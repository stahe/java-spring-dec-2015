{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Accueil","text":"<p>Introduction au langage Java et \u00e0 l'\u00e9cosyst\u00e8me Spring au travers d'une \u00e9tude de cas</p> <p>Serge Tah\u00e9, d\u00e9cembre 2015</p>"},{"location":"annexes.html","title":"22. Annexes","text":"<p>Nous pr\u00e9sentons ici comment installer les outils utilis\u00e9s dans ce document sur des machines windows 7 ou 8. Les copies d'\u00e9cran d\u00e9signent g\u00e9n\u00e9ralement les versions 64 bits des SGBD et outils install\u00e9s. Le lecteur s'adaptera \u00e0 son propre environnement.</p>"},{"location":"annexes.html#221-installation-dun-jdk","title":"22.1. Installation d'un JDK","text":"<p>On trouvera \u00e0 l'URL [http://www.oracle.com/technetwork/java/javase/downloads/index.html] (octobre 2014), le JDK le plus r\u00e9cent. On nommera par la suite &lt;jdk-install&gt; le dossier d'installation du JDK.</p>"},{"location":"annexes.html#222-installation-de-maven","title":"22.2. Installation de Maven","text":"<p>Maven est un outil de gestion des d\u00e9pendances d'un projet Java et plus encore. Il est disponible (octobre 2014) \u00e0 l'URL [http://maven.apache.org/download.cgi].</p> <p>T\u00e9l\u00e9chargez et d\u00e9zippez l'archive. Nous appellerons &lt;maven-install&gt; le dossier d'installation de Maven.</p> <ul> <li>en [1], le fichier [conf / settings.xml] configure Maven\u00a0; On y trouve les lignes suivantes\u00a0:</li> </ul> <pre><code>  &lt;!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository\n  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;\n--&gt;\n</code></pre> <p>La valeur par d\u00e9faut de la ligne 4 peut poser probl\u00e8me \u00e0 certains logiciels utilisant Maven, si comme moi votre {user.home} a un espace dans son chemin (par exemple [C:\\Users\\Serge Tah\u00e9]). On d\u00e9signera (ligne 7) un autre dossier pour le d\u00e9p\u00f4t local Maven\u00a0:</p> <pre><code>  &lt;!-- localRepository\n   | The path to the local repository maven will use to store artifacts.\n   |\n   | Default: ${user.home}/.m2/repository\n  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;\n  --&gt;\n&lt;localRepository&gt;D:\\Programs\\devjava\\maven\\.m2\\repository&lt;/localRepository&gt;\n</code></pre> <p>On \u00e9vitera, ligne 7, un chemin qui contient des espaces.</p>"},{"location":"annexes.html#223-installation-de-sts-spring-tool-suite","title":"22.3. Installation de STS (Spring Tool Suite)","text":"<p>Nous allons installer SpringSource Tool Suite [http://www.springsource.com/developer/sts] (octobre 2014), un Eclipse pr\u00e9-\u00e9quip\u00e9 avec de nombreux plugins li\u00e9s au framework Spring et \u00e9galement avec une configuration Maven pr\u00e9-install\u00e9e.</p> <ul> <li>aller sur le site de  SpringSource Tool Suite (STS) [1], pour t\u00e9l\u00e9charger la version courante de STS [2A] [2B],</li> </ul> <ul> <li>le fichier t\u00e9l\u00e9charg\u00e9 est un installateur qui cr\u00e9e l'arborescence de fichiers [3A] [3B]. En [4], on lance l'ex\u00e9cutable,</li> <li>en [5], la fen\u00eatre de travail de l'IDE apr\u00e8s avoir ferm\u00e9 la fen\u00eatre de bienvenue. En [6], on fait afficher la fen\u00eatre des serveurs d'applications,</li> </ul> <ul> <li>en [7], la fen\u00eatre des serveurs. Un serveur est enregistr\u00e9. C'est un serveur VMware compatible Tomcat. Il faut indiquer \u00e0 STS le dossier d'installation de Maven\u00a0:</li> </ul> <ul> <li>en [1-2], on configure STS\u00a0;</li> <li>en [3-4], on ajoute une nouvelle installation Maven\u00a0;</li> </ul> <ul> <li>en [5], on d\u00e9signe le dossier d'installation de Maven\u00a0;</li> <li>en [6], on termine l'assistant\u00a0;</li> <li>en [7], on fait de la nouvelle installation Maven, l'installation par d\u00e9faut\u00a0;</li> </ul> <ul> <li>en [8-9], on v\u00e9rifie le d\u00e9p\u00f4t local de Maven, le dossier o\u00f9 il mettra les d\u00e9pendances qu'il t\u00e9l\u00e9chargera et o\u00f9 STS mettra les artifacts qui seront construits\u00a0; Il faut \u00e9galement choisir un JDK (Java Development Kit) pour ex\u00e9cuter \u00e0 la fois les projets Eclipse sans et avec Maven [1-5].</li> </ul> <p>Avec [4], on peut ajouter des JDK (Java Development Kit) ou des JRE (Java Runtime Environment). Ce dernier sait ex\u00e9cuter des fichiers .class mais ne sait pas compiler les .java pour les produire. Le JDK sait faire les deux. On choisira un JDK parce que certaines op\u00e9rations Maven ont besoin d'un JDK.</p> <p>Pour cr\u00e9er un projet Eclipse, on proc\u00e8dera de la fa\u00e7on suivante\u00a0:</p> <ul> <li>en [3], donnez un nom au projet\u00a0;</li> <li>en [4], d\u00e9signez un dossier existant et vide\u00a0;</li> </ul> <ul> <li>en [5], le projet cr\u00e9\u00e9\u00a0;</li> <li>en [5-8], cr\u00e9ez un package. Un package est un dossier qui contient du code Java. Deux classes peuvent porter le m\u00eame nom si elles appartiennent \u00e0 des packages diff\u00e9rents. Dans un projet, il ne peut y avoir deux packages de m\u00eame nom. Ainsi on ne peut utiliser un nom de package qui existerait dans une des d\u00e9pendances du projet. Une entreprise utilisera comme nom de package, un nom pr\u00e9cisant l'entreprise, le projet et les diff\u00e9rentes branches de celui-ci\u00a0;</li> </ul> <ul> <li>en [9], donnez un nom au package\u00a0;</li> <li>en [10], le package cr\u00e9\u00e9\u00a0;</li> </ul> <ul> <li>en [11-13], on cr\u00e9e une classe dans le package qui a \u00e9t\u00e9 cr\u00e9\u00e9\u00a0;</li> </ul> <ul> <li>en [14], donnez un nom \u00e0 la classe (doit respecter la norme CamelCase - pour chaque mot du nom, commencer par une majuscule suivie de minuscules)\u00a0;</li> <li>en [15], v\u00e9rifiez le package\u00a0;</li> <li>en [16], cochez la case. Elle demande \u00e0 ce que la m\u00e9thode statique [main] soit g\u00e9n\u00e9r\u00e9e. Cette m\u00e9thode rend une classe ex\u00e9cutable, \u00e7-\u00e0-d la premi\u00e8re classe \u00e0 ex\u00e9cuter dans un projet\u00a0;</li> <li>en [17], la classe ainsi cr\u00e9\u00e9e\u00a0; Tapez dans la m\u00e9thode [main] le code suivant qui affiche un texte sur la console\u00a0:</li> </ul> <pre><code>package st.istia;\n\npublic class Test01 {\n\n    public static void main(String[] args) {\n        System.out.println(\"test01\");\n    }\n\n}\n</code></pre> <ul> <li>en [18-20], ex\u00e9cutez la classe. Sa m\u00e9thode [main] va alors \u00eatre ex\u00e9cut\u00e9e\u00a0;</li> </ul> <ul> <li>en [21-22], le r\u00e9sultat de l'application\u00a0; Si la vue [Console] n'est pas pr\u00e9sente, proc\u00e9dez comme suit [1-4]\u00a0:</li> </ul> <p>Il se peut qu'\u00e0 l'importation d'un projet Eclipse, celui-ci pr\u00e9sente des erreurs. Cela peut \u00eatre d\u00fb \u00e0 une configuration incorrecte du projet. Pour corriger l'erreur (si erreur il y a), proc\u00e9dez ainsi\u00a0:</p> <ul> <li>en [1], modifiez le [Build Path] du projet\u00a0;</li> </ul> <ul> <li>en [2], le projet est configur\u00e9 pour utiliser une JVM 1.5\u00a0;</li> <li>en [3], supprimez cette d\u00e9pendance\u00a0;</li> <li>en [4], ajoutez une nouvelle d\u00e9pendance\u00a0;</li> </ul> <ul> <li>en [5], on ajoute une JVM\u00a0;</li> <li>en [6], on choisit la JVM du poste\u00a0; Ceci fait, on valide le tout puis on passe \u00e0 la propri\u00e9t\u00e9 [Java compiler] du projet [7]\u00a0:</li> </ul> <ul> <li>en [8], on demande au compilateur d'accepter toutes les caract\u00e9ristiques du langage Java jusqu'\u00e0 sa version 1.7 (ou 1.8) comprise\u00a0;</li> <li>en [9], on valide\u00a0;</li> <li>en [10], le projet ainsi reconfigur\u00e9 ne doit plus pr\u00e9senter d'erreurs\u00a0; Par ailleurs, le projet import\u00e9 peut utiliser un encodage UTF-8 des caract\u00e8res. Proc\u00e9dez ainsi pour fixer cet encodage dans le projet import\u00e9 [1-4]\u00a0:</li> </ul> <p>Par ailleurs, il peut \u00eatre utile d'inhiber la v\u00e9rification orthographique dans le projet pour \u00e9viter que les commentaires en fran\u00e7ais soient soulign\u00e9s comme \u00e9tant incorrects. Suivez les \u00e9tapes [1-4] ci-dessous\u00a0:</p>"},{"location":"annexes.html#224-installation-de-lide-netbeans","title":"22.4. Installation de l'IDE Netbeans","text":"<p>Netbeans est disponible \u00e0 l'URL [http://netbeans.org/downloads/].</p> <p>On pourra prendre ci-dessus, la version Java SE (Standard Edition).</p>"},{"location":"annexes.html#225-installation-du-plugin-chrome-advanced-rest-client","title":"22.5. Installation du plugin Chrome [Advanced Rest Client]","text":"<p>Dans ce document, on utilise le navigateur Chrome de Google (http://www.google.fr/intl/fr/chrome/browser/ ). On lui ajoutera l'extension [Advanced Rest Client]. On pourra proc\u00e9der ainsi\u00a0:</p> <ul> <li>aller sur le site de [Google Web store] (https://chrome.google.com/webstore) avec le navigateur Chrome\u00a0;</li> <li>chercher l'application [Advanced Rest Client]\u00a0:</li> </ul> <ul> <li>l'application est alors disponible au t\u00e9l\u00e9chargement\u00a0:</li> </ul> <ul> <li>pour l'obtenir, il vous faudra cr\u00e9er un compte Google. [Google Web Store] demande ensuite confirmation [1]\u00a0:</li> </ul> <ul> <li>en [2], l'extension ajout\u00e9e est disponible dans l'option [Applications] [3]. Cette option est affich\u00e9e sur chaque nouvel onglet que vous cr\u00e9ez (CTRL-T) dans le navigateur.</li> </ul>"},{"location":"annexes.html#226-gestion-du-json-en-java","title":"22.6. Gestion du jSON en Java","text":"<p>De fa\u00e7on transparente pour le d\u00e9veloppeur le framework [Spring MVC] utilise la biblioth\u00e8que jSON [Jackson]. Pour illustrer ce qu'est le jSON (JavaScript Object Notation), nous pr\u00e9sentons ici un programme qui s\u00e9rialise des objets en jSON et fait l'inverse en d\u00e9s\u00e9rialisant les cha\u00eenes jSON produites pour recr\u00e9er les objets initiaux.</p> <p>La biblioth\u00e8que 'Jackson' permet de construire\u00a0:</p> <ul> <li>la cha\u00eene jSON d'un objet\u00a0: new ObjectMapper().writeValueAsString(object)\u00a0;</li> <li>un objet \u00e0 partir d'un cha\u00eene jSON\u00a0: new ObjectMapper().readValue(jsonString, Object.class). Les deux m\u00e9thodes sont susceptibles de lancer une IOException. Voici un exemple.</li> </ul> <p>Le projet ci-dessus est un projet Maven avec le fichier [pom.xml] suivant\u00a0;</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;istia.st.pam&lt;/groupId&gt;\n  &lt;artifactId&gt;json&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n      &lt;version&gt;2.3.3&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 12-16\u00a0: la d\u00e9pendance qui am\u00e8ne la biblioth\u00e8que 'Jackson'\u00a0; La classe [Personne] est la suivante\u00a0:</li> </ul> <pre><code>package istia.st.json;\n\npublic class Personne {\n    // data\n    private String nom;\n    private String prenom;\n    private int age;\n\n    // constructeurs\n    public Personne() {\n\n    }\n\n    public Personne(String nom, String pr\u00e9nom, int \u00e2ge) {\n        this.nom = nom;\n        this.prenom = pr\u00e9nom;\n        this.age = \u00e2ge;\n    }\n\n    // signature\n    public String toString() {\n        return String.format(\"Personne[%s, %s, %d]\", nom, prenom, age);\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>La classe [Main] est la suivante\u00a0:</p> <pre><code>package istia.st.json;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n  // l'outil de s\u00e9rialisation / d\u00e9s\u00e9rialisation\n  static ObjectMapper mapper = new ObjectMapper();\n\n  public static void main(String[] args) throws IOException {\n    // cr\u00e9ation d'une personne\n    Personne paul = new Personne(\"Denis\", \"Paul\", 40);\n    // affichage jSON\n    String json = mapper.writeValueAsString(paul);\n    System.out.println(\"Json=\" + json);\n    // instanciation Personne \u00e0 partir du Json\n    Personne p = mapper.readValue(json, Personne.class);\n    // affichage personne\n    System.out.println(\"Personne=\" + p);\n    // un tableau\n    Personne virginie = new Personne(\"Radot\", \"Virginie\", 20);\n    Personne[] personnes = new Personne[]{paul, virginie};\n    // affichage Json\n    json = mapper.writeValueAsString(personnes);\n    System.out.println(\"Json personnes=\" + json);\n    // dictionnaire\n    Map&lt;String, Personne&gt; hpersonnes = new HashMap&lt;String, Personne&gt;();\n    hpersonnes.put(\"1\", paul);\n    hpersonnes.put(\"2\", virginie);\n    // affichage Json\n    json = mapper.writeValueAsString(hpersonnes);\n    System.out.println(\"Json hpersonnes=\" + json);\n  }\n}\n</code></pre> <p>L'ex\u00e9cution de cette classe produit l'affichage \u00e9cran suivant\u00a0:</p> <pre><code>Json={\"nom\":\"Denis\",\"prenom\":\"Paul\",\"age\":40}\nPersonne=Personne[Denis, Paul, 40]\nJson personnes=[{\"nom\":\"Denis\",\"prenom\":\"Paul\",\"age\":40},{\"nom\":\"Radot\",\"prenom\":\"Virginie\",\"age\":20}]\nJson hpersonnes={\"2\":{\"nom\":\"Radot\",\"prenom\":\"Virginie\",\"age\":20},\"1\":{\"nom\":\"Denis\",\"prenom\":\"Paul\",\"age\":40}}\n</code></pre> <p>De l'exemple on retiendra\u00a0:</p> <ul> <li>l'objet [ObjectMapper] n\u00e9cessaire aux transformations jSON / Object\u00a0: ligne 11\u00a0;</li> <li>la transformation [Personne] --&gt; jSON\u00a0: ligne 17\u00a0;</li> <li>la transformation jSON --&gt; [Personne]\u00a0: ligne 20\u00a0;</li> <li>l'exception [IOException] lanc\u00e9e par les deux m\u00e9thodes\u00a0: ligne 13.</li> </ul>"},{"location":"annexes.html#227-installation-de-wampserver","title":"22.7. Installation de [WampServer]","text":"<p>[WampServer] est un ensemble de logiciels pour d\u00e9velopper en PHP / MySQL / Apache sur une machine Windows. Nous l'utiliserons uniquement pour le SGBD MySQL.</p> <ul> <li>sur le site de [WampServer] [1], choisir la version qui convient [2],</li> <li>l'ex\u00e9cutable t\u00e9l\u00e9charg\u00e9 est un installateur. Diverses informations sont demand\u00e9es au cours de l'installation. Elles ne concernent pas MySQL. On peut donc les ignorer. La fen\u00eatre [3] s'affiche \u00e0 la fin de l'installation. On lance [WampServer],</li> </ul> <ul> <li>en [4], l'ic\u00f4ne de [WampServer] s'installe dans la barre des t\u00e2ches en bas et \u00e0 droite de l'\u00e9cran [4],</li> <li>lorsqu'on clique dessus, le menu [5] s'affiche. Il permet de g\u00e9rer le serveur Apache et le SGBD MySQL. Pour g\u00e9rer celui-ci, on utiliser l'option [PhpPmyAdmin],</li> <li>on obtient alors la fen\u00eatre ci-dessous,</li> </ul> <p></p> <p>Nous donnerons peu de d\u00e9tails sur l'utilisation de [PhpMyAdmin]. Nous montrons au paragraphe 6.4.2, page 85, comment l'utiliser pour cr\u00e9er une base de donn\u00e9es \u00e0 partir d'un script SQL.</p>"},{"location":"conclusion.html","title":"21. Conclusion","text":"<p>Il a \u00e9t\u00e9 \u00e9crit en introduction de ce document\u00a0:</p> <p>Son objectif est d'enseigner le langage Java dans une optique professionnelle. Pour cette raison, nous nous appuyons fortement sur le framework Spring [http://spring.io/] tr\u00e8s utilis\u00e9 dans le d\u00e9veloppement JEE (Java Enterprise Edition). Logiquement, ce cours devrait \u00eatre suivi par un cours JEE.</p> <p>Le lecteur int\u00e9ress\u00e9 pourra poursuivre avec divers documents enseignant JEE\u00a0:</p> <ul> <li>[Introduction \u00e0 Struts 2 par l'exemple] (2012). Struts a \u00e9t\u00e9 le premier framework MVC dans le monde JEE, il y a plus de 10 ans (~2005). Struts 2 est une \u00e9volution du framework Struts initial\u00a0;</li> <li>[Introduction \u00e0 JSF2, Primefaces et Primefaces mobile] (2012). Ce document pr\u00e9sente un autre framework MVC du mode JEE, la version 2 de JSF (Java Server Faces) ainsi que les EJB3 (Enterprise Java Bean) qui offrent des possibilit\u00e9s se rapprochant de ce qu'offre Spring. Il pr\u00e9sente \u00e9galement [Primefaces] une biblioth\u00e8que de composants Ajax (Asynchronous Javascript And Xml) pour JSF et sa version [Primefaces mobile] \u00e0 destination des smartphones et tablettes\u00a0;</li> <li>[Tutoriel Angular JS et Spring 4] (2014) qui pr\u00e9sente une autre architecture web, celle du client / serveur. Ici,</li> <li>le client est construit avec le framework jS Angular\u00a0;</li> <li>le serveur est construit avec Spring MVC\u00a0;</li> <li>[Spring MVC et Thymeleaf] (2015) qui pr\u00e9sente les d\u00e9tails de Spring MVC et associe celui-ci au g\u00e9n\u00e9rateur de pages Thymeleaf. L'application construite est la m\u00eame que celle du document [Tutoriel Angular JS et Spring 4], ce qui permet de comparer les deux architectures\u00a0;</li> <li>[Exploiter une base de donn\u00e9es relationnelle avec l'\u00e9cosyst\u00e8me Spring] (2015). Ce document est celui \u00e0 partir duquel a \u00e9t\u00e9 \u00e9crit ce TD. Il n'apporte rien de plus si ce n'est que les exemples ont \u00e9t\u00e9 trait\u00e9s avec 6 SGBD (MySQL, Oracle, SQL Server, PostgreSQL, IBM DB2, Firebird) et 3 impl\u00e9mentation JPA (Hibernate, EclipseLink, OpenJPA). Son objectif est de montrer comment architecturer une application afin qu'elle soit portable d'un SGBD \u00e0 un autre et d'une impl\u00e9mentation JPA \u00e0 une autre\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html","title":"13. [Cours]\u00a0: Exposer une base de donn\u00e9es sur le web avec Spring MVC","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, service web / jSON, client / serveur</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#131-support","title":"13.1. Support","text":"<p>Les projets de ce chapitre seront trouv\u00e9s dans le dossier [support / chap-13]. Le script SQL [dbintrospringdata.sql] permet de cr\u00e9er la base MySQL n\u00e9cessaire aux tests.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#132-la-place-de-spring-mvc-dans-une-application-web","title":"13.2. La place de Spring MVC dans une application Web","text":"<p>Situons Spring MVC dans le d\u00e9veloppement d'une application Web. Le plus souvent, celle-ci sera b\u00e2tie sur une architecture multicouche telle que la suivante\u00a0:</p> <ul> <li>la couche [Web] est la couche en contact avec l'utilisateur de l'application Web. Celui-ci interagit avec l'application Web au travers de pages Web visualis\u00e9es par un navigateur. C'est dans cette couche que se situe Spring MVC et uniquement dans cette couche\u00a0;</li> <li>la couche [m\u00e9tier] impl\u00e9mente les r\u00e8gles de gestion de l'application, tels que le calcul d'un salaire ou d'une facture. Cette couche utilise des donn\u00e9es provenant de l'utilisateur via la couche [Web] et du SGBD via la couche [DAO]\u00a0;</li> <li>la couche [DAO] (Data Access Objects), la couche [ORM] (Object Relational Mapper) et le pilote JDBC g\u00e8rent l'acc\u00e8s aux donn\u00e9es du SGBD. La couche [ORM]  fait un pont entre les objets manipul\u00e9s par la couche [DAO] et les lignes et les colonnes des tables d'une base de donn\u00e9es relationnelle. La sp\u00e9cification JPA (Java Persistence API) permet de s'abstraire de l'ORM utilis\u00e9 si celui-ci impl\u00e9mente ces sp\u00e9cifications. Ce sera le cas ici et nous appellerons d\u00e9sormais la couche ORM, la couche JPA\u00a0;</li> <li>l'int\u00e9gration des couches est faite par le framework Spring\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#133-le-modele-de-developpement-de-spring-mvc","title":"13.3. Le mod\u00e8le de d\u00e9veloppement de Spring MVC","text":"<p>Spring MVC impl\u00e9mente le mod\u00e8le d'architecture dit MVC (Mod\u00e8le \u2013 Vue \u2013 Contr\u00f4leur) de la fa\u00e7on suivante\u00a0:</p> <p>Le traitement d'une demande d'un client se d\u00e9roule de la fa\u00e7on suivante :</p> <ul> <li>demande - les URL demand\u00e9es sont de la forme http://machine:port/contexte/Action/param1/param2/....?p1=v1&amp;p2=v2&amp;... Le [Front Controller] utilise un fichier de configuration ou des annotations Java pour \"\u00a0router\u00a0\" la demande vers le bon contr\u00f4leur et la bonne action au sein de ce contr\u00f4leur. Pour cela, il utilise le champ [Action] de l'URL. Le reste de l'URL [/param1/param2/...] est form\u00e9 de param\u00e8tres facultatifs qui seront transmis \u00e0 l'action. Le C de MVC est ici la cha\u00eene [Front Controller, Contr\u00f4leur, Action]. Si aucun contr\u00f4leur ne peut traiter l'action demand\u00e9e, le serveur Web r\u00e9pondra que l'URL demand\u00e9e n'a pas \u00e9t\u00e9 trouv\u00e9e.</li> <li>traitement </li> <li>l'action choisie peut exploiter les param\u00e8tres parami que le [Front Controller] lui a transmis. Ceux-ci peuvent provenir de plusieurs sources\u00a0:</li> <li>du chemin [/param1/param2/...] de l'URL,</li> <li>des param\u00e8tres [p1=v1&amp;p2=v2] de l'URL,</li> <li>de param\u00e8tres post\u00e9s par le navigateur avec sa demande\u00a0;</li> <li>dans le traitement de la demande de l'utilisateur, l'action peut avoir besoin de la couche [m\u00e9tier] [2b]. Une fois la demande du client trait\u00e9e, celle-ci peut appeler diverses r\u00e9ponses. Un exemple classique est :</li> <li>une page d'erreur si la demande n'a pu \u00eatre trait\u00e9e correctement</li> <li>une page de confirmation sinon</li> <li>l'action demande \u00e0 une certaine vue de s'afficher [3]. Cette vue va afficher des donn\u00e9es qu'on appelle le mod\u00e8le de la vue. C'est le M de MVC. L'action va cr\u00e9er ce mod\u00e8le M [2c] et demander \u00e0 une vue V de s'afficher [3]\u00a0;</li> <li>r\u00e9ponse - la vue V choisie utilise le mod\u00e8le M construit par l'action pour initialiser les parties dynamiques de la r\u00e9ponse HTML qu'elle doit envoyer au client puis envoie cette r\u00e9ponse. Pour un service web / jSON, l'architecture pr\u00e9c\u00e9dente est l\u00e9g\u00e8rement modifi\u00e9e\u00a0:</li> </ul> <ul> <li>en [4a], le mod\u00e8le qui est une classe Java est transform\u00e9 en cha\u00eene jSON par une biblioth\u00e8que jSON\u00a0;</li> <li>en [4b], cette cha\u00eene jSON est envoy\u00e9e au navigateur\u00a0; Maintenant, pr\u00e9cisons le lien entre architecture web MVC et architecture en couches. Selon la d\u00e9finition qu'on donne au mod\u00e8le, ces deux concepts sont li\u00e9s ou non. Prenons une application web Spring MVC \u00e0 une couche\u00a0:</li> </ul> <p>Si nous impl\u00e9mentons la couche [Web] avec Spring MVC, nous aurons bien une architecture web MVC mais pas une architecture multicouche. Ici, la couche [web] s'occupera de tout\u00a0: pr\u00e9sentation, m\u00e9tier, acc\u00e8s aux donn\u00e9es. Ce sont les actions qui feront ce travail.</p> <p>Maintenant, consid\u00e9rons une architecture Web multicouche\u00a0:</p> <p>La couche [Web] peut \u00eatre impl\u00e9ment\u00e9e sans framework et sans suivre le mod\u00e8le MVC. On a bien alors une architecture multicouche mais la couche Web n'impl\u00e9mente pas le mod\u00e8le MVC.</p> <p>Par exemple, dans le monde .NET la couche [Web] ci-dessus peut \u00eatre impl\u00e9ment\u00e9e avec ASP.NET MVC et on a alors une architecture en couches avec une couche [Web] de type MVC. Ceci fait, on peut remplacer cette couche ASP.NET MVC par une couche ASP.NET classique (WebForms) tout en gardant le reste (m\u00e9tier, DAO, ORM) \u00e0 l'identique.  On a alors une architecture en couches avec une couche [Web] qui n'est plus de type MVC.</p> <p>Dans MVC, nous avons dit que le mod\u00e8le M \u00e9tait celui de la vue V, c.a.d. l'ensemble des donn\u00e9es affich\u00e9es par la vue V. Une autre d\u00e9finition du mod\u00e8le M de MVC est donn\u00e9e\u00a0:</p> <p>Beaucoup d'auteurs consid\u00e8rent que ce qui est \u00e0 droite de la couche [Web] forme le mod\u00e8le M du MVC. Pour \u00e9viter les ambig\u00fcit\u00e9s on peut parler\u00a0:</p> <ul> <li>du mod\u00e8le du domaine lorsqu'on d\u00e9signe tout ce qui est \u00e0 droite de la couche [Web]</li> <li>du mod\u00e8le de la vue lorsqu'on d\u00e9signe les donn\u00e9es affich\u00e9es par une vue V Dans la suite, le terme \"\u00a0mod\u00e8le M\u00a0\" d\u00e9signera exclusivement le mod\u00e8le d'une vue V.</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#134-un-projet-web-json-avec-spring-mvc","title":"13.4. Un projet web / jSON avec Spring MVC","text":"<p>Le site [http://spring.io/guides] offre des tutoriels de d\u00e9marrage pour d\u00e9couvrir l'\u00e9cosyst\u00e8me Spring. Nous allons suivre l'un d'eux pour d\u00e9couvrir la configuration Maven n\u00e9cessaire \u00e0 un projet Spring MVC.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1341-le-projet-de-demonstration","title":"13.4.1. Le projet de d\u00e9monstration","text":"<ul> <li>en [1], nous importons l'un des guides Spring\u00a0;</li> </ul> <ul> <li>en [2], nous choisissons l'exemple [Rest Service]\u00a0;</li> <li>en [3], on choisit le projet Maven\u00a0;</li> <li>en [4], on prend la version finale du guide\u00a0;</li> <li>en [5], on valide\u00a0;</li> <li>en [6], le projet import\u00e9\u00a0; Les services web accessibles via des URL standard et qui d\u00e9livrent du texte jSON sont souvent appel\u00e9s des services REST (REpresentational State Transfer). Un service est dit Restful s'il respecte certaines r\u00e8gles.</li> </ul> <p>Examinons maintenant le projet import\u00e9, d'abord sa configuration Maven.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1342-configuration-maven","title":"13.4.2. Configuration Maven","text":"<p>Le fichier [pom.xml] est le suivant\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-rest-service&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;start-class&gt;hello.Application&lt;/start-class&gt;\n    &lt;/properties&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;spring-releases&lt;/id&gt;\n            &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n    &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;spring-releases&lt;/id&gt;\n            &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;\n        &lt;/pluginRepository&gt;\n    &lt;/pluginRepositories&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 6-8\u00a0: les propri\u00e9t\u00e9s du projet Maven. Manque une balise [&lt;packaging&gt;] indiquant le type du fichier produit par la compilation Maven. En l'absence de celle-ci, c'est le type [jar] qui est utilis\u00e9. L'application est donc une application ex\u00e9cutable de type console, et non une application web o\u00f9 le packaging serait alors [war]\u00a0;</li> <li>lignes 10-14\u00a0: le projet Maven a un projet parent [spring-boot-starter-parent]. C'est lui qui d\u00e9finit l'essentiel des d\u00e9pendances du projet. Elles peuvent \u00eatre suffisantes, auquel cas on n'en rajoute pas, ou pas, auquel cas on rajoute les d\u00e9pendances manquantes\u00a0;</li> <li>lignes 17-20\u00a0: l'artifact [spring-boot-starter-web] am\u00e8ne avec lui les biblioth\u00e8ques n\u00e9cessaires \u00e0 un projet Spring MVC de type service web o\u00f9 il n'y a pas de vues g\u00e9n\u00e9r\u00e9es. Cet artifact am\u00e8ne avec lui un tr\u00e8s grand nombre de biblioth\u00e8ques dont celles d'un serveur Tomcat embarqu\u00e9. C'est sur ce serveur que l'application sera ex\u00e9cut\u00e9e\u00a0; Les biblioth\u00e8ques amen\u00e9es par cette configuration sont tr\u00e8s nombreuses\u00a0:</li> </ul> <p>Ci-dessus on voit les trois archives du serveur Tomcat.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1343-larchitecture-dun-service-spring-web-json","title":"13.4.3. L'architecture d'un service Spring [web / jSON]","text":"<p>Pour un service web / jSON, Spring MVC impl\u00e9mente le mod\u00e8le MVC de la fa\u00e7on suivante\u00a0:</p> <ul> <li>en [4a], le mod\u00e8le qui est une classe Java est transform\u00e9 en cha\u00eene jSON par une biblioth\u00e8que jSON\u00a0;</li> <li>en [4b], cette cha\u00eene jSON est envoy\u00e9e au navigateur\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1344-le-controleur-c","title":"13.4.4. Le contr\u00f4leur C","text":"<p>L'application import\u00e9e a le contr\u00f4leur suivant\u00a0:</p> <pre><code>package hello;\n\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class GreetingController {\n\n    private static final String template = \"Hello, %s!\";\n    private final AtomicLong counter = new AtomicLong();\n\n    @RequestMapping(\"/greeting\")\n    public Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n        return new Greeting(counter.incrementAndGet(), String.format(template, name));\n    }\n}\n</code></pre> <ul> <li>ligne 9\u00a0: l'annotation [@RestController] fait de la classe [GreetingController] un contr\u00f4leur Spring, \u00e7-\u00e0-d que ses m\u00e9thodes sont enregistr\u00e9es pour traiter des URL. Nous avons vu l'annotation similaire [@Controller]. Le r\u00e9sultat des m\u00e9thodes de ce contr\u00f4leur \u00e9tait un type [String] qui \u00e9tait le nom de la vue \u00e0 afficher. Ici c'est diff\u00e9rent. Les m\u00e9thodes d'un contr\u00f4leur de type [@RestController] rendent des objets qui sont s\u00e9rialis\u00e9s pour \u00eatre envoy\u00e9s au navigateur. Le type de s\u00e9rialisation op\u00e9r\u00e9e d\u00e9pend de la configuration de Spring MVC. Ici, ils seront s\u00e9rialis\u00e9s en jSON. C'est la pr\u00e9sence d'une biblioth\u00e8que jSON dans les d\u00e9pendances du projet qui fait que Spring Boot va, par autoconfiguration, configurer le projet de cette fa\u00e7on\u00a0;</li> <li>ligne 14\u00a0: l'annotation [@RequestMapping] indique l'URL que traite la m\u00e9thode, ici l'URL [/greeting]\u00a0;</li> <li>ligne 15\u00a0: nous avons d\u00e9j\u00e0 expliqu\u00e9 l'annotation [@RequestParam]. Le r\u00e9sultat rendu par la m\u00e9thode est un objet de type [Greeting].</li> <li>ligne 12\u00a0: un entier long de type atomique. Cela signifie qu'il supporte la concurrence d'acc\u00e8s. Plusieurs threads peuvent vouloir incr\u00e9menter la variable [counter] en m\u00eame temps. Cela se fera proprement. Un thread ne peut lire la valeur du compteur que si le thread en train de le modifier a termin\u00e9 sa modification.</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1345-le-modele-m","title":"13.4.5. Le mod\u00e8le M","text":"<p>Le mod\u00e8le M produit par la m\u00e9thode pr\u00e9c\u00e9dente est l'objet [Greeting] suivant\u00a0:</p> <pre><code>package hello;\n\npublic class Greeting {\n\n    private final long id;\n    private final String content;\n\n    public Greeting(long id, String content) {\n        this.id = id;\n        this.content = content;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}\n</code></pre> <p>La transformation jSON de cet objet cr\u00e9era la cha\u00eene de caract\u00e8res {\"id\":n,\"content\":\"texte\"}. Au final, la cha\u00eene jSON produite par la m\u00e9thode du contr\u00f4leur sera de la forme\u00a0:</p> <pre><code>{\"id\":2,\"content\":\"Hello, World!\"}\n</code></pre> <p>ou </p> <pre><code>{\"id\":2,\"content\":\"Hello, John!\"}\n</code></pre>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1346-execution","title":"13.4.6. Ex\u00e9cution","text":"<p>La classe [Application.java] est la classe ex\u00e9cutable du projet. Son code est le suivant\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.context.annotation.ComponentScan;\n\n@ComponentScan\n@EnableAutoConfiguration\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n</code></pre> <p>Nous avons d\u00e9j\u00e0 rencontr\u00e9 et expliqu\u00e9 ce code dans l'exemple pr\u00e9c\u00e9dent.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1347-execution-du-projet","title":"13.4.7. Ex\u00e9cution du projet","text":"<p>Ex\u00e9cutons le projet\u00a0:</p> <p>On obtient les logs console suivants\u00a0:</p> <pre><code>  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.1.9.RELEASE)\n\n2014-11-28 15:22:55.005  INFO 3152 --- [           main] hello.Application                        : Starting Application on Gportpers3 with PID 3152 (started by ST in D:\\data\\istia-1415\\spring mvc\\dvp-final\\gs-rest-service)\n2014-11-28 15:22:55.046  INFO 3152 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@62e136d3: startup date [Fri Nov 28 15:22:55 CET 2014]; root of context hierarchy\n2014-11-28 15:22:55.762  INFO 3152 --- [           main] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'beanNameViewResolver': replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration; factoryMethodName=beanNameViewResolver; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/web/ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter; factoryMethodName=beanNameViewResolver; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]]\n2014-11-28 15:22:56.567  INFO 3152 --- [           main] .t.TomcatEmbeddedServletContainerFactory : Server initialized with port: 8080\n2014-11-28 15:22:56.738  INFO 3152 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat\n2014-11-28 15:22:56.740  INFO 3152 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.56\n2014-11-28 15:22:56.869  INFO 3152 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2014-11-28 15:22:56.870  INFO 3152 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1827 ms\n2014-11-28 15:22:57.478  INFO 3152 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]\n2014-11-28 15:22:57.481  INFO 3152 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]\n2014-11-28 15:22:57.685  INFO 3152 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2014-11-28 15:22:57.879  INFO 3152 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/greeting],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public hello.Greeting hello.GreetingController.greeting(java.lang.String)\n2014-11-28 15:22:57.884  INFO 3152 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)\n2014-11-28 15:22:57.885  INFO 3152 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],methods=[],params=[],headers=[],consumes=[],produces=[text/html],custom=[]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest)\n2014-11-28 15:22:57.906  INFO 3152 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2014-11-28 15:22:57.907  INFO 3152 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2014-11-28 15:22:58.231  INFO 3152 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2014-11-28 15:22:58.318  INFO 3152 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080/http\n2014-11-28 15:22:58.319  INFO 3152 --- [           main] hello.Application                        : Started Application in 3.788 seconds (JVM running for 4.424)\n</code></pre> <ul> <li>ligne 13\u00a0: le serveur Tomcat d\u00e9marre sur le port 8080 (ligne 12)\u00a0;</li> <li>ligne 17\u00a0: la servlet [DispatcherServlet] est pr\u00e9sente\u00a0;</li> <li>ligne 20\u00a0: la m\u00e9thode [GreetingController.greeting] a \u00e9t\u00e9 d\u00e9couverte\u00a0; Pour tester l'application web, on demande l'URL [http://localhost:8080/greeting]\u00a0:</li> </ul> <p>On re\u00e7oit bien la cha\u00eene jSON attendue. Il peut \u00eatre int\u00e9ressant de voir les ent\u00eates HTTP envoy\u00e9s par le serveur. Pour cela, on va utiliser l'extension de Chrome appel\u00e9e [Advanced Rest Client] (Chrome / Ctrl-T / Menu [Applications] / [Advanced Rest Client] - cf Annexes page 422)\u00a0:</p> <ul> <li>en [1], l'URL demand\u00e9e\u00a0;</li> <li>en [2], la m\u00e9thode GET est utilis\u00e9e\u00a0;</li> <li>en [3], la r\u00e9ponse jSON\u00a0;</li> <li>en [4], le serveur a indiqu\u00e9 qu'il envoyait une r\u00e9ponse au format jSON\u00a0;</li> <li>en [5], on demande la m\u00eame URL mais cette fois-ci avec un POST\u00a0;</li> <li>en [7], les informations sont envoy\u00e9es au serveur sous la forme [urlencoded]\u00a0;</li> <li>en [6], le param\u00e8tre name avec sa valeur\u00a0;</li> <li>en [8], le navigateur indique au serveur qu'il lui envoie des informations [urlencoded]\u00a0;</li> <li>en [9], la r\u00e9ponse jSON du serveur\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1348-creation-dune-archive-executable","title":"13.4.8. Cr\u00e9ation d'une archive ex\u00e9cutable","text":"<p>Nous cr\u00e9ons maintenant une archive ex\u00e9cutable\u00a0:</p> <ul> <li>en [1]\u00a0: on ex\u00e9cute une cible Maven\u00a0;</li> <li>en [2]\u00a0: il y a deux cibles (goals)\u00a0: [clean] pour supprimer le dossier [target] du projet Maven, [package] pour le r\u00e9g\u00e9n\u00e9rer\u00a0;</li> <li>en [3]\u00a0: le dossier [target] g\u00e9n\u00e9r\u00e9, le sera dans ce dossier\u00a0;</li> <li>en [4]\u00a0: on g\u00e9n\u00e8re la cible\u00a0; Dans les logs qui apparaissent dans la console, il est important de voir appara\u00eetre le plugin [spring-boot-maven-plugin]. C'est lui qui g\u00e9n\u00e8re l'archive ex\u00e9cutable.</li> </ul> <pre><code>[INFO] --- spring-boot-maven-plugin:1.1.0.RELEASE:repackage (default) @ gs-rest-service ---\n</code></pre> <p>Avec une console, on se place dans le dossier g\u00e9n\u00e9r\u00e9\u00a0:</p> <pre><code>D:\\Temp\\wksSTS\\gs-rest-service\\target&gt;dir\n ...\n11/06/2014  15:30    &lt;DIR&gt;          classes\n11/06/2014  15:30    &lt;DIR&gt;          generated-sources\n11/06/2014  15:30        11\u00a0073\u00a0572 gs-rest-service-0.1.0.jar\n11/06/2014  15:30             3\u00a0690 gs-rest-service-0.1.0.jar.original\n11/06/2014  15:30    &lt;DIR&gt;          maven-archiver\n11/06/2014  15:30    &lt;DIR&gt;          maven-status\n...\n</code></pre> <ul> <li>ligne 5\u00a0: l'archive g\u00e9n\u00e9r\u00e9e\u00a0; Cette archive est ex\u00e9cut\u00e9e de la fa\u00e7on suivante\u00a0:</li> </ul> <pre><code>D:\\Temp\\wksSTS\\gs-rest-service-complete\\target&gt;java -jar gs-rest-service-0.1.0.jar\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.1.0.RELEASE)\n\n2014-06-11 15:32:47.088  INFO 4972 --- [           main] hello.Application\n                  : Starting Application on Gportpers3 with PID 4972 (D:\\Temp\\wk\nsSTS\\gs-rest-service-complete\\target\\gs-rest-service-0.1.0.jar started by ST in\nD:\\Temp\\wksSTS\\gs-rest-service-complete\\target)\n...\n</code></pre> <p>Maintenant que l'application web est lanc\u00e9e, on peut l'interroger avec un navigateur\u00a0:</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1349-deployer-lapplication-sur-un-serveur-tomcat","title":"13.4.9. D\u00e9ployer l'application sur un serveur Tomcat","text":"<p>Comme il a \u00e9t\u00e9 fait pour le projet pr\u00e9c\u00e9dent, nous modifions le fichier [pom.xml] de la fa\u00e7on suivante\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-rest-service&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    ...\n&lt;/project&gt;\n</code></pre> <ul> <li>ligne 9\u00a0: il faut indiquer qu'on va g\u00e9n\u00e9rer une archive war (Web ARchive)\u00a0; Il faut par ailleurs configurer l'application web. En l'absence de fichier [web.xml], cela se fait avec une classe h\u00e9ritant de [SpringBootServletInitializer]\u00a0:</li> </ul> <p>La classe [ApplicationInitializer] est la suivante\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.boot.builder.SpringApplicationBuilder;\nimport org.springframework.boot.context.web.SpringBootServletInitializer;\n\npublic class ApplicationInitializer extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(Application.class);\n    }\n\n}\n</code></pre> <ul> <li>ligne 6\u00a0: la classe [ApplicationInitializer] \u00e9tend la classe [SpringBootServletInitializer]\u00a0;</li> <li>ligne 9\u00a0: la m\u00e9thode [configure] est red\u00e9finie (ligne 8)\u00a0;</li> <li>ligne 10\u00a0: on fournit la classe qui configure le projet\u00a0; Pour ex\u00e9cuter le projet, on peut proc\u00e9der ainsi\u00a0:</li> </ul> <ul> <li>en [1-2], on ex\u00e9cute le projet sur l'un des serveurs enregistr\u00e9s dans l'IDE Eclipse\u00a0; Ceci fait, on peut demander l'URL [http://localhost:8080/gs-rest-service/greeting/?name=Mitchell] dans un navigateur\u00a0:</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13410-conclusion","title":"13.4.10. Conclusion","text":"<p>Nous avons introduit un type de projets Spring MVC o\u00f9 l'application web envoie un flux jSON au navigateur. Nous allons d\u00e9velopper maintenant une application web / jSON pour exposer sur le web la base [dbintrospringdata] \u00e9tudi\u00e9e dans le tutoriel [Introduction \u00e0 Spring Data].</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#135-exposer-la-base-dbintrospringdata-sur-le-web","title":"13.5. Exposer la base [dbintrospringdata] sur le web","text":""},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1351-architecture-du-service-web-json","title":"13.5.1. Architecture du service web / jSON","text":"<p>Nous allons mettre en place l'architecture suivante\u00a0:</p> <p>Les couches [DAO] et [JPA] sont impl\u00e9ment\u00e9es par l'application \u00e9crite dans le tutoriel [Introduction \u00e0 Spring Data].</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1352-installation-de-la-base-de-donnees","title":"13.5.2. Installation de la base de donn\u00e9es","text":"<p>Le script SQL [dbintrospringdata.sql] permet de cr\u00e9er la base MySQL n\u00e9cessaire aux tests.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1353-le-projet-eclipse-du-service-web-json","title":"13.5.3. Le projet Eclipse du service web / jSON","text":"<p>Le projet Eclipse du service web / jSON est le suivant\u00a0:</p> <p>C'est un projet Maven dont le fichier [pom.xml] est le suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.webjson&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-server-webjson01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;name&gt;intro-server-webjson01&lt;/name&gt;\n    &lt;description&gt;d\u00e9mo spring mvc&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.springdata&lt;/groupId&gt;\n            &lt;artifactId&gt;intro-spring-data-01&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 11-15\u00a0: le projet Maven parent d\u00e9j\u00e0 utilis\u00e9 pour la couche [DAO]\u00a0;</li> <li>lignes 18-22\u00a0: la d\u00e9pendance sur la couche [DAO]\u00a0;</li> <li>lignes 23-26\u00a0: la d\u00e9pendance sur l'artifact [spring-boot-starter-web]. Cet artifact am\u00e8ne avec lui toutes les d\u00e9pendances n\u00e9cessaires \u00e0 la cr\u00e9ation d'un service web / jSON. Il am\u00e8ne aussi des biblioth\u00e8ques inutiles. Une configuration plus pr\u00e9cise serait donc n\u00e9cessaire. Mais cette configuration est pratique pour d\u00e9marrer\u00a0;</li> <li>lignes 28-30\u00a0: la d\u00e9pendance sur l'artifact [spring-boot-starter] permet de g\u00e9rer les annotation Spring Boot\u00a0; Les d\u00e9pendances amen\u00e9es par cette configuration sont les suivantes\u00a0:</li> </ul> <ul> <li>en [1], on voit qu'Eclipse a vu la d\u00e9pendance sur l'archive du projet [intro-spring-data-01]\u00a0; Les d\u00e9pendances ci-dessus sont \u00e0 la fois celles de la couche [DAO] et de la couche [web].</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13531-configuration-de-la-couche-web","title":"13.5.3.1. Configuration de la couche [web]","text":"<p>La couche [web] est configur\u00e9e par un fichier [AppConfig]\u00a0:</p> <p>La classe [WebConfig] configure la couche [web]\u00a0:</p> <pre><code>package spring.webjson.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;\nimport org.springframework.boot.context.embedded.ServletRegistrationBean;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\nimport com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n\n@EnableWebMvc\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    // -------------------------------- configuration couche [web]\n    @Autowired\n    private ApplicationContext context;\n\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        DispatcherServlet servlet = new DispatcherServlet((WebApplicationContext) context);\n        return servlet;\n    }\n\n    @Bean\n    public ServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) {\n        return new ServletRegistrationBean(dispatcherServlet, \"/*\");\n    }\n\n    @Bean\n    public EmbeddedServletContainerFactory embeddedServletContainerFactory() {\n        return new TomcatEmbeddedServletContainerFactory(\"\", 8080);\n    }\n\n    // filtres jSON\n    @Bean(name = \"jsonMapper\")\n    public ObjectMapper jsonMapper() {\n        return new ObjectMapper();\n    }\n\n    @Bean(name = \"jsonMapperCategorieWithProduits\")\n    public ObjectMapper jsonMapperCategorieWithProduits() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(\n                new SimpleFilterProvider().addFilter(\"jsonFilterCategorie\", SimpleBeanPropertyFilter.serializeAllExcept())\n                        .addFilter(\"jsonFilterProduit\", SimpleBeanPropertyFilter.serializeAllExcept(\"categorie\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperProduitWithCategorie\")\n    public ObjectMapper jsonMapperProduitWithCategorie() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(\n                new SimpleFilterProvider().addFilter(\"jsonFilterProduit\", SimpleBeanPropertyFilter.serializeAllExcept())\n                        .addFilter(\"jsonFilterCategorie\", SimpleBeanPropertyFilter.serializeAllExcept(\"produits\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperCategorieWithoutProduits\")\n    public ObjectMapper jsonMapperCategorieWithoutProduits() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(new SimpleFilterProvider().addFilter(\"jsonFilterCategorie\",\n                SimpleBeanPropertyFilter.serializeAllExcept(\"produits\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperProduitWithoutCategorie\")\n    public ObjectMapper jsonMapperProduitWithoutCategorie() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(new SimpleFilterProvider().addFilter(\"jsonFilterProduit\",\n                SimpleBeanPropertyFilter.serializeAllExcept(\"categorie\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n}\n</code></pre> <ul> <li>ligne 18\u00a0: l'annotation [@EnableWebMvc] induit des configurations automatiques pour le framework Spring MVC\u00a0;</li> <li>ligne 19\u00a0: la classe [WebConfig] \u00e9tend la classe Spring [WebMvcConfigurerAdapter] pour en red\u00e9finir certains beans (lignes 26-40)\u00a0;</li> <li>lignes 22-23\u00a0: injection du contexte Spring\u00a0;</li> <li>lignes 25-29\u00a0: d\u00e9finition de la servlet du framework Spring MVC, celle qui route les requ\u00eates HTTP vers le bon contr\u00f4leur et la bonne m\u00e9thode. [DispatcherServlet] est une classe de Spring\u00a0;</li> <li>lignes 31-34\u00a0: on indique que cette servlet traite toutes les URL\u00a0;</li> <li>lignes 36-39\u00a0: c'est la pr\u00e9sence de ce bean qui va activer le serveur Tomcat pr\u00e9sent dans les archives du projet. Il attendra les requ\u00eates sur le port 8080\u00a0;</li> <li>lignes 42-91\u00a0: des beans qui seront utilis\u00e9s pour g\u00e9rer des filtres jSON\u00a0;</li> <li>lignes 42-45\u00a0: un mappeur jSON sans filtres\u00a0;</li> <li>lignes 47-57\u00a0: le mappeur jSON qui permet d'avoir une cat\u00e9gorie avec ses produits. On notera que lorsqu'on demande une cat\u00e9gorie avec ses produits, il faut \u00e0 la fois configurer le filtre jSON de la classe [Categorie] et celui de la classe [Produit]. Il en est toujours ainsi. Lorsqu'on s\u00e9rialise / d\u00e9s\u00e9rialise une classe en jSON, il faut configurer le filtre jSON de la classe et ceux de toutes les d\u00e9pendances \u00e0 inclure dans celle-ci\u00a0;</li> <li>lignes 59-69\u00a0: le mappeur jSON qui permet d'avoir un produit avec sa cat\u00e9gorie\u00a0;</li> <li>lignes 71-80\u00a0: le mappeur jSON qui permet d'avoir une cat\u00e9gorie sans ses produits\u00a0;</li> <li>lignes 82-91\u00a0: le mappeur jSON qui permet d'avoir un produit sans sa cat\u00e9gorie\u00a0; La classe [AppConfig] configure l'ensemble de l'application, \u00e7-\u00e0-d les couches [web] et [DAO]\u00a0:</li> </ul> <pre><code>package spring.webjson.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n\nimport spring.data.config.DaoConfig;\n\n@ComponentScan(basePackages = { \"spring.webjson\" })\n@Import({ DaoConfig.class, WebConfig.class})\npublic class AppConfig {\n\n}\n</code></pre> <ul> <li>ligne 9\u00a0: on importe les beans de la couche [DAO] et ceux de la couche [web]\u00a0;</li> <li>ligne 8\u00a0: indique dans quels packages trouver d'autres beans Spring\u00a0; On notera que nulle part, nous n'avons utilis\u00e9 l'annotation [@EnableAutoConfiguration]. Nous avons pr\u00e9f\u00e9r\u00e9 contr\u00f4ler la configuration nous-m\u00eames.</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1354-le-modele-de-lapplication","title":"13.5.4. Le mod\u00e8le de l'application","text":"<p>La classe [ApplicationModel] est la suivante\u00a0:</p> <pre><code>package spring.webjson.models;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport spring.data.dao.IDao;\nimport spring.data.entities.Categorie;\nimport spring.data.entities.Produit;\n\n@Component\npublic class ApplicationModel implements IDao {\n\n    // la couche [DAO]\n    @Autowired\n    private IDao dao;\n\n    @Override\n    public void addProduits(List&lt;Produit&gt; produits) {\n        dao.addProduits(produits);\n    }\n\n    @Override\n    public void deleteAllProduits() {\n        dao.deleteAllProduits();\n    }\n\n    @Override\n    public void updateProduits(List&lt;Produit&gt; produits) {\n        dao.updateProduits(produits);\n    }\n\n    @Override\n    public List&lt;Produit&gt; getAllProduits() {\n        return dao.getAllProduits();\n    }\n\n    @Override\n    public void addCategories(List&lt;Categorie&gt; categories) {\n        dao.addCategories(categories);\n    }\n\n    @Override\n    public void deleteAllCategories() {\n        dao.deleteAllCategories();\n    }\n\n    @Override\n    public void updateCategories(List&lt;Categorie&gt; categories) {\n        dao.updateCategories(categories);\n    }\n\n    @Override\n    public List&lt;Categorie&gt; getAllCategories() {\n        return dao.getAllCategories();\n    }\n\n    @Override\n    public Produit getProduitByIdWithCategorie(Long idProduit) {\n        return dao.getProduitByIdWithCategorie(idProduit);\n    }\n\n    @Override\n    public Produit getProduitByNameWithCategorie(String nom) {\n        return dao.getProduitByNameWithCategorie(nom);\n    }\n\n    @Override\n    public Categorie getCategorieByIdWithProduits(Long idCategorie) {\n        return dao.getCategorieByIdWithProduits(idCategorie);\n    }\n\n    @Override\n    public Categorie getCategorieByNameWithProduits(String nom) {\n        return dao.getCategorieByNameWithProduits(nom);\n    }\n\n    @Override\n    public Produit getProduitByIdWithoutCategorie(Long idProduit) {\n        return dao.getProduitByIdWithoutCategorie(idProduit);\n    }\n\n    @Override\n    public Categorie getCategorieByIdWithoutProduits(Long idCategorie) {\n        return dao.getCategorieByIdWithoutProduits(idCategorie);\n    }\n\n    @Override\n    public Produit getProduitByNameWithoutCategorie(String nom) {        \n        return dao.getProduitByNameWithoutCategorie(nom);\n    }\n\n    @Override\n    public Categorie getCategorieByNameWithoutProduits(String nom) {\n        return dao.getCategorieByNameWithoutProduits(nom);\n    }\n\n}\n</code></pre> <ul> <li>ligne 12\u00a0: la classe est un singleton Spring\u00a0;</li> <li>ligne 13\u00a0: qui impl\u00e9mente l'interface [IDao] de la couche [DAO]\u00a0;</li> <li>lignes 16-17\u00a0: injection d'une r\u00e9f\u00e9rence sur la couche [DAO]\u00a0;</li> <li>lignes 19-99\u00a0: impl\u00e9mentation de l'interface [IDao]\u00a0; L'architecture de la couche web \u00e9volue comme suit\u00a0:</li> </ul> <ul> <li>en [2b], les m\u00e9thodes du ou des contr\u00f4leurs communiquent avec le singleton [ApplicationModel]\u00a0; Cette strat\u00e9gie am\u00e8ne de la souplesse quant \u00e0 la gestion d'un \u00e9ventuel cache. La classe [ApplicationModel] peut servir \u00e0 m\u00e9moriser des informations obtenues aupr\u00e8s de la couche [DAO] ou encore des donn\u00e9es de configuration. Cela peut \u00eatre utile lorsqu'on n'a pas la ma\u00eetrise de la couche [DAO]. Cette strat\u00e9gie de cache peut \u00e9voluer au fil du temps. Les modifications n'auront aucun impact sur le code du ou des contr\u00f4leurs.</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1355-le-controleur","title":"13.5.5. Le contr\u00f4leur","text":"<p>Nous n'avons ici qu'un contr\u00f4leur, la classe [MyController].</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13551-les-url-exposees","title":"13.5.5.1. Les URL expos\u00e9es","text":"<p>Les URL expos\u00e9es par ce contr\u00f4leur sont les suivantes\u00a0:</p> <pre><code>    @RequestMapping(value = \"/addProduits\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\")\n    public String addProduits(HttpServletRequest request) {\n...\n    }\n</code></pre> <p>Ajoute des produits dans la base. Ceux-ci sont post\u00e9s. La r\u00e9ponse est la cha\u00eene jSON la liste des produits ajout\u00e9s avec leur cl\u00e9 primaire.</p> <pre><code>    @RequestMapping(value = \"/deleteAllProduits\", method = RequestMethod.GET)\n    public String deleteAllProduits() {\n..\n    }\n</code></pre> <p>Supprime tous les produits de la base.</p> <pre><code>    @RequestMapping(value = \"/updateProduits\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\")\n    public String updateProduits(HttpServletRequest request) {\n..\n    }\n</code></pre> <p>Met \u00e0 jour des produits dans la base. Ceux-ci sont post\u00e9s. La r\u00e9ponse est cha\u00eene jSON de la liste des produits mis \u00e0 jour.</p> <pre><code>    @RequestMapping(value = \"/getAllProduits\", method = RequestMethod.GET)\n    public String getAllProduits() {\n..\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON de tous les produits.</p> <pre><code>    @RequestMapping(value = \"/addCategories\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\")\n    public String addCategories(HttpServletRequest request) {\n..\n    }\n</code></pre> <p>Ajoute des cat\u00e9gories dans la base. Ceux-ci sont post\u00e9s. La r\u00e9ponse est la cha\u00eene jSON de la liste des cat\u00e9gories ajout\u00e9es avec leur cl\u00e9 primaire. Si les cat\u00e9gories contiennent des produits, ceux-ci sont \u00e9galement ajout\u00e9s \u00e0 la base.</p> <pre><code>    @RequestMapping(value = \"/deleteAllCategories\", method = RequestMethod.GET)\n    public String deleteAllCategories() {\n...\n    }\n</code></pre> <p>Supprime toutes les cat\u00e9gories de la base ainsi que tous les produits de celles-ci. Apr\u00e8s la base est vide.</p> <pre><code>    @RequestMapping(value = \"/updateCategories\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\")\n    public String updateCategories(HttpServletRequest request) {\n...\n    }\n</code></pre> <p>Met \u00e0 jour des cat\u00e9gories dans la base. Ceux-ci sont post\u00e9s. La r\u00e9ponse est la liste des cat\u00e9gories mises \u00e0 jour. Si les cat\u00e9gories contiennent des produits, ceux-ci sont \u00e9galement mis \u00e0 jour dans la base. Rend la cha\u00eene jSON des cat\u00e9gories modifi\u00e9es\u00a0;</p> <pre><code>    @RequestMapping(value = \"/getAllCategories\", method = RequestMethod.GET)\n    public String getAllCategories() {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON de toutes les cat\u00e9gories.</p> <pre><code>    @RequestMapping(value = \"/getProduitByIdWithCategorie/{idProduit}\", method = RequestMethod.GET)\n    public String getProduitByIdWithCategorie(@PathVariable(\"idProduit\") Long idProduit) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'un produit d\u00e9sign\u00e9 par son id, avec sa cat\u00e9gorie.</p> <pre><code>    @RequestMapping(value = \"/getProduitByIdWithoutCategorie/{idProduit}\", method = RequestMethod.GET)\n    public String getProduitByIdWithoutCategorie(@PathVariable(\"idProduit\") Long idProduit) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'un produit d\u00e9sign\u00e9 par son id, sans sa cat\u00e9gorie.</p> <pre><code>    @RequestMapping(value = \"/getProduitByNameWithCategorie/{nom}\", method = RequestMethod.GET)\n    public String getProduitByNameWithCategorie(@PathVariable(\"nom\") String nom) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'un produit d\u00e9sign\u00e9 par son nom, avec sa cat\u00e9gorie.</p> <pre><code>    @RequestMapping(value = \"/getProduitByNameWithoutCategorie/{nom}\", method = RequestMethod.GET)\n    public String getProduitByNameWithoutCategorie(@PathVariable(\"nom\") String nom) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'un produit d\u00e9sign\u00e9 par son nom, sans sa cat\u00e9gorie.</p> <pre><code>    @RequestMapping(value = \"/getCategorieByIdWithProduits/{idCategorie}\", method = RequestMethod.GET)\n    public String getCategorieByIdWithProduits(@PathVariable(\"idCategorie\") Long idCategorie) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'une cat\u00e9gorie d\u00e9sign\u00e9e par son id, avec ses produits.</p> <pre><code>    @RequestMapping(value = \"/getCategorieByNameWithProduits/{nom}\", method = RequestMethod.GET)\n    public String getCategorieByNameWithProduits(@PathVariable(\"nom\") String nom) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'une cat\u00e9gorie d\u00e9sign\u00e9e par son nom, avec ses produits.</p> <pre><code>    @RequestMapping(value = \"/getCategorieByNameWithoutProduits/{nom}\", method = RequestMethod.GET)\n    public String getCategorieByNameWithoutProduits(@PathVariable(\"nom\") String nom) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'une cat\u00e9gorie d\u00e9sign\u00e9e par son nom, sans ses produits.</p> <pre><code>    @RequestMapping(value = \"/getCategorieByIdWithoutProduits/{idCategorie}\", method = RequestMethod.GET)\n    public String getCategorieByIdWithoutProduits(@PathVariable(\"idCategorie\") Long idCategorie) {\n...\n    }\n</code></pre> <p>Obtient la cha\u00eene jSON d'une cat\u00e9gorie d\u00e9sign\u00e9e par son id sans ses produits.</p> <p>Les URL expos\u00e9es correspondent aux m\u00e9thodes de l'interface [IDao] de la couche [DAO]. Les m\u00e9thodes du service web / jSON sont toutes b\u00e2ties sur le m\u00eame mod\u00e8le. Nous allons en examiner quelques unes.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13552-le-squelette-du-controleur","title":"13.5.5.2. Le squelette du contr\u00f4leur","text":"<p>Le squelette du contr\u00f4leur est le suivant\u00a0:</p> <pre><code>package spring.webjson.service;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.io.CharStreams;\n\nimport spring.data.dao.DaoException;\nimport spring.data.entities.Categorie;\nimport spring.data.entities.Produit;\nimport spring.webjson.models.ApplicationModel;\nimport spring.webjson.models.Response;\n\n@Controller\npublic class MyController {\n\n    // d\u00e9pendances Spring\n    @Autowired\n    private ApplicationModel application;\n\n    // filtres jSON\n    @Autowired\n    @Qualifier(\"jsonMapper\")\n    private ObjectMapper jsonMapper;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithProduits\")\n    private ObjectMapper jsonMapperCategorieWithProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithCategorie\")\n    private ObjectMapper jsonMapperProduitWithCategorie;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithoutProduits\")\n    private ObjectMapper jsonMapperCategorieWithoutProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithoutCategorie\")\n    private ObjectMapper jsonMapperProduitWithoutCategorie;\n\n    // la classe [MyController] est un singleton et n'est instanci\u00e9e qu'une fois le bean\n\n    public MyController() {\n        // System.out.println(\"MyController\");\n    }\n\n    @RequestMapping(value = \"/addProduits\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\", produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String addProduits(HttpServletRequest request) throws JsonProcessingException {\n        ...\n    }\n</code></pre> <ul> <li>ligne 28\u00a0: l'annotation [@Controller] fait de la classe un composant Spring\u00a0;</li> <li>lignes 32-33\u00a0: injection d'une r\u00e9f\u00e9rence sur la classe [ApplicationModel]\u00a0;</li> <li>lignes 36-50\u00a0: injections de r\u00e9f\u00e9rences sur les mappeurs jSON\u00a0;</li> <li>ligne 58\u00a0: l'URL expos\u00e9e est [/addProduits]. Le client doit utiliser une m\u00e9thode [POST] pour faire sa requ\u00eate (method = RequestMethod.POST). Il doit envoyer la valeur post\u00e9e sous forme d'une cha\u00eene jSON (consumes = \"application/json; charset=UTF-8\"). La m\u00e9thode renvoie elle-m\u00eame la r\u00e9ponse au client (ligne 59). Ce sera une cha\u00eene de caract\u00e8res (ligne 60). L'ent\u00eate HTTP [Content-type\u00a0: application/json; charset=UTF-8] sera envoy\u00e9 au client pour lui indiquer qu'il va recevoir une cha\u00eene jSON (ligne 58)\u00a0;</li> <li>ligne 60\u00a0: la m\u00e9thode [addProduits] rend la cha\u00eene jSON de la liste des produits ajout\u00e9s dans la base\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13553-la-reponse-des-methodes-du-controleur","title":"13.5.5.3. La r\u00e9ponse des m\u00e9thodes du contr\u00f4leur","text":"<p>Toutes les m\u00e9thodes du contr\u00f4leur rendent la r\u00e9ponse de type [Response] suivant\u00a0:</p> <pre><code>package spring.webjson.service;\n\nimport java.util.List;\n\npublic class Response&lt;T&gt; {\n\n    // ----------------- propri\u00e9t\u00e9s\n    // statut de l'op\u00e9ration\n    private int status;\n    // les \u00e9ventuels messages d'erreur\n    private List&lt;String&gt; messages;\n    // le corps de la r\u00e9ponse\n    private T body;\n\n    // constructeurs\n    public Response() {\n\n    }\n\n    public Response(int status, List&lt;String&gt; messages, T body) {\n        this.status = status;\n        this.messages = messages;\n        this.body = body;\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre> <ul> <li>ligne 5\u00a0: la r\u00e9ponse encapsule un type T\u00a0;</li> <li>ligne 13\u00a0: la r\u00e9ponse de type T\u00a0;</li> <li>lignes 9-11\u00a0: il est possible qu'une m\u00e9thode rencontre une exception. Dans ce cas, elle rendra une r\u00e9ponse avec\u00a0:</li> <li>ligne 9\u00a0: status!=0\u00a0;</li> <li>ligne 11\u00a0: la liste des erreurs rencontr\u00e9es\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13554-lurl-addproduits","title":"13.5.5.4. L'URL [/addProduits]","text":"<p>L'URL [/addProduits] est trait\u00e9e par la m\u00e9thode suivante\u00a0:</p> <pre><code>@RequestMapping(value = \"/addProduits\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\", produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String addProduits(HttpServletRequest request) throws JsonProcessingException {\n        // r\u00e9ponse\n        Response&lt;List&lt;Produit&gt;&gt; response;\n        try {\n            // on r\u00e9cup\u00e8re la valeur post\u00e9e\n            String body = CharStreams.toString(request.getReader());\n            List&lt;Produit&gt; produits = jsonMapperProduitWithoutCategorie.readValue(body, new TypeReference&lt;List&lt;Produit&gt;&gt;() {\n            });\n            // on r\u00e9tablit le lien entre produits et cat\u00e9gories\n            for (Produit produit : produits) {\n                produit.setCategorie(application.getCategorieByIdWithoutProduits(produit.getIdCategorie()));\n            }\n            // on persiste les produits\n            application.addProduits(produits);\n            response = new Respon    se&lt;List&lt;Produit&gt;&gt;(0, null, produits);\n        } catch (DaoException e1) {\n            response = new Response&lt;List&lt;Produit&gt;&gt;(1000, e1.getErreurs(), null);\n        } catch (Exception e2) {\n            response = new Response&lt;List&lt;Produit&gt;&gt;(1000, getErreursForException(e2), null);\n        }\n        // r\u00e9ponse jSON\n        return jsonMapperProduitWithoutCategorie.writeValueAsString(response);\n    }\n</code></pre> <ul> <li>ligne 3\u00a0: la m\u00e9thode admet pour param\u00e8tre [HttpServletRequest request] qui encapsule toutes les informations sur la requ\u00eate du client\u00a0;</li> <li>ligne 5\u00a0: la r\u00e9ponse qui sera envoy\u00e9e au client\u00a0: une liste de produits\u00a0;</li> <li>ligne 8\u00a0: on r\u00e9cup\u00e8re la valeur post\u00e9e. La classe [CharStreams] appartient \u00e0 la biblioth\u00e8que [Google Guava] dont on a ajout\u00e9 la r\u00e9f\u00e9rence dans le fichier [pom.xml]. On obtient la cha\u00eene jSON post\u00e9e par le client. Il faut la d\u00e9s\u00e9rialiser pour en faire quelque chose\u00a0;</li> <li>lignes 8-10\u00a0: la d\u00e9s\u00e9rialisation est faite. On obtient une liste de produits o\u00f9 chaque produit a un champ [categorie=null]\u00a0;</li> <li>lignes 12-14\u00a0: on r\u00e9initialise le champ [categorie] de tous les produits de la liste. Pour cela, on utilise le champ [idCategorie] du produit qui lui, est initialis\u00e9\u00a0;</li> <li>ligne 16\u00a0: les produits sont ins\u00e9r\u00e9s dans la base\u00a0;</li> <li>ligne 17\u00a0: l'objet [response] est initialis\u00e9 avec la liste de produits\u00a0;</li> <li>lignes 18-19\u00a0: cas o\u00f9 la m\u00e9thode rencontre une exception de la couche [DAO]. On initialise la r\u00e9ponse avec [status=1000] (code d'erreur) [messages=e1.getMessages()], \u00e7-\u00e0-d qu'on transmet au client la liste des erreurs rencontr\u00e9es c\u00f4t\u00e9 serveur\u00a0;</li> <li>lignes 20-21\u00a0: cas o\u00f9 la m\u00e9thode rencontre un autre type d'exception. On initialise la r\u00e9ponse avec [status=1000] (code d'erreur) [messages=getErreursForException(e)] o\u00f9 [getErreursForException] est une m\u00e9thode priv\u00e9e de la classe qui rend la liste des erreurs associ\u00e9es aux exceptions de la pile d'exceptions de e, et [body=null]\u00a0;</li> <li>ligne 24\u00a0: on rend la cha\u00eene jSON de la r\u00e9ponse\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13555-lurl-getallproduits","title":"13.5.5.5. L'URL [/getAllProduits]","text":"<p>L'URL [/getAllProduits] est trait\u00e9e par la m\u00e9thode suivante\u00a0:</p> <pre><code>    @RequestMapping(value = \"/getAllProduits\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String getAllProduits() throws JsonProcessingException {\n        // r\u00e9ponse\n        Response&lt;List&lt;Produit&gt;&gt; response;\n        try {\n            response = new Response&lt;List&lt;Produit&gt;&gt;(0, null, application.getAllProduits());\n        } catch (DaoException e1) {\n            response = new Response&lt;List&lt;Produit&gt;&gt;(1003, e1.getErreurs(), null);\n        } catch (Exception e2) {\n            response = new Response&lt;List&lt;Produit&gt;&gt;(1003, getErreursForException(e2), null);\n        }\n        // r\u00e9ponse jSON\n        return jsonMapperProduitWithoutCategorie.writeValueAsString(response);\n}\n</code></pre> <ul> <li>ligne 1\u00a0: l'URL [/getAllProduits] est demand\u00e9e avec une op\u00e9ration [GET]. Elle produit du jSON\u00a0;</li> <li>ligne 2\u00a0: la m\u00e9thode envoie elle-m\u00eame la r\u00e9ponse jSON au client\u00a0;</li> <li>ligne 5\u00a0: la m\u00e9thode envoie la cha\u00eene jSON d'un type [Response&lt;List&lt;Produit&gt;&gt;]\u00a0;</li> <li>ligne 7\u00a0: les produits sont demand\u00e9s sans leur cat\u00e9gorie\u00a0;</li> <li>lignes 8-12\u00a0: en cas d'erreur, la r\u00e9ponse est initialis\u00e9e avec un code et des messages d'erreur\u00a0;</li> <li>ligne 14\u00a0: la r\u00e9ponse jSON de la r\u00e9ponse est envoy\u00e9e au client\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13556-conclusion","title":"13.5.5.6. Conclusion","text":"<p>Nous n'allons pas pr\u00e9senter les autres m\u00e9thodes du contr\u00f4leur. Elles ressemblent \u00e0 l'une ou l'autre des deux m\u00e9thodes que nous enons de pr\u00e9senter.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1356-la-classe-dexecution-du-service-web-json","title":"13.5.6. La classe d'ex\u00e9cution du service web / jSON","text":"<p>La classe [Boot] est la classe ex\u00e9cutable du projet\u00a0:</p> <pre><code>package spring.webjson.boot;\n\nimport org.springframework.boot.SpringApplication;\n\nimport spring.webjson.server.config.AppConfig;\n\npublic class Boot {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AppConfig.class, args);\n    }\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la m\u00e9thode statique [SpringApplication.run] est ex\u00e9cut\u00e9e. La classe [SpringApplication] est une classe du projet [Spring Boot] (ligne 3). On lui passe deux param\u00e8tres\u00a0:</li> <li>[AppConfig.class]\u00a0: la classe qui configure la totalit\u00e9 de l'application\u00a0;</li> <li>[args]\u00a0: les \u00e9ventuels arguments pass\u00e9s \u00e0 la m\u00e9thode [main] ligne 9. Ce param\u00e8tre n'est pas utilis\u00e9 ici\u00a0; Lorsqu'on ex\u00e9cute cette classe, on a les logs suivants\u00a0:</li> </ul> <pre><code>.   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.2.2.RELEASE)\n\n2015-03-24 16:22:46.608  INFO 9492 --- [           main] spring.webjson.server.boot.Boot          : Starting Boot on Gportpers3 with PID 9492 (D:\\data\\istia-1415\\eclipse\\intro-web-json\\intro-webjson-server-02\\target\\classes started by ST in D:\\data\\istia-1415\\eclipse\\intro-web-json\\intro-webjson-server-02)\n2015-03-24 16:22:46.654  INFO 9492 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@1d7acb34: startup date [Tue Mar 24 16:22:46 CET 2015]; root of context hierarchy\n2015-03-24 16:22:47.521  INFO 9492 --- [           main] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'beanNameViewResolver': replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration; factoryMethodName=beanNameViewResolver; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/web/ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter; factoryMethodName=beanNameViewResolver; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]]\n2015-03-24 16:22:47.569  INFO 9492 --- [           main] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'entityManagerFactory': replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=spring.data.config.DaoConfig; factoryMethodName=entityManagerFactory; initMethodName=null; destroyMethodName=(inferred); defined in class spring.data.config.DaoConfig] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=true; factoryBeanName=org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration; factoryMethodName=entityManagerFactory; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaAutoConfiguration.class]]\n2015-03-24 16:22:48.137  INFO 9492 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [class org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$405db6ba] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n2015-03-24 16:22:48.162  INFO 9492 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'transactionAttributeSource' of type [class org.springframework.transaction.annotation.AnnotationTransactionAttributeSource] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n2015-03-24 16:22:48.172  INFO 9492 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'transactionInterceptor' of type [class org.springframework.transaction.interceptor.TransactionInterceptor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n2015-03-24 16:22:48.178  INFO 9492 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.config.internalTransactionAdvisor' of type [class org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)\n2015-03-24 16:22:48.586  INFO 9492 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)\n2015-03-24 16:22:48.850  INFO 9492 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat\n2015-03-24 16:22:48.852  INFO 9492 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.0.20\n2015-03-24 16:22:48.992  INFO 9492 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2015-03-24 16:22:48.992  INFO 9492 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2342 ms\n2015-03-24 16:22:49.645  INFO 9492 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]\n2015-03-24 16:22:49.650  INFO 9492 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'characterEncodingFilter' to: [/*]\n2015-03-24 16:22:49.651  INFO 9492 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]\n2015-03-24 16:22:50.380  INFO 9492 --- [           main] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'\n2015-03-24 16:22:50.392  INFO 9492 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [\n    name: default\n    ...]\n2015-03-24 16:22:50.478  INFO 9492 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {4.3.8.Final}\n2015-03-24 16:22:50.480  INFO 9492 --- [           main] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found\n2015-03-24 16:22:50.483  INFO 9492 --- [           main] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist\n2015-03-24 16:22:50.697  INFO 9492 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {4.0.5.Final}\n2015-03-24 16:22:50.806  INFO 9492 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQLDialect\n2015-03-24 16:22:51.058  INFO 9492 --- [           main] o.h.h.i.ast.ASTQueryTranslatorFactory    : HHH000397: Using ASTQueryTranslatorFactory\n2015-03-24 16:22:52.581  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@1d7acb34: startup date [Tue Mar 24 16:22:46 CET 2015]; root of context hierarchy\n2015-03-24 16:22:52.654  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/addProduits],methods=[POST],params=[],headers=[],consumes=[application/json;charset=UTF-8],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.util.List&lt;spring.data.entities.Produit&gt;&gt; spring.webjson.server.service.Controller.addProduits(javax.servlet.http.HttpServletRequest)\n2015-03-24 16:22:52.655  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/updateProduits],methods=[POST],params=[],headers=[],consumes=[application/json;charset=UTF-8],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.util.List&lt;spring.data.entities.Produit&gt;&gt; spring.webjson.server.service.Controller.updateProduits(javax.servlet.http.HttpServletRequest)\n2015-03-24 16:22:52.655  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getAllProduits],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.util.List&lt;spring.data.entities.Produit&gt;&gt; spring.webjson.server.service.Controller.getAllProduits()\n2015-03-24 16:22:52.655  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getAllCategories],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.util.List&lt;spring.data.entities.Categorie&gt;&gt; spring.webjson.server.service.Controller.getAllCategories()\n2015-03-24 16:22:52.655  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/addCategories],methods=[POST],params=[],headers=[],consumes=[application/json;charset=UTF-8],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.util.List&lt;spring.data.entities.Categorie&gt;&gt; spring.webjson.server.service.Controller.addCategories(javax.servlet.http.HttpServletRequest)\n2015-03-24 16:22:52.655  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/updateCategories],methods=[POST],params=[],headers=[],consumes=[application/json;charset=UTF-8],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.util.List&lt;spring.data.entities.Categorie&gt;&gt; spring.webjson.server.service.Controller.updateCategories(javax.servlet.http.HttpServletRequest)\n2015-03-24 16:22:52.656  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getCategorieByNameWithoutProduits/{nom}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Categorie&gt; spring.webjson.server.service.Controller.getCategorieByNameWithoutProduits(java.lang.String)\n2015-03-24 16:22:52.656  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getProduitByNameWithoutCategorie/{nom}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Produit&gt; spring.webjson.server.service.Controller.getProduitByNameWithoutCategorie(java.lang.String)\n2015-03-24 16:22:52.656  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getProduitByNameWithCategorie/{nom}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Produit&gt; spring.webjson.server.service.Controller.getProduitByNameWithCategorie(java.lang.String)\n2015-03-24 16:22:52.656  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getProduitByIdWithCategorie/{idProduit}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Produit&gt; spring.webjson.server.service.Controller.getProduitByIdWithCategorie(java.lang.Long)\n2015-03-24 16:22:52.656  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getCategorieByNameWithProduits/{nom}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Categorie&gt; spring.webjson.server.service.Controller.getCategorieByNameWithProduits(java.lang.String)\n2015-03-24 16:22:52.657  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getCategorieByIdWithProduits/{idCategorie}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Categorie&gt; spring.webjson.server.service.Controller.getCategorieByIdWithProduits(java.lang.Long)\n2015-03-24 16:22:52.657  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/deleteAllCategories],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.lang.Void&gt; spring.webjson.server.service.Controller.deleteAllCategories()\n2015-03-24 16:22:52.657  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getCategorieByIdWithoutProduits/{idCategorie}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Categorie&gt; spring.webjson.server.service.Controller.getCategorieByIdWithoutProduits(java.lang.Long)\n2015-03-24 16:22:52.657  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/deleteAllProduits],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;java.lang.Void&gt; spring.webjson.server.service.Controller.deleteAllProduits()\n2015-03-24 16:22:52.658  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/getProduitByIdWithoutCategorie/{idProduit}],methods=[GET],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public spring.webjson.webjson.models.Response&lt;spring.data.entities.Produit&gt; spring.webjson.server.service.Controller.getProduitByIdWithoutCategorie(java.lang.Long)\n2015-03-24 16:22:52.659  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}\" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)\n2015-03-24 16:22:52.659  INFO 9492 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],methods=[],params=[],headers=[],consumes=[],produces=[text/html],custom=[]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest)\n2015-03-24 16:22:52.691  INFO 9492 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2015-03-24 16:22:52.692  INFO 9492 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2015-03-24 16:22:52.742  INFO 9492 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2015-03-24 16:22:53.001  INFO 9492 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2015-03-24 16:22:53.106  INFO 9492 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)\n2015-03-24 16:22:53.108  INFO 9492 --- [           main] spring.webjson.server.boot.Boot          : Started Boot in 6.752 seconds (JVM running for 7.433)\n</code></pre> <ul> <li>lignes 17-19\u00a0: d\u00e9marrage du serveur Tomcat qui va ex\u00e9cuter le service web / jSON\u00a0;</li> <li>lignes 25-33\u00a0: construction de la couche [DAO]\u00a0;</li> <li>lignes 32-51\u00a0: les URL expos\u00e9es sont d\u00e9couvertes\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1357-tests-du-service-web-json","title":"13.5.7. Tests du service web / jSON","text":"<p>Pour faire les tests, nous g\u00e9n\u00e9rons la base de donn\u00e9es MySQL [dbintrospringdata] \u00e0 partir du script SQL [dbintrospringdata.sql]\u00a0:</p> <p>Ceci fait, nous utilisons le client [Advanced Rest Client] (cf page 422) pour interroger les URL expos\u00e9es par le service web / jSON (le service web / jSON doit \u00eatre lanc\u00e9). </p> <ul> <li>en [1-3], nous demandons l'URL [/getAllCategories] via une commande HTTP GET\u00a0; Nous obtenons la r\u00e9ponse suivante\u00a0:</li> </ul> <ul> <li>en [1], la requ\u00eate HTTP du client\u00a0;</li> <li>en [2], la r\u00e9ponse HTTP du serveur\u00a0;</li> <li>en [3], le statut [200 OK] indique que le serveur a correctement trait\u00e9 la demande\u00a0;</li> <li>en [4], la r\u00e9ponse jSON du serveur\u00a0; La r\u00e9ponse jSON compl\u00e8te est la suivante\u00a0:</li> </ul> <pre><code>{\"status\":0,\"messages\":null,\"body\":[{\"id\":415,\"version\":0,\"nom\":\"categorie0\",\"produits\":[{\"id\":1849,\"version\":0,\"nom\":\"produit00\",\"idCategorie\":415,\"prix\":100.0,\"description\":\"desc00\"},{\"id\":1850,\"version\":0,\"nom\":\"produit01\",\"idCategorie\":415,\"prix\":101.0,\"description\":\"desc01\"},{\"id\":1851,\"version\":0,\"nom\":\"produit02\",\"idCategorie\":415,\"prix\":102.0,\"description\":\"desc02\"},{\"id\":1852,\"version\":0,\"nom\":\"produit03\",\"idCategorie\":415,\"prix\":103.0,\"description\":\"desc03\"},{\"id\":1853,\"version\":0,\"nom\":\"produit04\",\"idCategorie\":415,\"prix\":104.0,\"description\":\"desc04\"}]},{\"id\":416,\"version\":0,\"nom\":\"categorie1\",\"produits\":[{\"id\":1856,\"version\":0,\"nom\":\"produit12\",\"idCategorie\":416,\"prix\":112.0,\"description\":\"desc12\"},{\"id\":1857,\"version\":0,\"nom\":\"produit13\",\"idCategorie\":416,\"prix\":113.0,\"description\":\"desc13\"},{\"id\":1858,\"version\":0,\"nom\":\"produit14\",\"idCategorie\":416,\"prix\":114.0,\"description\":\"desc14\"},{\"id\":1854,\"version\":0,\"nom\":\"produit10\",\"idCategorie\":416,\"prix\":110.0,\"description\":\"desc10\"},{\"id\":1855,\"version\":0,\"nom\":\"produit11\",\"idCategorie\":416,\"prix\":111.0,\"description\":\"desc11\"}]}]}\n</code></pre> <ul> <li>status:0 signifie qu'il n'y a pas eu d'erreurs c\u00f4t\u00e9 serveur\u00a0;</li> <li>messages\u00a0: null\u00a0signifie qu'il n'y a pas de messages d'erreur\u00a0;</li> <li>body\u00a0: est le corps de la r\u00e9ponse, ici la liste des cat\u00e9gories avec leurs produits. Il y a deux cat\u00e9gories avec chacune 5 produits\u00a0; Nous allons ajouter \u00e0 la cat\u00e9gorie [categorie1], le produit [produit15]. Pour cela nous allons utiliser l'URL [/addCategories] qui a le code suivant\u00a0:</li> </ul> <pre><code>@RequestMapping(value = \"/addCategories\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\", produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String addCategories(HttpServletRequest request) throws JsonProcessingException {\n        Response&lt;List&lt;Categorie&gt;&gt; response;\n        ObjectMapper mapper = context.getBean(ObjectMapper.class);\n        // on persiste les cat\u00e9gories\n        try {\n            // on r\u00e9cup\u00e8re la valeur post\u00e9e\n            String body = CharStreams.toString(request.getReader());\n            mapper.setFilters(jsonFilterCategorieWithProduits);\n            List&lt;Categorie&gt; categories = mapper.readValue(body, new TypeReference&lt;List&lt;Categorie&gt;&gt;() {\n            });\n            // on r\u00e9tablit le lien entre produits et cat\u00e9gories\n            for (Categorie categorie : categories) {\n                Set&lt;Produit&gt; produits = categorie.getProduits();\n                if (produits != null) {\n                    for (Produit produit : categorie.getProduits()) {\n                        produit.setCategorie(categorie);\n                    }\n                }\n            }\n            // on persiste les cat\u00e9gories\n            application.addCategories(categories);\n            response = new Response&lt;List&lt;Categorie&gt;&gt;(0, null, categories);\n        } catch (Exception e) {\n            response = new Response&lt;List&lt;Categorie&gt;&gt;(1004, getErreursForException(e), null);\n        }\n        // r\u00e9ponse jSON\n        return mapper.writeValueAsString(response);\n    }\n</code></pre> <ul> <li>ligne 1\u00a0: le client doit faire un POST et la valeur post\u00e9e doit \u00eatre une cha\u00eene jSON\u00a0;</li> <li>lignes 9-12\u00a0: la valeur post\u00e9e doit \u00eatre une liste de cat\u00e9gories avec leurs produits associ\u00e9s\u00a0; Nous allons cr\u00e9er une cat\u00e9gorie [categorie2] avec un produit [produit21]. La cha\u00eene jSON \u00e0 envoyer est alors la suivante\u00a0:</li> </ul> <pre><code>[{\"id\":null,\"version\":0,\"nom\":\"categorie2\",\"produits\":[{\"id\":null,\"version\":0,\"nom\":\"produit21\",\"idCategorie\":null,\"prix\":111.0,\"description\":\"desc21\"}]}]\n</code></pre> <p>La requ\u00eate au service web / jSON est faite de la fa\u00e7on suivante\u00a0:</p> <ul> <li>en [1], l'URL demand\u00e9e\u00a0;</li> <li>en [2], elle est demand\u00e9e via une op\u00e9ration POST\u00a0;</li> <li>en [3], la cha\u00eene jSON post\u00e9e\u00a0;</li> <li>en [4], on indique au serveur qu'on va lui envoyer du jSON\u00a0; La r\u00e9ponse du serveur est la suivante\u00a0:</li> </ul> <ul> <li>en [1], on voit que et la cat\u00e9gorie et son produit ont maintenant une cl\u00e9 primaire montrant par l\u00e0 qu'ils ont probablement \u00e9t\u00e9 ins\u00e9r\u00e9s dans la base. Nous allons le v\u00e9rifier en utilisant l'URL [/getCategorieByNameWithProduits/categorie2]\u00a0:</li> </ul> <p>Nous obtenons le r\u00e9sultat suivant\u00a0:</p> <p>Nous avons bien obtenu la cat\u00e9gorie [categorie2] avec son unique produit [produit21]. On peut aussi demander uniquement le produit. Utilisons pour cela l'URL [/getProduitByIdWithoutCategorie/1859]\u00a0:</p> <p>Nous obtenons le r\u00e9sultat suivant\u00a0:</p> <p>Toutes les op\u00e9rations [GET] peuvent \u00eatre faites dans un simple navigateur\u00a0:</p> <p>Le lecteur est invit\u00e9 \u00e0 tester les autres URL du service web / json.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#136-un-client-programme-pour-le-service-web-json","title":"13.6. Un client programm\u00e9 pour le service web / jSON","text":"<p>Maintenant que la base [dbintrospringdata] est disponible sur le web, nous allons \u00e9crire une application qui l'exploite. On aura alors l'architecture client / serveur suivante\u00a0:</p> <p>L'application cliente aura deux couches\u00a0:</p> <ul> <li>une couche [DAO] [2] pour communiquer avec l'application web / jSON qui expose la base de donn\u00e9es\u00a0;</li> <li>une couche de tests JUnit [1] pour v\u00e9rifier que le client et le serveur font bien leur travail\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1361-le-projet-eclipse","title":"13.6.1. Le projet Eclipse","text":"<p>Le projet Eclipse du client est le suivant\u00a0:</p> <ul> <li>le dossier [src/main/java] impl\u00e9mente la couche [DAO]\u00a0;</li> <li>le dossier [src/test/java] impl\u00e9mente les tests JUnit\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1362-configuration-maven-du-projet","title":"13.6.2. Configuration Maven du projet","text":"<p>Le projet est un projet Maven configur\u00e9 par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.webjson&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-client-webjson-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;description&gt;Client console du serveur web / jSON&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- librairie jSON utilis\u00e9e par Spring --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- composant utilis\u00e9 par Spring RestTemplate --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n            &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Google Guava --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n            &lt;artifactId&gt;guava&lt;/artifactId&gt;\n            &lt;version&gt;16.0.1&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- biblioth\u00e8que de logs --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n    &lt;name&gt;intro-client-webjson-01&lt;/name&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 14-18\u00a0: le projet Maven parent [spring-boot-starter-parent] qui nous permet de d\u00e9finir un certain nombre de d\u00e9pendances sans leur versions, celle-ci \u00e9tant d\u00e9finie dans le projet parent\u00a0;</li> <li>lignes 22-25\u00a0: bien que nous n'\u00e9crivions pas une application web, nous avons besoin de la d\u00e9pendance [spring-web] qui am\u00e8ne avec elle la classe [RestTemplate] qui permet de s'interfacer ais\u00e9ment avec une application web / jSON\u00a0;</li> <li>lignes 27-34\u00a0: une biblioth\u00e8que jSON\u00a0;</li> <li>lignes 36-39\u00a0: une d\u00e9pendance qui va nous permettre de fixer un timeout aux requ\u00eates HTTP du client. Un timeout est un temps maximal d'attente de la r\u00e9ponse du serveur. Au-del\u00e0 de ce temps, le client signale une erreur de timeout en jetant une exception\u00a0;</li> <li>lignes 41-46\u00a0: la biblioth\u00e8que Google Guava utilis\u00e9e dans le test JUnit. Pour cette raison, nous avons mis sa port\u00e9e \u00e0 [test] (ligne 45). Cela signifie que cette d\u00e9pendance n'est incluse que lors de l'ex\u00e9cution de codes de la branche [src/test/java]\u00a0;</li> <li>lignes 48-51\u00a0: la biblioth\u00e8que de logs\u00a0;</li> <li>lignes 52-63\u00a0: la d\u00e9pendance pour les tests JUnit. Elle am\u00e8ne notamment la biblioth\u00e8que JUnit 4 n\u00e9cessaire pour les tests. Ces d\u00e9pendances ont l'attribut [&lt;scope&gt;test&lt;/scope&gt;] indiquant qu'elles ne sont n\u00e9cessaires que pour la phase de tests. Elles ne sont pas incluses dans l'archive finale du projet\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1363-implementation-de-la-couche-dao","title":"13.6.3. Impl\u00e9mentation de la couche [DAO]","text":"<ul> <li>le package [spring.client.config] contient la configation Spring de la couche [DAO]\u00a0;</li> <li>le package [spring.client.dao] contient l'impl\u00e9mentation de la couche [DAO]\u00a0;</li> <li>le package [spring.client.entities] contient les objets \u00e9chang\u00e9s avec le service web / jSON\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13631-configuration","title":"13.6.3.1. Configuration","text":"<p>La classe [DaoConfig] fait la configuration Spring de la couche [DAO]. Son code est le suivant\u00a0:</p> <pre><code>package spring.client.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.web.client.RestTemplate;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\nimport com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n\n@ComponentScan({ \"spring.client.dao\" })\npublic class DaoConfig {\n\n    // constantes\n    static private final int TIMEOUT = 1000;\n    static private final String URL_WEBJSON = \"http://localhost:8080\";\n\n    @Bean\n    public RestTemplate restTemplate(int timeout) {\n        // cr\u00e9ation du composant RestTemplate\n        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();\n        RestTemplate restTemplate = new RestTemplate(factory);\n        // timeout des \u00e9changes\n        factory.setConnectTimeout(timeout);\n        factory.setReadTimeout(timeout);\n        // r\u00e9sultat\n        return restTemplate;\n    }\n\n    @Bean\n    public int timeout() {\n        return TIMEOUT;\n    }\n\n    @Bean\n    public String urlWebJson() {\n        return URL_WEBJSON;\n    }\n\n    // filtres jSON\n    @Bean(name = \"jsonMapper\")\n    public ObjectMapper jsonMapper() {\n        return new ObjectMapper();\n    }\n\n    @Bean(name = \"jsonMapperCategorieWithProduits\")\n    public ObjectMapper jsonMapperCategorieWithProduits() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(\n                new SimpleFilterProvider().addFilter(\"jsonFilterCategorie\", SimpleBeanPropertyFilter.serializeAllExcept())\n                        .addFilter(\"jsonFilterProduit\", SimpleBeanPropertyFilter.serializeAllExcept(\"categorie\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperProduitWithCategorie\")\n    public ObjectMapper jsonMapperProduitWithCategorie() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(\n                new SimpleFilterProvider().addFilter(\"jsonFilterProduit\", SimpleBeanPropertyFilter.serializeAllExcept())\n                        .addFilter(\"jsonFilterCategorie\", SimpleBeanPropertyFilter.serializeAllExcept(\"produits\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperCategorieWithoutProduits\")\n    public ObjectMapper jsonMapperCategorieWithoutProduits() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(new SimpleFilterProvider().addFilter(\"jsonFilterCategorie\",\n                SimpleBeanPropertyFilter.serializeAllExcept(\"produits\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperProduitWithoutCategorie\")\n    public ObjectMapper jsonMapperProduitWithoutCategorie() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(new SimpleFilterProvider().addFilter(\"jsonFilterProduit\",\n                SimpleBeanPropertyFilter.serializeAllExcept(\"categorie\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n}\n</code></pre> <ul> <li>ligne 13\u00a0: la classe est une classe de configuration Spring - des composants Spring sont \u00e0 chercher dans le package [spring.client.dao]\u00a0;</li> <li>ligne 17\u00a0: on se fixe un timeout d'une seconde (1000 ms)\u00a0;</li> <li>lignes 32-35\u00a0: le bean qui rend cette valeur\u00a0;</li> <li>ligne 18\u00a0: l'URL du service web / jSON\u00a0;</li> <li>lignes 37-40\u00a0: le bean qui rend cette valeur\u00a0;</li> <li>lignes 20-30\u00a0: la configuration de la classe [RestTemplate] qui assure les \u00e9changes avec le service web / jSON. Lorsqu'on n'a pas \u00e0 la configurer, on peut en disposer dans le code par un simple [new RestTemplate()]. Ici, nous voulons fixer le timeout des \u00e9changes avec le service web / jSON. Le bean [timeout] de la ligne 36 est pass\u00e9 en param\u00e8tre de la m\u00e9thode [restTemplate] de la ligne 24\u00a0;</li> <li>ligne 23\u00a0: le composant [HttpComponentsClientHttpRequestFactory] est le composant qui nous permet de fixer le timeout des \u00e9changes (lignes 29-30)\u00a0;</li> <li>ligne 24\u00a0: la classe [RestTemplate] est construite avec ce composant. Comme elle s'appuie sur celui-ci pour communiquer avec le service web / jSON, les \u00e9changes seront bien soumis au timeout\u00a0;</li> <li>le client et le serveur vont s'\u00e9changer des lignes de texte. Un convertisseur s'occupe de s\u00e9rialiser un objet en texte et inversement de d\u00e9s\u00e9rialiser un texte en objet. Il peut y avoir plusieurs convertisseurs associ\u00e9s \u00e0 la classe [RestTemplate] et celui choisi \u00e0 un moment donn\u00e9 d\u00e9pend des ent\u00eates HTTP envoy\u00e9s par le serveur. Ici, nous n'aurons aucun convertisseur. Aussi, le composant [RestTemplate] ne cherchera pas \u00e0 convertir d'une fa\u00e7on ou d'une autre les deux \u00e9l\u00e9ments suivants\u00a0:</li> <li>le texte post\u00e9\u00a0;</li> <li> <p>le texte re\u00e7u en r\u00e9ponse\u00a0; Ces textes seront des cha\u00eenes jSON qui seront donc laiss\u00e9es en l'\u00e9tat par le composant [RestTemplate]. C'est nous d\u00e9veloppeur, qui ferons les s\u00e9ralisations / d\u00e9s\u00e9rialisations jSON n\u00e9cessaires. Ceci parce que les filtres \u00e0 appliquer \u00e0 la valeur post\u00e9e et \u00e0 la r\u00e9ponse re\u00e7ue peuvent \u00eatre diff\u00e9rents et l'exp\u00e9rience montre qu'il est plus facile de les g\u00e9rer soi-m\u00eame que d'essayer de configurer le composant [RestTemplate] afin qu'il utilise le bon convertisseur jSON\u00a0;</p> </li> <li> <p>lignes 42-92\u00a0: d\u00e9finissent des filtres jSON. Ce sont les m\u00eames que ceux du serveur pr\u00e9sent\u00e9s et expliqu\u00e9s au paragraphe 13.5.3.1, page 231\u00a0;</p> </li> <li>lignes 43-46\u00a0: un mappeur jSON sans filtres\u00a0;</li> <li>lignes 64-68\u00a0: un mappeur jSON pour avoir une cat\u00e9gorie sans ses produits\u00a0;</li> <li>lignes 48-58\u00a0: un mappeur jSON pour avoir une cat\u00e9gorie avec ses produits\u00a0;</li> <li>lignes 83-92\u00a0: un mappeur jSON pour avoir un produit sans sa cat\u00e9gorie ;</li> <li>lignes 60-70\u00a0: un mappeur jSON pour avoir un produit avec sa cat\u00e9gorie ; Tous ces beans vont \u00eatre disponibles aux codes de la couche [DAO] ainsi qu'au test Junit.</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13632-les-entites","title":"13.6.3.2. Les entit\u00e9s","text":"<p>Les entit\u00e9s manipul\u00e9es par la couche [DAO] sont celles qu'elle \u00e9change avec le service web / jSON. Ce sont les articles et les produits. C\u00f4t\u00e9 serveur, ces entit\u00e9s avaient des annotations de persistence JPA. Ici, ces annotations ont \u00e9t\u00e9 enlev\u00e9es. Nous redonnons le code des entit\u00e9s pour rappel\u00a0:</p> <p>[AbstractEntity]</p> <pre><code>package spring.client.entities;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic abstract class AbstractEntity {\n    // propri\u00e9t\u00e9s\n    protected Long id;\n    protected Long version;\n\n    // constructeurs\n    public AbstractEntity() {\n\n    }\n\n    public AbstractEntity(Long id, Long version) {\n        this.id = id;\n        this.version = version;\n    }\n\n    // red\u00e9finition [equals] et [hashcode]\n    @Override\n    public int hashCode() {\n        return (id != null ? id.hashCode() : 0);\n    }\n\n    @Override\n    public boolean equals(Object entity) {\n        if (!(entity instanceof AbstractEntity)) {\n            return false;\n        }\n        String class1 = this.getClass().getName();\n        String class2 = entity.getClass().getName();\n        if (!class2.equals(class1)) {\n            return false;\n        }\n        AbstractEntity other = (AbstractEntity) entity;\n        return id != null &amp;&amp; this.id == other.id.longValue();\n    }\n\n    // signature jSON\n    public String toString() {\n        ObjectMapper mapper = new ObjectMapper();\n        try {\n            return mapper.writeValueAsString(this);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>[Categorie]</p> <pre><code>package spring.client.entities;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.annotation.JsonFilter;\n\n@JsonFilter(\"jsonFilterCategorie\")\npublic class Categorie extends AbstractEntity {\n\n    // propri\u00e9t\u00e9s\n    private String nom;\n\n    // les produits associ\u00e9s\n    public Set&lt;Produit&gt; produits = new HashSet&lt;Produit&gt;();\n\n    // constructeurs\n    public Categorie() {\n\n    }\n\n    public Categorie(String nom) {\n        this.nom = nom;\n    }\n\n    // m\u00e9thodes\n    public void addProduit(Produit produit) {\n        // on ajoute le produit\n        produits.add(produit);\n        // on fixe sa cat\u00e9gorie\n        produit.setCategorie(this);\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre> <p>[Produit]</p> <pre><code>package spring.webjson.client.entities;\n\nimport com.fasterxml.jackson.annotation.JsonFilter;\n\n@JsonFilter(\"jsonFilterProduit\")\npublic class Produit extends AbstractEntity {\n\n    // le nom\n    private String nom;\n  // le n\u00b0 de la cat\u00e9gorie\n    private Long idCategorie;\n  // le prix\n    private double prix;\n  // la description\n    private String description;\n\n    // la cat\u00e9gorie\n    private Categorie categorie;\n\n    // constructeurs\n    public Produit() {\n\n    }\n\n    public Produit(String nom, double prix, String description) {\n        this.nom = nom;\n        this.prix = prix;\n        this.description = description;\n    }\n\n    // getters et setters\n...\n}\n</code></pre>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13633-la-classe-daoexception","title":"13.6.3.3. La classe [DaoException]","text":"<p>Lorsque la couche [DAO] rencontrera une erreur, elle lancera une exception de type [DaoException]. Cette classe est celle utilis\u00e9e c\u00f4t\u00e9 serveur et d\u00e9crite au paragraphe 11.3.7, page 193.</p>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13634-linterface-de-la-couche-dao","title":"13.6.3.4. L'interface de la couche [DAO]","text":"<p>La couche [DAO] pr\u00e9sente l'interface [IDao] d\u00e9crite au paragraphe 11.3.7, page 193.</p> <pre><code>package spring.client.dao;\n\nimport java.util.List;\n\nimport spring.client.entities.Categorie;\nimport spring.client.entities.Produit;\n\npublic interface IDao {\n\n    // insertion d'une liste de produits\n    public List&lt;Produit&gt; addProduits(List&lt;Produit&gt; produits);\n\n    // suppression de tous les produits\n    public void deleteAllProduits();\n\n    // mise \u00e0 jour d'une liste de produits\n    public List&lt;Produit&gt; updateProduits(List&lt;Produit&gt; produits);\n\n    // obtention de tous les produits\n    public List&lt;Produit&gt; getAllProduits();\n\n    // insertion d'une liste de categories\n    public List&lt;Categorie&gt; addCategories(List&lt;Categorie&gt; categories);\n\n    // suppression de tous les categories\n    public void deleteAllCategories();\n\n    // mise \u00e0 jour d'une liste de categories\n    public List&lt;Categorie&gt; updateCategories(List&lt;Categorie&gt; categories);\n\n    // obtention de tous les categories\n    public List&lt;Categorie&gt; getAllCategories();\n\n    // un produit particulier\n    public Produit getProduitByIdWithCategorie(Long idProduit);\n\n    public Produit getProduitByIdWithoutCategorie(Long idProduit);\n\n    public Produit getProduitByNameWithCategorie(String nom);\n\n    public Produit getProduitByNameWithoutCategorie(String nom);\n\n    // une cat\u00e9gorie particuli\u00e8re\n    public Categorie getCategorieByIdWithProduits(Long idCategorie);\n\n    public Categorie getCategorieByIdWithoutProduits(Long idCategorie);\n\n    public Categorie getCategorieByNameWithProduits(String nom);\n\n    public Categorie getCategorieByNameWithoutProduits(String nom);\n\n}\n</code></pre>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13635-la-reponse-du-service-web-json","title":"13.6.3.5. La r\u00e9ponse du service web / jSON","text":"<p>Nous avons vu que toutes les URL du service web / jSON rendaient un type [Response] d\u00e9fini au paragraphe 13.5.5.3, page 238. Nous reprenons ici cette classe\u00a0:</p> <pre><code>package spring.client.dao;\n\nimport java.util.List;\n\npublic class Response&lt;T&gt; {\n\n    // ----------------- propri\u00e9t\u00e9s\n    // statut de l'op\u00e9ration\n    private int status;\n    // les \u00e9ventuels messages d'erreur\n    private List&lt;String&gt; messages;\n    // le corps de la r\u00e9ponse\n    private T body;\n\n    // constructeurs\n    public Response() {\n\n    }\n\n    public Response(int status, List&lt;String&gt; messages, T body) {\n        this.status = status;\n        this.messages = messages;\n        this.body = body;\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13636-implementation-des-echanges-avec-le-service-web-json","title":"13.6.3.6. Impl\u00e9mentation des \u00e9changes avec le service web / jSON","text":"<p>La classe [AbstractDao] impl\u00e9mente les \u00e9changes avec le service web / jSON\u00a0:</p> <pre><code>package spring.client.dao;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.web.client.RestTemplate;\n\npublic abstract class AbstractDao {\n\n    // data\n    @Autowired\n    protected RestTemplate restTemplate;\n    @Autowired\n    protected String urlServiceWebJson;\n\n    // requ\u00eate g\u00e9n\u00e9rique\n    protected String getResponse(String url, String jsonPost) {\n\n        // url : URL \u00e0 contacter\n        // jsonPost : la valeur jSON \u00e0 poster\n        try {\n            // ex\u00e9cution requ\u00eate\n            RequestEntity&lt;?&gt; request;\n            if (jsonPost != null) {\n                // requ\u00eate POST\n                request = RequestEntity.post(new URI(String.format(\"%s%s\", urlServiceWebJson, url)))\n                        .header(\"Content-Type\", \"application/json\").accept(MediaType.APPLICATION_JSON).body(jsonPost);\n            } else {\n                // requ\u00eate GET\n                request = RequestEntity.get(new URI(String.format(\"%s%s\", urlServiceWebJson, url)))\n                        .accept(MediaType.APPLICATION_JSON).build();\n            }\n            // on ex\u00e9cute la requ\u00eate\n            return restTemplate.exchange(request, new ParameterizedTypeReference&lt;String&gt;() {\n            }).getBody();\n        } catch (URISyntaxException e1) {\n            throw new DaoException(20, e1);\n        } catch (RuntimeException e2) {\n            throw new DaoException(21, e2);\n        }\n    }\n\n}\n</code></pre> <ul> <li>lignes 15-16\u00a0: injection du composant [RestTemplate] qui assure la communication avec le serveur\u00a0;</li> <li> <p>lignes 17-18\u00a0: injection de l'URL du service web / jSON\u00a0; L'impl\u00e9mentation des m\u00e9thodes de communication avec le serveur est factoris\u00e9e dans la m\u00e9thode [getResponse]\u00a0:</p> </li> <li> <p>ligne 21\u00a0: la m\u00e9thode re\u00e7oit 2 param\u00e8tres\u00a0:</p> </li> <li>[url]\u00a0: l'URL demand\u00e9e\u00a0;</li> <li>[jsonPost]\u00a0: la cha\u00eene jSON \u00e0 poster, null sinon. Si [jsonPost==null], la requ\u00eate de l'URL est faite avec un GET, sinon avec un POST\u00a0; </li> <li>ligne 38\u00a0: l'instruction qui fait la requ\u00eate au serveur et re\u00e7oit sa r\u00e9ponse. Le composant [RestTemplate] offre un nombre important de m\u00e9thodes d'\u00e9change avec le serveur. Nous avons choisi ici la m\u00e9thode [exchange], mais il en existe d'autres\u00a0;</li> <li>lignes 27-36\u00a0: il nous faut construire la requ\u00eate de type [RequestEntity]. Elle est diff\u00e9rente selon que l'on utilise un GET ou un POST pour faire la requ\u00eate\u00a0;</li> <li>lignes 30-31\u00a0: la requ\u00eate pour un GET. La classe [RequestEntity] offre des m\u00e9thodes statiques pour cr\u00e9er les requ\u00eates GET, POST, HEAD,... La m\u00e9thode [RequestEntity.get] permet de cr\u00e9er une requ\u00eate GET en cha\u00eenant les diff\u00e9rentes m\u00e9thodes qui construisent celle-ci\u00a0:</li> <li>la m\u00e9thode [RequestEntity.get] admet pour param\u00e8tre l'URL cible sous la forme d'une instance URI,</li> <li>la m\u00e9thode [accept] permet de d\u00e9finir les \u00e9l\u00e9ments de l'ent\u00eate HTTP [Accept]. Ici, nous indiquons que nous acceptons le type [application/json] que va envoyer le serveur\u00a0;</li> <li>la m\u00e9thode [build] utilise ces diff\u00e9rentes informations pour construire le type [RequestEntity] de la requ\u00eate\u00a0;</li> <li>lignes 34-35\u00a0: la requ\u00eate pour un POST. La m\u00e9thode [RequestEntity.post] permet de cr\u00e9er une requ\u00eate POST en cha\u00eenant les diff\u00e9rentes m\u00e9thodes qui construisent celle-ci\u00a0:</li> <li>la m\u00e9thode [RequestEntity.post] admet pour param\u00e8tre l'URL cible sous la forme d'une instance URI,</li> <li>la m\u00e9thode [header] d\u00e9finit un ent\u00eate HTTP. Ici on envoie au serveur l'ent\u00eate [Content-Type: application/json] pour lui indiquer que la valeur post\u00e9e va lui arriver sous la forme d'une cha\u00eene jSON\u00a0;</li> <li>la m\u00e9thode [accept] permet d'indiquer que nous acceptons le type [application/json] que va envoyer le serveur\u00a0;</li> <li>la m\u00e9thode [body] fixe la valeur post\u00e9e. Celle-ci est le 4i\u00e8me param\u00e8tre de la m\u00e9thode g\u00e9n\u00e9rique [getResponse] (ligne 1)\u00a0;</li> <li>ligne 38\u00a0: la m\u00e9thode [RestTemplate].exchange rend un type [ResponseEntity&lt;String&gt;] qui encapsule la totalit\u00e9 de la r\u00e9ponse du serveur\u00a0: ent\u00eates HTTP et corps du document. La m\u00e9thode [ResponseEntity].getBody() permet d'avoir ce corps qui repr\u00e9sente la r\u00e9ponse du serveur, ici une cha\u00eene de caract\u00e8res\u00a0;</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#13637-implementation-de-linterface-idao","title":"13.6.3.7. Impl\u00e9mentation de l'interface [IDao]","text":"<p>La classe [Dao] impl\u00e9mente l'interface [IDao]\u00a0:</p> <pre><code>package spring.client.dao;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Component;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport spring.client.entities.Categorie;\nimport spring.client.entities.Produit;\n\n@Component\npublic class Dao extends AbstractDao implements IDao {\n\n    @Autowired\n    private ApplicationContext context;\n\n    // filtres jSON\n    @Autowired\n    @Qualifier(\"jsonMapper\")\n    private ObjectMapper jsonMapper;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithProduits\")\n    private ObjectMapper jsonMapperCategorieWithProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithCategorie\")\n    private ObjectMapper jsonMapperProduitWithCategorie;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithoutProduits\")\n    private ObjectMapper jsonMapperCategorieWithoutProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithoutCategorie\")\n    private ObjectMapper jsonMapperProduitWithoutCategorie;\n\n    @Override\n    public List&lt;Produit&gt; addProduits(List&lt;Produit&gt; produits) {\n        // ----------- ajouter des produits (sans leur cat\u00e9gorie)\n        ...\n}\n</code></pre> <ul> <li>ligne 17\u00a0: la classe [Dao] est un composant Spring dans lequel on peut donc injecter d'autres composants Spring\u00a0;</li> <li>ligne 18\u00a0: la classe [Dao] \u00e9tend la classe [AbstractDao] que nous venons de voir et impl\u00e9mente l'interface [IDao]\u00a0;</li> <li>lignes 20-21\u00a0: on injecte le contexte Spring afin d'avoir acc\u00e8s \u00e0 ses beans\u00a0;</li> <li>lignes 24-38\u00a0: injection des mappeurs jSON d\u00e9finis dans la classe [AppConfig] pr\u00e9sent\u00e9e au paragraphe 13.6.2, page 249\u00a0; Les impl\u00e9mentations des diff\u00e9rentes m\u00e9thodes de l'interface [IDao] suivent toutes le m\u00eame sch\u00e9ma. Nous allons pr\u00e9senter deux m\u00e9thodes, l'une s'appuyant sur une op\u00e9ration [POST], l'autre sur une op\u00e9ration [GET].</li> </ul> <p>Un exemple de [GET]\u00a0: [getCategorieByNameWithProduits]</p> <pre><code>@Override\n    public Categorie getCategorieByNameWithProduits(String nom) {\n        // ----------- obtenir une cat\u00e9gorie d\u00e9sign\u00e9e par son nom, avec ses produits\n        try {\n            // requ\u00eate\n            Response&lt;Categorie&gt; response = jsonMapperCategorieWithProduits.readValue(\n                    getResponse(String.format(\"/getCategorieByNameWithProduits/%s\", nom), null),\n                    new TypeReference&lt;Response&lt;Categorie&gt;&gt;() {\n                    });\n            // erreur ?\n            if (response.getStatus() != 0) {\n                // on lance 1 exception\n                throw new DaoException(response.getStatus(), response.getMessages());\n            } else {\n                // on rend le coeur de la r\u00e9ponse du serveur\n                return response.getBody();\n            }\n        } catch (DaoException e1) {\n            throw e1;\n        } catch (RuntimeException | IOException e2) {\n            throw new DaoException(113, e2);\n        }\n    }\n</code></pre> <ul> <li> <p>ligne 7\u00a0: on appelle la m\u00e9thode [getResponse] de la classe parent. C'est cette m\u00e9thode qui assure les \u00e9changes avec le service web / jSON. Ses param\u00e8tres sont les suivants\u00a0: <pre><code>getResponse(String.format(\"/getCategorieByNameWithProduits/%s\", nom), null)\n</code></pre></p> </li> <li> <p>l'URL du service interrog\u00e9e [/getCategorieByNameWithProduits/nom]\u00a0;</p> </li> <li>la valeur post\u00e9e. Ici il n'y en a pas\u00a0; La m\u00e9thode [getResponse] rend un type String qui est la r\u00e9ponse jSON envoy\u00e9e par le serveur. On d\u00e9s\u00e9rialise cette r\u00e9ponse jSON de la fa\u00e7on suivante\u00a0:</li> </ul> <pre><code>jsonMapperCategorieWithProduits.readValue(\n                    jsonResponse,\n                    new TypeReference&lt;Response&lt;Categorie&gt;&gt;() {\n});\n</code></pre> <p>parce que la cha\u00eene jSON est la s\u00e9rialisation d'un type [Response&lt;Categorie&gt;]\u00a0;</p> <ul> <li>lignes 11-17\u00a0: on teste le statut de la r\u00e9ponse. Si le statut est diff\u00e9rent de 0, alors c'est qu'il y a eu une erreur c\u00f4t\u00e9 serveur. On lance alors une exception (ligne 13), en reprenant les informations contenues dans la r\u00e9ponse (statut et liste de messages d'erreur)\u00a0;</li> <li>ligne 16\u00a0: s'il n'y a pas eu d'erreur c\u00f4t\u00e9 serveur, on rend le corps du type [Response&lt;Categorie&gt;], \u00e7-\u00e0-d la cat\u00e9gorie demand\u00e9e\u00a0;</li> <li>lignes 18-19\u00a0: on g\u00e8re l'exception lanc\u00e9e ligne 16\u00a0;</li> <li>lignes 20-22\u00a0: traitent toutes les autres exceptions\u00a0; Un exemple de [POST]\u00a0: [addCategories]</li> </ul> <pre><code>@Override\n    public List&lt;Categorie&gt; addCategories(List&lt;Categorie&gt; categories) {\n        // ----------- ajouter des cat\u00e9gories (avec leurs produits)\n        try {\n            // requ\u00eate\n            Response&lt;List&lt;Categorie&gt;&gt; response = jsonMapperCategorieWithProduits.readValue(\n                    getResponse(\"/addCategories\", jsonMapperCategorieWithProduits.writeValueAsString(categories)),\n                    new TypeReference&lt;Response&lt;List&lt;Categorie&gt;&gt;&gt;() {\n                    });\n            // erreur ?\n            if (response.getStatus() != 0) {\n                // on lance 1 exception\n                throw new DaoException(response.getStatus(), response.getMessages());\n            } else {\n                // on rend le coeur de la r\u00e9ponse du serveur\n                return response.getBody();\n            }\n        } catch (DaoException e1) {\n            throw e1;\n        } catch (RuntimeException | IOException e2) {\n            throw new DaoException(104, e2);\n        }\n    }\n</code></pre> <ul> <li>ligne 2\u00a0: la m\u00e9thode [addCategories] sert \u00e0 persister en base de donn\u00e9es les cat\u00e9gories pass\u00e9es en param\u00e8tre. Elle rend ces m\u00eames cat\u00e9gories enrichies de leurs cl\u00e9s primaires. Si les cat\u00e9gories sont pass\u00e9es avec des produits, ceux-ci sont \u00e9galement persist\u00e9s\u00a0;</li> <li>ligne 7\u00a0: on appelle la m\u00e9thode [getResponse] du parent pour faire les \u00e9changes avec le service web / jSON\u00a0;</li> <li>le 1er param\u00e8tre est l'URL [/addCategories]\u00a0;</li> <li>le second param\u00e8tre est la valeur post\u00e9e, ici la liste des cat\u00e9gories \u00e0 persister\u00a0; <pre><code>getResponse(\"/addCategories\", jsonMapperCategorieWithProduits.writeValueAsString(categories))\n</code></pre></li> </ul> <p>La cha\u00eene jSON obtenue est ensuite d\u00e9s\u00e9rialis\u00e9e pour obtenir le type [Response&lt;List&lt;Categorie&gt;] attendu\u00a0:</p> <pre><code>Response&lt;List&lt;Categorie&gt;&gt; response = jsonMapperCategorieWithProduits.readValue(\n                    jsonResponse,\n                    new TypeReference&lt;Response&lt;List&lt;Categorie&gt;&gt;&gt;() {\n                    });\n</code></pre> <ul> <li>lignes 11-17\u00a0: gestion de la r\u00e9ponse du serveur (erreur ou pas)\u00a0;</li> <li>lignes 20-22\u00a0: gestion des exceptions\u00a0; Toutes les autres m\u00e9thodes suivent le canevas des deux m\u00e9thodes pr\u00e9sent\u00e9es.</li> </ul>"},{"location":"cours-exposer-une-base-de-donnees-sur-le-web-avec-spring-mvc.html#1364-le-test-junit","title":"13.6.4. Le test JUnit","text":"<p>Revenons \u00e0 l'architecture client / serveur en cours de construction\u00a0:</p> <p>Nous avons construit une couche [DAO] [2] avec la m\u00eame interface que la couche [DAO] [4]. Pour tester la couche [DAO] [2], on peut donc utiliser le test JUnit qui a servi \u00e0 tester la couche [DAO] [4]. Pour rappel, celui-ci est le suivant\u00a0:</p> <pre><code>package spring.client.junit;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.collect.Lists;\n\nimport spring.client.config.DaoConfig;\nimport spring.client.dao.DaoException;\nimport spring.client.dao.IDao;\nimport spring.client.entities.Categorie;\nimport spring.client.entities.Produit;\n\n@SpringApplicationConfiguration(classes = DaoConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // couche [DAO]\n    @Autowired\n    private IDao dao;\n\n    // filtres jSON\n    @Autowired\n    @Qualifier(\"jsonMapper\")\n    private ObjectMapper jsonMapper;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithProduits\")\n    private ObjectMapper jsonMapperCategorieWithProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithCategorie\")\n    private ObjectMapper jsonMapperProduitWithCategorie;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithoutProduits\")\n    private ObjectMapper jsonMapperCategorieWithoutProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithoutCategorie\")\n    private ObjectMapper jsonMapperProduitWithoutCategorie;\n\n    @Before\n    public void cleanAndFill() {\n        // on nettoie la base avant chaque test\n        log(\"Vidage de la base de donn\u00e9es\", 1);\n        // on vide la table [CATEGORIES] - par cascade la table [PRODUITS] va \u00eatre vid\u00e9e\n        dao.deleteAllCategories();\n        // --------------------------------------------------------------------------------------\n        log(\"Remplissage de la base\", 1);\n        // on remplit les tables\n        List&lt;Categorie&gt; categories = new ArrayList&lt;Categorie&gt;();\n        for (int i = 0; i &lt; 2; i++) {\n            Categorie categorie = new Categorie(String.format(\"categorie%d\", i));\n            for (int j = 0; j &lt; 5; j++) {\n                categorie.addProduit(new Produit(String.format(\"produit%d%d\", i, j), 100 * (1 + (double) (i * 10 + j) / 100),\n                        String.format(\"desc%d%d\", i, j)));\n            }\n            categories.add(categorie);\n        }\n        // ajout de la cat\u00e9gorie - par cascade les produits vont eux aussi \u00eatre ins\u00e9r\u00e9s\n        categories = dao.addCategories(categories);\n    }\n\n    @Test\n    public void showDataBase() throws BeansException, JsonProcessingException {\n        // liste des cat\u00e9gories\n        log(\"Liste des cat\u00e9gories\", 2);\n        List&lt;Categorie&gt; categories = dao.getAllCategories();\n        affiche(categories, jsonMapperCategorieWithoutProduits);\n        // liste des produits\n        log(\"Liste des produits\", 2);\n        List&lt;Produit&gt; produits = dao.getAllProduits();\n        affiche(produits, jsonMapperProduitWithoutCategorie);\n        // quelques v\u00e9rifications\n        Assert.assertEquals(2, categories.size());\n        Assert.assertEquals(10, produits.size());\n        Categorie categorie = findCategorieByName(\"categorie0\", categories);\n        Assert.assertNotNull(categorie);\n        Produit produit = findProduitByName(\"produit03\", produits);\n        Assert.assertNotNull(produit);\n        Long idCategorie = produit.getIdCategorie();\n        Assert.assertEquals(categorie.getId(), idCategorie);\n    }\n\n    @Test\n    public void getCategorieByNameWithProduits() {\n        log(\"getCategorieByNameWithProduits\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithProduits(\"categorie1\");\n        Assert.assertNotNull(categorie1);\n        Assert.assertEquals(5, categorie1.getProduits().size());\n    }\n\n    @Test\n    public void getCategorieByNameWithoutProduits() {\n        log(\"getCategorieByNameWithoutProduits\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithoutProduits(\"categorie1\");\n        Assert.assertNotNull(categorie1);\n        Assert.assertEquals(\"categorie1\", categorie1.getNom());\n    }\n\n    @Test\n    public void getCategorieByIdWithProduits() {\n        log(\"getCategorieByIdWithProduits\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithProduits(\"categorie1\");\n        Categorie categorie2 = dao.getCategorieByIdWithProduits(categorie1.getId());\n        Assert.assertNotNull(categorie2);\n        Assert.assertEquals(categorie1.getId(), categorie2.getId());\n        Assert.assertEquals(categorie1.getNom(), categorie2.getNom());\n    }\n\n    @Test\n    public void getCategorieByIdWithoutProduits() {\n        log(\"getCategorieByIdWithoutProduits\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithProduits(\"categorie1\");\n        Categorie categorie2 = dao.getCategorieByIdWithoutProduits(categorie1.getId());\n        Assert.assertNotNull(categorie2);\n        Assert.assertEquals(categorie1.getNom(), categorie2.getNom());\n    }\n\n    @Test\n    public void getProduitByNameWithCategorie() {\n        log(\"getProduitByNameWithCategorie\", 1);\n        Produit produit = dao.getProduitByNameWithCategorie(\"produit03\");\n        Assert.assertNotNull(produit);\n        Assert.assertNotNull(produit.getCategorie());\n    }\n\n    @Test\n    public void getProduitByNameWithoutCategorie() {\n        log(\"getProduitByNameWithoutCategorie\", 1);\n        Produit produit = dao.getProduitByNameWithoutCategorie(\"produit03\");\n        Assert.assertNotNull(produit);\n        Assert.assertEquals(\"produit03\", produit.getNom());\n    }\n\n    @Test\n    public void getProduitByIdWithCategorie() {\n        log(\"getProduitByNameWithCategorie\", 1);\n        Produit produit = dao.getProduitByNameWithCategorie(\"produit03\");\n        Produit produit2 = dao.getProduitByIdWithCategorie(produit.getId());\n        Assert.assertNotNull(produit2);\n        Assert.assertEquals(produit2.getNom(), produit.getNom());\n        Assert.assertEquals(produit2.getId(), produit.getId());\n        Assert.assertEquals(produit.getCategorie().getId(), produit2.getCategorie().getId());\n    }\n\n    @Test\n    public void getProduitByIdWithoutCategorie() {\n        log(\"getProduitByIdWithoutCategorie\", 1);\n        Produit produit = dao.getProduitByNameWithCategorie(\"produit03\");\n        Produit produit2 = dao.getProduitByIdWithoutCategorie(produit.getId());\n        Assert.assertNotNull(produit2);\n        Assert.assertEquals(produit2.getNom(), produit.getNom());\n        Assert.assertEquals(produit2.getId(), produit.getId());\n    }\n\n    @Test\n    public void doInsertsInTransaction() {\n        log(\"Ajout d'une cat\u00e9gorie [cat1] avec deux produits de m\u00eame nom\", 1);\n        // on fait l'insertion\n        Categorie categorie = new Categorie(\"cat1\");\n        categorie.addProduit(new Produit(\"x\", 1.0, \"\"));\n        categorie.addProduit(new Produit(\"x\", 1.0, \"\"));\n        // ajout de la cat\u00e9gorie - par cascade les produits vont eux aussi \u00eatre ins\u00e9r\u00e9s\n        try {\n            categorie = dao.addCategories(Lists.newArrayList(categorie)).get(0);\n        } catch (DaoException e) {\n            show(\"Les erreurs suivantes se sont produites :\", e.getErreurs());\n        }\n        // v\u00e9rifications\n        List&lt;Categorie&gt; categories = dao.getAllCategories();\n        Assert.assertEquals(2, categories.size());\n        List&lt;Produit&gt; produits = dao.getAllProduits();\n        Assert.assertEquals(10, produits.size());\n    }\n\n    @Test\n    public void updateDataBase() {\n        log(\"Mise \u00e0 jour du prix des produits de [categorie1]\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithProduits(\"categorie1\");\n        Categorie categorie1Saved = dao.getCategorieByNameWithProduits(\"categorie1\");\n        Set&lt;Produit&gt; produits = categorie1.getProduits();\n        for (Produit produit : produits) {\n            produit.setPrix(1.1 * produit.getPrix());\n        }\n        List&lt;Produit&gt; produits2 = Lists.newArrayList(produits);\n        produits2 = dao.updateProduits(produits2);\n        // v\u00e9rifications\n        List&lt;Produit&gt; produitsSaved = Lists.newArrayList(categorie1Saved.getProduits());\n        for (Produit produit2 : produits2) {\n            Produit produit = findProduitByName(produit2.getNom(), produitsSaved);\n            Assert.assertEquals(produit2.getPrix(), produit.getPrix() * 1.1, 1e-6);\n        }\n    }\n\n    @Test\n    public void addProduits() throws BeansException, JsonProcessingException {\n        log(\"Ajout de deux produits de cat\u00e9gorie [categorie0]\", 1);\n        Categorie categorie0 = dao.getCategorieByNameWithoutProduits(\"categorie0\");\n        Long idCategorie = categorie0.getId();\n        Produit p1 = new Produit(\"x\", 1, \"\");\n        p1.setIdCategorie(idCategorie);\n        p1.setCategorie(categorie0);\n        Produit p2 = new Produit(\"y\", 1, \"\");\n        p2.setIdCategorie(idCategorie);\n        p2.setCategorie(categorie0);\n        List&lt;Produit&gt; produits = new ArrayList&lt;Produit&gt;();\n        produits.add(p1);\n        produits.add(p2);\n        produits = dao.addProduits(produits);\n        // v\u00e9rification\n        affiche(produits, jsonMapperProduitWithoutCategorie);\n    }\n\n    // -------------- m\u00e9thodes priv\u00e9es\n    private Produit findProduitByName(String nom, List&lt;Produit&gt; produits) {\n        for (Produit produit : produits) {\n            if (produit.getNom().equals(nom)) {\n                return produit;\n            }\n        }\n        return null;\n    }\n\n    private Categorie findCategorieByName(String nom, List&lt;Categorie&gt; categories) {\n        for (Categorie categorie : categories) {\n            if (categorie.getNom().equals(nom)) {\n                return categorie;\n            }\n        }\n        return null;\n    }\n\n    // affichage d'un \u00e9l\u00e9ment de type T\n    static private &lt;T&gt; void affiche(T element, ObjectMapper jsonMapper) throws JsonProcessingException {\n        System.out.println(jsonMapper.writeValueAsString(element));\n    }\n\n    // affichage d'une liste d'\u00e9l\u00e9ments de type T\n    static private &lt;T&gt; void affiche(List&lt;T&gt; elements, ObjectMapper jsonMapper) throws JsonProcessingException {\n        for (T element : elements) {\n            affiche(element, jsonMapper);\n        }\n    }\n\n    private static void log(String message, int mode) {\n        // affiche message\n        String toPrint = null;\n        switch (mode) {\n        case 1:\n            toPrint = String.format(\"%s --------------------------------\", message);\n            break;\n        case 2:\n            toPrint = String.format(\"-- %s\", message);\n            break;\n        }\n        System.out.println(toPrint);\n    }\n\n    private static void show(String title, List&lt;String&gt; messages) {\n        // titre\n        System.out.println(String.format(\"%s : \", title));\n        // messages\n        for (String message : messages) {\n            System.out.println(String.format(\"- %s\", message));\n        }\n    }\n\n}\n</code></pre> <p>Son ex\u00e9cution r\u00e9ussit et donne les r\u00e9sultats suivants sur la console\u00a0:</p> <pre><code>Vidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\nAjout de deux produits de cat\u00e9gorie [categorie0] --------------------------------\n{\"id\":6285,\"version\":0,\"nom\":\"x\",\"idCategorie\":1319,\"prix\":1.0,\"description\":\"\"}\n{\"id\":6286,\"version\":0,\"nom\":\"y\",\"idCategorie\":1319,\"prix\":1.0,\"description\":\"\"}\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\nMise \u00e0 jour du prix des produits de [categorie1] --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetCategorieByIdWithoutProduits --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetProduitByNameWithoutCategorie --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetCategorieByNameWithProduits --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetCategorieByNameWithoutProduits --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetProduitByNameWithCategorie --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetProduitByNameWithCategorie --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetProduitByIdWithoutCategorie --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\n-- Liste des cat\u00e9gories\n{\"id\":1337,\"version\":0,\"nom\":\"categorie0\"}\n{\"id\":1338,\"version\":0,\"nom\":\"categorie1\"}\n-- Liste des produits\n{\"id\":6367,\"version\":0,\"nom\":\"produit00\",\"idCategorie\":1337,\"prix\":100.0,\"description\":\"desc00\"}\n{\"id\":6368,\"version\":0,\"nom\":\"produit01\",\"idCategorie\":1337,\"prix\":101.0,\"description\":\"desc01\"}\n{\"id\":6369,\"version\":0,\"nom\":\"produit02\",\"idCategorie\":1337,\"prix\":102.0,\"description\":\"desc02\"}\n{\"id\":6370,\"version\":0,\"nom\":\"produit03\",\"idCategorie\":1337,\"prix\":103.0,\"description\":\"desc03\"}\n{\"id\":6371,\"version\":0,\"nom\":\"produit04\",\"idCategorie\":1337,\"prix\":104.0,\"description\":\"desc04\"}\n{\"id\":6372,\"version\":0,\"nom\":\"produit10\",\"idCategorie\":1338,\"prix\":110.0,\"description\":\"desc10\"}\n{\"id\":6373,\"version\":0,\"nom\":\"produit11\",\"idCategorie\":1338,\"prix\":111.0,\"description\":\"desc11\"}\n{\"id\":6374,\"version\":0,\"nom\":\"produit12\",\"idCategorie\":1338,\"prix\":112.0,\"description\":\"desc12\"}\n{\"id\":6375,\"version\":0,\"nom\":\"produit13\",\"idCategorie\":1338,\"prix\":113.0,\"description\":\"desc13\"}\n{\"id\":6376,\"version\":0,\"nom\":\"produit14\",\"idCategorie\":1338,\"prix\":114.0,\"description\":\"desc14\"}\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\ngetCategorieByIdWithProduits --------------------------------\nVidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\nAjout d'une cat\u00e9gorie [cat1] avec deux produits de m\u00eame nom --------------------------------\nLes erreurs suivantes se sont produites : \n- org.hibernate.exception.ConstraintViolationException: could not execute statement\n- could not execute statement\n- Duplicate entry 'x' for key 'NOM'\n11:24:37.650 [Thread-1] INFO  o.s.c.a.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@f8c1ddd: startup date [Fri Nov 20 11:24:34 CET 2015]; root of context hierarchy\n</code></pre>"},{"location":"cours-gestion-des-acces-inter-domaines.html","title":"18. [Cours]\u00a0: Gestion des acc\u00e8s inter-domaines","text":"<p>Mots cl\u00e9s : CORS (Cross-Origin Resource Sharing).</p> <p>Ce chapitre est un peu \u00e0 l'\u00e9cart du TD. Il a \u00e9t\u00e9 gard\u00e9 parce qu'il introduit la programmation web et la programmation Javascript. Il faut se rappeler ici que l'un des objectifs de ce TD est de pr\u00e9senter les concepts fr\u00e9quemment utilis\u00e9s dans le d\u00e9velopement JEE, \u00e7-\u00e0-d le d\u00e9veloppement web s'appuyant sur des frameworks Java. On compl\u00e8te ici, le serveur web utilis\u00e9 dans l'\u00e9tude de la base de donn\u00e9es de produits et de cat\u00e9gories pour lui permettre d'accepter des requ\u00eates inter-domaines.</p> <p>Dans le document [Tutoriel AngularJS / Spring 4], on d\u00e9veloppe une application client / serveur o\u00f9 le client est une application AngularJS\u00a0:</p> <ul> <li>les pages HTML / CSS / JS de l'application Angular viennent du serveur [1]\u00a0;</li> <li>en [2], le service [dao] fait une requ\u00eate \u00e0 un autre serveur, le serveur [2]. Et bien \u00e7a, c'est interdit par le navigateur qui ex\u00e9cute l'application Angular parce que c'est une faille de s\u00e9curit\u00e9. L'application ne peut interroger que le serveur d'o\u00f9 elle vient, \u00e7-\u00e0-d le serveur [1]\u00a0; En fait, il est inexact de dire que le navigateur interdit \u00e0 l'application Angular d'interroger le serveur [2]. Elle l'interroge en fait pour lui demander s'il autorise un client qui ne vient pas de chez lui \u00e0 l'interroger. On appelle cette technique de partage, le CORS (Cross-Origin Resource Sharing). Le serveur [2] donne son accord en envoyant des ent\u00eates HTTP pr\u00e9cis.</li> </ul> <p>Nous allons cr\u00e9er l'architecture suivante\u00a0:</p> <ul> <li>en [1], une application web d\u00e9livre des pages HTML / jS\u00a0;</li> <li>en [2], le navigateur ex\u00e9cute le Javascript embarqu\u00e9 dans les pages HTML pour interroger le service web s\u00e9curis\u00e9 [3]\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#181-support","title":"18.1. Support","text":"<p>Les projets de ce chapitre seront trouv\u00e9s dans le dossier [support / chap-18].</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#182-le-projet-du-client","title":"18.2. Le projet du client","text":"<p>On cr\u00e9e le projet Eclipse suivant\u00a0:</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#183-configuration-maven","title":"18.3. Configuration Maven","text":"<p>Le projet est un projet Maven avec le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.webjson&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-server-webjson-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;name&gt;intro-server-webjson-01&lt;/name&gt;\n    &lt;description&gt;d\u00e9mo spring mvc&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.springdata&lt;/groupId&gt;\n            &lt;artifactId&gt;intro-spring-data-01&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 11-15\u00a0: c'est un projet Spring Boot\u00a0;</li> <li>lignes 23-26\u00a0: on utilise la d\u00e9pendance [spring-boot-starter-web] qui am\u00e8ne avec elle un serveur Tomcat et Spring MVC\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#184-configuration-spring","title":"18.4. Configuration Spring","text":"<p>La classe [WebConfig] qui configure le projet Spring est la suivante\u00a0:</p> <pre><code>package spring.cors.client.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;\nimport org.springframework.boot.context.embedded.ServletRegistrationBean;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\n@EnableWebMvc\npublic class WebConfig extends WebMvcConfigurerAdapter {\n\n    // -------------------------------- configuration couche [web]\n    @Autowired\n    private ApplicationContext context;\n\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        DispatcherServlet servlet = new DispatcherServlet((WebApplicationContext) context);\n        return servlet;\n    }\n\n    @Bean\n    public ServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) {\n        return new ServletRegistrationBean(dispatcherServlet, \"/*\");\n    }\n\n    @Bean\n    public EmbeddedServletContainerFactory embeddedServletContainerFactory() {\n        return new TomcatEmbeddedServletContainerFactory(\"\", 8081);\n    }\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        registry.addResourceHandler(\"/*.html\").addResourceLocations(\"classpath:/static/\");\n        registry.addResourceHandler(\"/*.js\").addResourceLocations(\"classpath:/static/js/\");\n    }\n}\n</code></pre> <ul> <li>ligne 15\u00a0: la classe configure un projet Spring MVC\u00a0;</li> <li>ligne 16\u00a0: la classe \u00e9tend la classe [WebMvcConfigurerAdapter] pour red\u00e9finir certaines de ses m\u00e9thodes\u00a0;</li> <li>lignes 18-36\u00a0: nous avons d\u00e9j\u00e0 rencontr\u00e9 ces beans, par exemple au paragraphe 13.5.3.1, page 231\u00a0. On notera, ligne 35, que le service web fonctionnera sur le port 8081\u00a0;</li> <li>lignes 38-42\u00a0: la m\u00e9thode [addResourceHandlers] permet de d\u00e9finir des ressources statiques, \u00e7-\u00e0-d des ressources non trait\u00e9es par la [DispatcherServlet] de la ligne 23\u00a0;</li> <li>ligne 40\u00a0: toute requ\u00eate d'une ressource ayant un suffixe .html aura pour r\u00e9ponse le fichier demand\u00e9 par la requ\u00eate et trouv\u00e9 dans le dossier [static] du Classpath du projet\u00a0;</li> <li>ligne 41\u00a0: toute requ\u00eate d'une ressource ayant un suffixe .js aura pour r\u00e9ponse le fichier Javascript demand\u00e9 par la requ\u00eate et trouv\u00e9 dans le dossier [static/js] du Classpath du projet\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#185-rudiments-de-jquery-et-de-javascript","title":"18.5. Rudiments de jQuery et de Javascript","text":"<p>La page HTML du client sera la suivante\u00a0:</p> <p>Elle embarquera avec elle du code Javascript (jS) ex\u00e9cut\u00e9 dans le navigateur. Nous allons pr\u00e9senter quelques rudiments de Javascript qui vont nous permettre de comprendre le code. Le client va faire des appels HTTP \u00e0 l'aide de la biblioth\u00e8que jQuery [https://jquery.com/] qui apporte de nombreuses fonctions facilitant le d\u00e9veloppement Javascript. Nous cr\u00e9ons un fichier statique HTML [jQuery.html] que l'on place dans le dossier [static]\u00a0:</p> <p>Ce fichier aura le contenu suivant\u00a0:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;\n&lt;title&gt;JQuery-01&lt;/title&gt;\n&lt;script type=\"text/javascript\" src=\"/jquery-2.1.3.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h3&gt;Rudiments de JQuery&lt;/h3&gt;\n    &lt;div id=\"element1\"&gt;El\u00e9ment 1&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 6\u00a0: importation de jQuery\u00a0;</li> <li>lignes 10-12\u00a0: un \u00e9l\u00e9ment de la page d'id [element1]. Nous allons jouer avec cet \u00e9l\u00e9ment. Il nous faut t\u00e9l\u00e9charger le fichier [jquery-2.1.3.min.js]. On trouvera la derni\u00e8re version de jQuery \u00e0 l'URL [http://jquery.com/download/]\u00a0:</li> </ul> <p></p> <p>On placera le fichier t\u00e9l\u00e9charg\u00e9 dans le dossier [static / js] et on changera la ligne 6 du fichier HTML en fonction de la version install\u00e9e.</p> <p>Ceci fait, on demande la vue statique [jQuery.html] avec Chrome [1-2]\u00a0:</p> <p>Avec Google Chrome, faire [Ctrl-Maj-I] pour faire appara\u00eetre les outils de d\u00e9veloppement [3]. L'onglet [Console] [4] permet d'ex\u00e9cuter du code Javascript. Nous donnons dans ce qui suit des commandes Javascript \u00e0 taper et nous en donnons une explication.</p> <pre><code>JS\n</code></pre> <pre><code>r\u00e9sultat\n</code></pre> <pre><code>$(\"#element1\")\n</code></pre> <p>: rend la collection de tous les \u00e9l\u00e9ments d'id [element1], donc normalement une collection de 0 ou 1 \u00e9l\u00e9ment parce qu'on ne peut avoir deux id identiques dans une page HTML.</p> <pre><code>$(\"#element1\").text(\"blabla\")\n</code></pre> <p>: affecte le texte [blabla] \u00e0 tous les \u00e9l\u00e9ments de la collection. Ceci a pour effet de changer le contenu affich\u00e9 par la page</p> <pre><code>$(\"#element1\").hide()\n</code></pre> <p>cache les \u00e9l\u00e9ments de la collection. Le texte [blabla] n'est plus affich\u00e9.</p> <pre><code>$(\"#element1\")\n</code></pre> <p>: affiche de nouveau la collection. Cela nous permet de voir que l'\u00e9l\u00e9ment d'id [element1] a l'attribut CSS style='display\u00a0: none;' qui fait que l'\u00e9l\u00e9ment est cach\u00e9.</p> <pre><code>$(\"#element1\").show()\n</code></pre> <p>: affiche les \u00e9l\u00e9ments de la collection. Le texte [blabla] appara\u00eet de nouveau. C'est l'attribut CSS style='display\u00a0: block;' qui assure cet affichage.</p> <pre><code>$(\"#element1\").attr('style','color: red')\n</code></pre> <p>: fixe un attribut \u00e0 tous les \u00e9l\u00e9ments de la collection. L'attribut est ici [style] et sa valeur [color: red]. Le texte [blabla] passe en rouge.</p> <pre><code>Tableau\n</code></pre> <pre><code>Dictionnaire\n</code></pre> <p>On notera que l'URL du navigateur n'a pas chang\u00e9 pendant toutes ces manipulations. Il n'y a pas eu d'\u00e9changes avec le serveur web. Tout se passe \u00e0 l'int\u00e9rieur du navigateur. Maintenant, visualisons le code source de la page\u00a0:</p> <p>C'est le texte initial. Il ne refl\u00e8te en rien les manipulations que l'on a faites sur l'\u00e9l\u00e9ment des lignes 10-12. Il est important de s'en souvenir lorsqu'on fait du d\u00e9bogage Javascript. Il est alors souvent inutile de visualiser le code source de la page affich\u00e9e.</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#186-le-code-javascript-de-lapplication","title":"18.6. Le code Javascript de l'application","text":"<p>Revenons \u00e0 la page de l'application cliente qui va interroger le service web / jSON\u00a0:</p> <p>Le code HTML de cette page est le suivant\u00a0:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;title&gt;Spring MVC&lt;/title&gt;\n&lt;script type=\"text/javascript\" src=\"/jquery-2.1.3.min.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"/client.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h2&gt;Client du service web / jSON&lt;/h2&gt;\n    &lt;form id=\"formulaire\"&gt;\n        &lt;!--  identifiant --&gt;\n        Identifiant :\n        &lt;!--  --&gt;\n        &lt;input type=\"text\" id=\"identifiant\" name=\"identifiant\" value=\"\" /&gt;\n        &lt;!--  mot de passe --&gt;\n        &lt;br /&gt; &lt;br /&gt; Mot de passe :\n        &lt;!--  --&gt;\n        &lt;input type=\"text\" id=\"password\" name=\"password\" value=\"\" /&gt;\n        &lt;!--  m\u00e9thode HTTP --&gt;\n        &lt;br /&gt; &lt;br /&gt; M\u00e9thode HTTP :\n        &lt;!--  --&gt;\n        &lt;input type=\"radio\" id=\"get\" name=\"method\" value=\"get\"\n            checked=\"checked\" /&gt;GET\n        &lt;!--  --&gt;\n        &lt;input type=\"radio\" id=\"post\" name=\"method\" value=\"post\" /&gt;POST\n        &lt;!--  URL --&gt;\n        &lt;br /&gt; &lt;br /&gt;URL cible (commen\u00e7ant par /): &lt;input type=\"text\"\n            id=\"url\" size=\"30\"&gt;&lt;br /&gt;\n        &lt;!-- valeur post\u00e9e --&gt;\n        &lt;br /&gt; Cha\u00eene jSON \u00e0 poster : &lt;input type=\"text\" id=\"posted\"\n            size=\"50\" /&gt;\n        &lt;!-- bouton de validation --&gt;\n        &lt;br /&gt; &lt;br /&gt; &lt;input type=\"button\" value=\"Valider\"\n            onclick=\"javascript:requestServer()\"&gt;&lt;/input&gt;\n    &lt;/form&gt;\n    &lt;hr /&gt;\n    &lt;h2&gt;R\u00e9ponse du serveur&lt;/h2&gt;\n    &lt;div id=\"response\"&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 6\u00a0: on importe la biblioth\u00e8que jQuery\u00a0;</li> <li>ligne 7\u00a0: on importe un code que nous allons \u00e9crire\u00a0;</li> <li>lignes 15, 19, 26, 29, 31\u00a0: on notera les identifiants [id] des composants de la page. Le javascript r\u00e9f\u00e9rence ces composants via ces identifiants\u00a0; Le code [client.js] est le suivant\u00a0:</li> </ul> <pre><code>// donn\u00e9es globales\nvar url;\nvar posted;\nvar response;\nvar method;\nvar baseUrl = 'http://localhost:8080';\nvar identifiant;\nvar password;\nvar authorizationHeader;\n\nfunction requestServer() {\n    // on r\u00e9cup\u00e8re les informations\n    var urlValue = url.val();\n    var postedValue = posted.val();\n    var identifiantValue = identifiant.val();\n    var passwordValue = password.val();\n    var method = document.forms[0].elements['method'].value;\n    authorizationCode = btoa(identifiantValue + ':' + passwordValue);\n    // on efface la r\u00e9ponse pr\u00e9c\u00e9dente\n    response.text(\"\");\n    // on fait un appel Ajax \u00e0 la main\n    if (method === \"get\") {\n        doGet(urlValue);\n    } else {\n        doPost(urlValue, postedValue);\n    }\n}\n\nfunction doGet(url) {\n    // on fait un appel Ajax \u00e0 la main\n    $.ajax({\n        headers : {\n            'Authorization':'Basic '+authorizationCode\n        },\n        url : baseUrl + url,\n        type : 'GET',\n        dataType : 'text',\n        beforeSend : function() {\n        },\n        success : function(data) {\n            // r\u00e9sultat texte\n            response.text(data);\n        },\n        complete : function() {\n        },\n        error : function(jqXHR) {\n            // erreur syst\u00e8me\n            response.text(JSON.stringify(jqXHR.statusCode()));\n        }\n    })\n}\n\nfunction doPost(url, posted) {\n    // on fait un appel Ajax \u00e0 la main\n    $.ajax({\n        headers : {\n            'Authorization':'Basic '+authorizationCode\n        },\n        url : baseUrl + url,\n        type : 'POST',\n        contentType : 'application/json; charset=UTF-8',\n        data : posted,\n        dataType : 'text',\n        beforeSend : function() {\n        },\n        success : function(data) {\n            // r\u00e9sultat texte\n            response.text(data);\n        },\n        complete : function() {\n        },\n        error : function(jqXHR) {\n            // erreur syst\u00e8me\n            response.text(JSON.stringify(jqXHR.statusCode()));\n        }\n    })\n}\n\n// au chargement du document\n$(document).ready(function() {\n    // on r\u00e9cup\u00e8re les r\u00e9f\u00e9rences des composants de la page\n    identifiant = $(\"#identifiant\");\n    password = $(\"#password\");\n    url = $(\"#url\");\n    posted = $(\"#posted\");\n    response = $(\"#response\");\n});\n</code></pre> <ul> <li>lignes 80-87\u00a0: du code jS ex\u00e9cut\u00e9 \u00e0 la fin du chargement du document dans le navigateur\u00a0;</li> <li>lignes 81-86\u00a0: on r\u00e9cup\u00e8re les r\u00e9f\u00e9rences des diff\u00e9rents \u00e9l\u00e9ments du document HTML, via leur identifiant [id]\u00a0;</li> <li>lignes 2-9\u00a0: des variables globales connues dans toute les fonctions d\u00e9finies dans le fichier jS\u00a0;</li> <li>ligne 13\u00a0: on r\u00e9cup\u00e8re l'URL tap\u00e9e par l'utilisateur\u00a0;</li> <li>ligne 14\u00a0: on r\u00e9cup\u00e8re la valeur qu'il veut poster (vide si op\u00e9ration GET)\u00a0;</li> <li>ligne 15\u00a0: on r\u00e9cup\u00e8re l'identifiant tap\u00e9 par l'utilisateur\u00a0;</li> <li>ligne 16\u00a0: on r\u00e9cup\u00e8re sont mot de passe\u00a0;</li> <li>ligne 17\u00a0: on r\u00e9cup\u00e8re la fa\u00e7on [get] ou [post] \u00e0 utiliser pour demander l'URL de la ligne 9\u00a0:</li> <li>[document] d\u00e9signe le document charg\u00e9 par le navigateur, ce qu'on appelle le DOM (Document Object Model),</li> <li>[document.forms[0]] d\u00e9signe le 1er formulaire du document, un document pouvant en avoir plusieurs. Ici, il n'y en qu'un,</li> <li> <p>[document.forms[0].elements['method']] d\u00e9signe l'\u00e9l\u00e9ment du formulaire qui a l'attribut [name='method']. Il y en a deux\u00a0: <pre><code>&lt;input type=\"radio\" id=\"get\" name=\"method\" value=\"get\" checked=\"checked\" /&gt;GET\n&lt;input type=\"radio\" id=\"post\" name=\"method\" value=\"post\" /&gt;POST\n</code></pre></p> </li> <li> <p>[document.forms[0].elements['method'].value] est la valeur qui va \u00eatre post\u00e9e pour le composant qui a l'attribut [name='method']. On sait que la valeur post\u00e9e est la valeur de l'attribut [value] du bouton radio coch\u00e9. Ici, ce sera donc l'une des cha\u00eenes ['get', 'post']\u00a0;</p> </li> <li>ligne 18\u00a0: on construit l'encodage Base74 de la cha\u00eene identifiant:password. Cet cha\u00eene cod\u00e9e va servir dans l'ent\u00eate HTTP [Authorization] que nous allons envoyer au serveur pour authentifier la requ\u00eate\u00a0;</li> <li>lignes 22-26\u00a0: selon la m\u00e9thode HTTP \u00e0 utiliser, on ex\u00e9cute la m\u00e9thode [doGet] ou [doPost]\u00a0;</li> <li>la m\u00e9thode jQuery [$.ajax] effectue un appel HTTP\u00a0;</li> <li>lignes 32-34\u00a0: on s'adresse \u00e0 un serveur qui exige un ent\u00eate HTTP [Authorization: Basic code]\u00a0;</li> <li>ligne 35\u00a0: l'utilisateur saisira des URL du type [/cors-getAllCategories,/cors-addProduits, ...]. Il faut donc compl\u00e9ter ces URL avec l'URL du serveur de la ligne 6\u00a0;</li> <li>ligne 36\u00a0: m\u00e9thode HTTP \u00e0 utiliser\u00a0;</li> <li>ligne 37\u00a0: le serveur renvoie du jSON. On indique le type [text] comme type de r\u00e9sultat afin de l'afficher tel qu'il a \u00e9t\u00e9 re\u00e7u\u00a0;</li> <li>ligne 42\u00a0: affichage de la r\u00e9ponse texte du serveur\u00a0;</li> <li>lignes 48-49\u00a0: affichage du message d'erreur \u00e9ventuel\u00a0;</li> <li>ligne 53\u00a0: la m\u00e9thode [doPost] re\u00e7oit un second param\u00e8tre qui est la valeur \u00e0 poster\u00a0;</li> <li>ligne 61\u00a0: pour indiquer que la valeur post\u00e9e va l'\u00eatre sous la forme d'une cha\u00eene jSON\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#187-execution-du-client","title":"18.7. Ex\u00e9cution du client","text":"<p>L'application cliente est une application Spring Boot lanc\u00e9e par la classe ex\u00e9cutable [Boot] suivante\u00a0:</p> <pre><code>package spring.cors.client.boot;\n\nimport org.springframework.boot.SpringApplication;\n\nimport spring.cors.client.config.WebConfig;\n\npublic class Boot {\n\n    public static void main(String[] args) {\n        SpringApplication.run(WebConfig.class, args);\n    }\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la m\u00e9thode [SpringApplication.run] utilise le fichier de configuration [WebConfig]. La page [client.html] va \u00eatre d\u00e9ploy\u00e9e sur le serveur Tomcat pr\u00e9sent dans le Classpath du projet\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#188-lurl-getallcategories","title":"18.8. L'URL [/getAllCategories]","text":"<p>Nous lan\u00e7ons\u00a0:</p> <ul> <li>le serveur web / json sur le port 8080\u00a0;</li> <li>le client de ce serveur sur le port 8081\u00a0; puis nous demandons l'URL [http://localhost:8081/client.html] [1]\u00a0:</li> </ul> <ul> <li>en [2], nous faisons un GET sur l'URL [http://localhost:8080/getAllCategories]; Nous n'obtenons pas de r\u00e9ponse du serveur. Lorsqu'on regarde la console de d\u00e9veloppement de Chrome (Ctrl-Maj-I) on d\u00e9couvre une erreur\u00a0:</li> </ul> <ul> <li>en [1], on est dans l'onglet [Network]\u00a0;</li> <li>en [2], on voit que la requ\u00eate HTTP qui a \u00e9t\u00e9 faite n'est pas [GET] mais [OPTIONS]. Dans le cas d'une requ\u00eate inter-domaines, le navigateur v\u00e9rifie aupr\u00e8s du serveur qu'un certain nombre de conditions sont v\u00e9rifi\u00e9es en lui envoyant une requ\u00eate HTTP [OPTIONS]. En l'occurrence, les requ\u00eates sont celles point\u00e9es par les pastilles [5-6]\u00a0;</li> <li>en [5], le navigateur demande si l'URL cible peut \u00eatre atteinte avec un GET. L'ent\u00eate de la requ\u00eate [Access-Control-Request-Method] demande une r\u00e9ponse avec un ent\u00eate HTTP [Access-Control-Allow-Methods] indiquant que la m\u00e9thode demand\u00e9e est accept\u00e9e\u00a0;</li> <li>en [6], le navigateur envoie l'ent\u00eate HTTP [Origin: http://localhost:8081]. Cet ent\u00eate demande une r\u00e9ponse dans un ent\u00eate HTTP [Access-Control-Allow-Origin] indiquant que l'origine indiqu\u00e9e est accept\u00e9e\u00a0;</li> <li>en [7],  le navigateur demande si les ent\u00eates HTTP [accept] et [authorization] sont accept\u00e9s. L'ent\u00eate de la requ\u00eate [Access-Control-Request-Headers] attend une r\u00e9ponse avec un ent\u00eate HTTP [Access-Control-Allow-Headers] indiquant que les ent\u00eates demand\u00e9s sont accept\u00e9s\u00a0;</li> <li>on a une erreur en [3]. En cliquant sur l'ic\u00f4ne, on a l'erreur [4]\u00a0;</li> <li>en [4], le message indique que le serveur n'a pas envoy\u00e9 l'ent\u00eate HTTP [Access-Control-Allow-Origin] qui indique si l'origine de la requ\u00eate est accept\u00e9e\u00a0;</li> <li>en [8], on peut constater que le serveur n'a effectivement pas envoy\u00e9 cet ent\u00eate. Du coup le navigateur a refus\u00e9 de faire la requ\u00eate HTTP GET demand\u00e9e initialement\u00a0; Il nous faut modifier le serveur web / jSON.</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#189-le-nouveau-service-web-json","title":"18.9. Le nouveau service web / json","text":"<p>Nous cr\u00e9ons un nouveau projet Maven [intro-spring-cors-server-jpa]\u00a0:</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1891-configuration-maven","title":"18.9.1. Configuration Maven","text":"<p>La configuration Maven du nouveau service web est la suivante\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.cors&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cors-server-jpa&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;name&gt;spring-cors-server-jpa&lt;/name&gt;\n    &lt;description&gt;d\u00e9mo spring cors&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.spring.security&lt;/groupId&gt;\n            &lt;artifactId&gt;intro-spring-security-server-01&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 23-27\u00a0: nous r\u00e9cup\u00e9rons tout l'acquis du travail fait jusqu'\u00e0 maintenant en nous appuyant sur l'archive du serveur web / json s\u00e9curis\u00e9\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1892-configuration-spring","title":"18.9.2. Configuration Spring","text":"<p>La classe de configuration [AppConfig] est la suivante\u00a0:</p> <pre><code>package spring.cors.server.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\nimport spring.security.config.SecurityConfig;\n\n@Configuration\n@ComponentScan(basePackages = { \"spring.cors.server.service\" })\n@Import({ SecurityConfig.class })\npublic class AppConfig {\n\n    // requ\u00eates inter-domaines\n    @Bean\n    public boolean isCorsEnabled() {\n        return true;\n    }\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la classe est une classe de configuration Spring\u00a0;</li> <li>ligne 11\u00a0: d'autres composants Spring sont \u00e0 chercher dans le paquetage [spring.cors.server.service]\u00a0;</li> <li>lignes 16-19\u00a0: nous cr\u00e9ons un composant Spring nomm\u00e9 [isCorsEnabled] qui indique si on accepte ou non les clients \u00e9trangers au domaine du serveur\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1893-la-classe-abstractcorscontroller","title":"18.9.3. La classe [AbstractCorsController]","text":"<p>La classe [AbstractCorsController] qui sera la classe parente de tous les contr\u00f4leurs de cette application\u00a0:</p> <p>Son code est le suivant\u00a0:</p> <pre><code>package spring.cors.server.service;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic abstract class AbstractCorsController {\n\n    @Autowired\n    private boolean isCorsEnabled;\n\n    // envoi des options au client\n    public void setHeaders(String origin, HttpServletResponse response) {\n        // Cors allowed ?\n        if (!isCorsEnabled || origin == null || !origin.startsWith(\"http://localhost\")) {\n            return;\n        }\n        // on fixe le header CORS\n        response.addHeader(\"Access-Control-Allow-Origin\", origin);\n        // on autorise certains headers\n        response.addHeader(\"Access-Control-Allow-Headers\", \"accept, authorization\");\n        // on autorise le GET\n        response.addHeader(\"Access-Control-Allow-Methods\", \"GET\");\n    }\n}\n</code></pre> <ul> <li>ligne 7\u00a0: la classe [CorsController] est abstraite car elle est con\u00e7ue pour \u00eatre \u00e9tendue et non instanci\u00e9e\u00a0;</li> <li>lignes 13-24\u00a0: la m\u00e9thode [setHeaders] met dans la r\u00e9ponse [HttpServletResponse response] (ligne 13) faite au client, les ent\u00eates HTTP r\u00e9clam\u00e9s par les requ\u00eates inter-domaines\u00a0;</li> <li>ligne 33\u00a0: la m\u00e9thode [/setHeaders] admet pour param\u00e8tres\u00a0:</li> <li>la cha\u00eene [origin] pr\u00e9sent dans l'ent\u00eate HTTP [Origin] des requ\u00eates inter-domaines\u00a0: <pre><code>Origin:http://localhost:8081\n</code></pre></li> </ul> <p>Ici le param\u00e8tre [origin] de la ligne 13 aurait la valeur [http://localhost:8081]. Au cas, o\u00f9 la demande ne contient pas l'ent\u00eate HTTP [Origin], on s'arrangera pour avoir [origin==null]\u00a0;</p> <ul> <li> <p>l'objet [HttpServletResponse response] qui va \u00eatre renvoy\u00e9 au client qui a fait la demande\u00a0; Ces deux param\u00e8tres sont inject\u00e9s par Spring\u00a0;</p> </li> <li> <p>lignes 15-175\u00a0: si l'application est configur\u00e9e pour accepter les requ\u00eates inter-domaines et si l'\u00e9metteur a envoy\u00e9 l'ent\u00eate HTTP [Origin] et si cette origine commence par [http://localhost], alors on va accepter la requ\u00eate inter-domaines, sinon on la rejette\u00a0;</p> </li> <li>ligne 19\u00a0: si le client est dans le domaine [http://localhost:port], on envoie l'ent\u00eate HTTP\u00a0: <pre><code>Access-Control-Allow-Origin:  http://localhost:port\n</code></pre></li> </ul> <p>qui signifie que le serveur accepte l'origine du client\u00a0;</p> <ul> <li>ligne 21\u00a0: nous avons signal\u00e9 deux ent\u00eates HTTP particuliers dans la requ\u00eate HTTP [OPTIONS]\u00a0: <pre><code>Access-Control-Request-Method: GET\nAccess-Control-Request-Headers: accept, authorization\n</code></pre></li> </ul> <p>A l'ent\u00eate HTTP [Access-Control-Request-X], le serveur r\u00e9pond avec un ent\u00eate HTTP [Access-Control-Allow-X] dans lequel il indique ce qui est autoris\u00e9. Les lignes 20-23 se contentent de reprendre la demande du client pour indiquer qu'elle est accept\u00e9e\u00a0;</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1894-le-controleur-mycontrollerwithhttpoptions","title":"18.9.4. Le contr\u00f4leur [MyControllerWithHttpOptions]","text":"<p>Afin de ne pas avoir \u00e0 modifier le serveur web / jSON non s\u00e9curis\u00e9 [intro-server-webjson-01] \u00e9tudi\u00e9 au paragraphe 13.5.3, page 230 nous allons cr\u00e9er un nouveau contr\u00f4leur qui l\u00e0 o\u00f9 le serveur non s\u00e9curis\u00e9 traite l'URL [/url], le nouveau contr\u00f4leur traitera l'URL [/cors-url] et cette URL acceptera les requ\u00eates inter-domaines.</p> <p>La classe [MyControllerWithHttpOptions] est le contr\u00f4leur qui va traiter les requ\u00eates HTTP de type [OPTIONS]\u00a0:</p> <pre><code>package spring.cors.server.service;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\n@Controller\npublic class MyControllerWithHttpOptions extends AbstractCorsController {\n\n    @RequestMapping(value = \"/cors-getAllCategories\", method = RequestMethod.OPTIONS)\n    public void getAllCategories(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse httpServletResponse){\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n    }\n...\n</code></pre> <ul> <li>ligne 14\u00a0: la classe est un contr\u00f4leur Spring MVC\u00a0;</li> <li>ligne 15\u00a0: la classe [MyControllerWithHttpOptions] \u00e9tend la classe [AbstractCorsController] que nous venons de d\u00e9crire\u00a0;</li> <li>lignes 17-18\u00a0: la m\u00e9thode [getAllCategories] (ligne 18) traite l'URL [\"/cors-getAllCategories\"] lorsqu'elle est demand\u00e9e avec la m\u00e9thode HTTP [OPTIONS]\u00a0;</li> <li>ligne 18\u00a0: la m\u00e9thode [getAllCategories] admet deux param\u00e8tres\u00a0:</li> <li>[@RequestHeader(value = \"Origin\", required = false) String origin] pour r\u00e9cup\u00e9rer la valeur de l'ent\u00eate HTTP [Origin:http://localhost:8081] lorsqu'il est pr\u00e9sent. Dans cet exemple, le param\u00e8tre [String origin] recevra la valeur [http://localhost:8081]. Cet ent\u00eate n'est pas obligatoire [required = false]. Lorsqu'il n'est pas pr\u00e9sent, le param\u00e8tre [String origin] aura la valeur null\u00a0;</li> <li>[HttpServletResponse httpServletResponse]\u00a0: la r\u00e9ponse qui sera envoy\u00e9e au client\u00a0;</li> <li>ligne 21\u00a0: on envoie les ent\u00eates HTTP qui permettent les requ\u00eates inter-domaines. La m\u00e9thode [setHeaders] est d\u00e9finie dans la classe parent [AbstractCorsController]\u00a0; Il est fait ainsi pour toutes les URL expos\u00e9es par le serveur web / jSON non s\u00e9curis\u00e9 [intro-server-webjson-01] \u00e9tudi\u00e9 au paragraphe 13.5.3, page 230. Lorsque ce service expose l'URL [/url], la classe [MyControllerWithHttpOptions] ci-dessus expose l'URL [/cors-url].</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1895-le-controleur-mycontrollerwithcors","title":"18.9.5. Le contr\u00f4leur [MyControllerWithCors]","text":"<p>La classe [MyControllerWithCors] est le contr\u00f4leur qui va traiter les requ\u00eates HTTP de type [GET] et [POST]\u00a0:</p> <pre><code>package spring.cors.server.service;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\nimport spring.webjson.service.MyController;\n\n@Controller\npublic class MyControllerWithCors extends AbstractCorsController {\n\n    // d\u00e9pendances Spring\n    @Autowired\n    private MyController myController;\n\n...\n    @RequestMapping(value = \"/cors-getAllCategories\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String getAllCategories(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse httpServletResponse) throws JsonProcessingException {\n        // r\u00e9ponse\n        return myController.getAllCategories();\n    }\n...\n</code></pre> <ul> <li>ligne 17\u00a0: la classe [MyControllerWithCors] est un contr\u00f4leur Spring MVC</li> <li>ligne 18\u00a0: elle \u00e9tend la classe [AbstractCorsController]\u00a0;</li> <li>lignes 21-22\u00a0: injection du contr\u00f4leur [MyController] du serveur web / jSON non s\u00e9curis\u00e9 [intro-server-webjson-01] \u00e9tudi\u00e9 au paragraphe 13.5.3, page 230\u00a0;</li> <li>lignes 25-27\u00a0: la m\u00e9thode [getAllCategories] traite l'URL [/cors-getAllCategories] (ligne 28) lorsqu'elle demand\u00e9e avec la m\u00e9thode HTTP [GET]\u00a0;</li> <li>ligne 26\u00a0: le r\u00e9sultat de la m\u00e9thode [getAllCategories] sera envoy\u00e9 au client. Ce r\u00e9sultat est un flux jSON (attribut [produces] de la ligne 27 et type [String] du r\u00e9sultat ligne 25)\u00a0;</li> <li>ligne 27\u00a0: la m\u00e9thode re\u00e7oit les m\u00eames param\u00e8tres que la m\u00e9thode [getAllCategories] du contr\u00f4leur [MyControllerWithHttpOptions] que nous venons d'\u00e9tudier\u00a0;</li> <li>ligne 30\u00a0: on demande \u00e0 la m\u00e9thode [myController.getAllCategories()] d'envoyer la r\u00e9ponse\u00a0; Au final, c'est la m\u00e9thode [myController.getAllCategories()] du serveur non s\u00e9curis\u00e9 qui envoie la r\u00e9ponse. On a simplement enrichi sa r\u00e9ponse avec les ent\u00eates n\u00e9cessaires aux requ\u00eates inter-domaines.</li> </ul> <p>Il est fait ainsi pour toutes les URL expos\u00e9es par le serveur web / jSON non s\u00e9curis\u00e9 [intro-server-webjson-01] \u00e9tudi\u00e9 au paragraphe 13.5.3, page 230. Lorsque ce service expose l'URL [/url], la classe [MyControllerWithCors] ci-dessus expose l'URL [/cors-url].</p> <p>Une requ\u00eate inter-domaine se d\u00e9roulera de la fa\u00e7on suivante\u00a0:</p> <ul> <li>le code JS du client demande l'URL [/cors-url] avec une requ\u00eate HTTP GET ou un POST\u00a0;</li> <li>le navigateur qui ex\u00e9cute ce code intercepte cette demande et demande d'abord l'URL [/cors-url] avec une requ\u00eate HTTP OPTIONS pour v\u00e9rifier que le service web cible accepte les requ\u00eates inter-domaines\u00a0;</li> <li>l'une des m\u00e9thodes du contr\u00f4leur [MyControllerWithHttpOptions] envoie les ent\u00eates inter-domaines attendus par le navigateur\u00a0;</li> <li>le navigateur demande alors l'URL initiale [/cors-url] avec une requ\u00eate HTTP GET ou un POST\u00a0;</li> <li>l'une des m\u00e9thodes du contr\u00f4leur [MyControllerWithCors] lui r\u00e9pond alors\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1896-tests","title":"18.9.6. Tests","text":"<p>La classe de boot du projet [intro-spring-cors-server-jpa] est la suivante\u00a0:</p> <pre><code>package spring.cors.server.boot;\n\nimport org.springframework.boot.SpringApplication;\n\nimport spring.cors.server.config.AppConfig;\n\npublic class Boot {\n\n    public static void main(String[] args) {\n        SpringApplication.run(AppConfig.class, args);\n    }\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la m\u00e9thode statique [SpringApplication.run] est ex\u00e9cut\u00e9e avec la configuration Spring [AppConfig]. A cause de cette configuration, le serveur Tomcat embarqu\u00e9 dans les archives du projet est ex\u00e9cut\u00e9 et l'application web [intro-spring-cors-server-jpa] est d\u00e9ploy\u00e9e dessus. L'application web du serveur non s\u00e9curis\u00e9 [intro-server-webjson-01] qui fait partie des archives du projet est \u00e9galement d\u00e9ploy\u00e9e dessus. Comme le projet [intro-spring-security-server-01] fait \u00e9galement partie des archives, deux types d'URL sont finalement expos\u00e9es\u00a0:</li> <li>celles du service web s\u00e9curis\u00e9\u00a0: /url\u00a0;</li> <li>celles du service web acceptant les requ\u00eates inter-domaines\u00a0: /cors-url\u00a0; Nous sommes d\u00e9sormais pr\u00eats pour de nouveaux tests. Nous lan\u00e7ons la nouvelle version du service web et nous d\u00e9couvrons que le probl\u00e8me reste entier. Rien n'a chang\u00e9. Si ligne 7 ci-dessous, on met un affichage console, celui-ci n'est jamais affich\u00e9 montrant par l\u00e0 que la m\u00e9thode [getAllCategories] de la classe [MyControllerWithHttpOptions] n'est jamais appel\u00e9e\u00a0;</li> </ul> <pre><code>@Controller\npublic class MyControllerWithHttpOptions extends AbstractCorsController {\n\n    @RequestMapping(value = \"/cors-getAllCategories\", method = RequestMethod.OPTIONS)\n    public void getAllCategories(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse httpServletResponse){\n        System.out.println(un_texte)\u00a0;\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n    }\n</code></pre> <p>Apr\u00e8s quelques recherches, on d\u00e9couvre que par d\u00e9faut Spring MVC traite lui-m\u00eame les commandes HTTP [OPTIONS]. Aussi c'est toujours Spring qui r\u00e9pond et jamais la m\u00e9thode [getAllCategories] de la ligne 5 ci-dessus. Ce comportement par d\u00e9faut de Spring MVC peut \u00eatre chang\u00e9. Nous modifions la classe  [AppConfig] existante\u00a0:</p> <pre><code>package spring.cors.server.config;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.web.servlet.DispatcherServlet;\n\nimport spring.security.config.SecurityConfig;\n\n@Configuration\n@ComponentScan(basePackages = { \"spring.cors.server.service\" })\n@Import({ SecurityConfig.class })\npublic class AppConfig {\n\n    // requ\u00eates inter-domaines\n    @Bean\n    public boolean isCorsEnabled() {\n        return true;\n    }\n\n    @Autowired\n    private DispatcherServlet dispatcherServlet;\n\n    @PostConstruct\n    public void init() {\n        // l'application traite elle-m\u00eame les demandes HTTP [OPTIONS]\n        dispatcherServlet.setDispatchOptionsRequest(true);\n    }\n}\n</code></pre> <ul> <li>lignes 25-26\u00a0: injection du bean [dispatcherServlet] qui g\u00e8re les demandes des clients. Ce bean a \u00e9t\u00e9 d\u00e9fini dans la configuration du serveur web / jSON non s\u00e9curis\u00e9 [intro-server-webjson-01] \u00e9tudi\u00e9 au paragraphe 13.5.3, page 230\u00a0;</li> <li>lignes 28-29\u00a0: la m\u00e9thode [init] (ligne 29) sera ex\u00e9cut\u00e9e d\u00e8s que la classe [AppConfig] aura \u00e9t\u00e9 instanci\u00e9e et les injections Spring faites. Donc lorsqu'elle s'ex\u00e9cute, le champ de la ligne 26 a \u00e9t\u00e9 initialis\u00e9\u00a0;</li> <li>ligne 31\u00a0: on configure le bean [dispatcherServlet] pour qu'il laisse l'application web traiter elle-m\u00eame les commandes HTTP [OPTIONS]\u00a0; Nous refaisons les tests avec cette nouvelle configuration. On obtient le r\u00e9sultat suivant\u00a0:</li> </ul> <ul> <li>en [1], nous voyons qu'il y a deux requ\u00eates HTTP vers l'URL [http://localhost:8080/cors-getAllCategories];</li> <li>en [2], la requ\u00eate [OPTIONS]\u00a0;</li> <li>en [3], les trois ent\u00eates HTTP que nous venons de configurer dans la r\u00e9ponse du serveur\u00a0; Examinons maintenant la seconde requ\u00eate\u00a0:</li> </ul> <ul> <li>en [1], la requ\u00eate examin\u00e9e\u00a0;</li> <li>en [2], c'est la requ\u00eate GET. Gr\u00e2ce \u00e0 la premi\u00e8re requ\u00eate [OPTIONS], le navigateur a re\u00e7u les informations qu'il demandait. Il r\u00e9alise maintenant la requ\u00eate [GET] demand\u00e9e initialement\u00a0;</li> <li>en [3], la r\u00e9ponse du serveur\u00a0;</li> <li>en [4], le serveur envoie du jSON\u00a0;</li> <li>en [5], une erreur s'est produite\u00a0;</li> <li>en [6], le message d'erreur\u00a0; Il est plus difficile d'expliquer ce qui s'est pass\u00e9 ici. La r\u00e9ponse [3] du serveur est normale [HTTP/1.1 200 OK]. On devrait donc avoir le document demand\u00e9. Il est possible que le serveur ait bien envoy\u00e9 le document mais que c'est le navigateur qui emp\u00eache son utilisation parce qu'il veut que pour la requ\u00eate GET \u00e9galement, la r\u00e9ponse comporte l'ent\u00eate HTTP [Access-Control-Allow-Origin:http://localhost:8081].</li> </ul> <p>Nous modifions alors le contr\u00f4leur [MyControllerWithCors] pour que lui aussi envoie les ent\u00eates n\u00e9cessaires aux requ\u00eates inter-domaines\u00a0:</p> <pre><code>    @RequestMapping(value = \"/cors-getAllCategories\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String getAllCategories(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse httpServletResponse) throws JsonProcessingException {\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n        // r\u00e9ponse\n        return myController.getAllCategories();\n}\n</code></pre> <ul> <li>ligne 6\u00a0:  les ent\u00eates n\u00e9cessaires aux requ\u00eates inter-domaines sont inclus dans la r\u00e9ponse\u00a0; Apr\u00e8s cette modification, les r\u00e9sultats sont les suivants\u00a0:</li> </ul> <p>Nous avons bien obtenu la liste des cat\u00e9gories.</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1810-les-autres-url-get","title":"18.10. Les autres URL [GET]","text":"<p>Dans les contr\u00f4leurs [MyControllerWithCors, MyControllerWithHttpOptions], le code des actions qui traitent les URL demand\u00e9es avec un [GET] suit le mod\u00e8le des actions qui ont trait\u00e9 pr\u00e9c\u00e9demment l'URL [/cors-getAllCategories]. Le lecteur peut v\u00e9rifier le code dans les exemples livr\u00e9s avec ce document. Voici un exemple pour l'URL [/cors-getAllProduits]\u00a0:</p> <p>dans [MyControllerWithHttpOptions]</p> <pre><code>    @RequestMapping(value = \"/cors-getAllProduits\", method = RequestMethod.OPTIONS)\n    public void getAllProduits(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse httpServletResponse) {\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n}\n</code></pre> <p>dans [MyControllerWithCors]</p> <pre><code>    @RequestMapping(value = \"/cors-getAllProduits\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String getAllProduits(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse httpServletResponse) throws JsonProcessingException {\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n        // r\u00e9ponse\n        return myController.getAllProduits();\n}\n</code></pre>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1811-les-url-post","title":"18.11. Les URL [POST]","text":"<p>Examinons le cas suivant\u00a0:</p> <ul> <li>on fait un POST [1] vers l'URL [2]\u00a0;</li> <li>en [3], la valeur post\u00e9e. Il s'agit d'une cha\u00eene jSON\u00a0;</li> <li>au total, on cherche \u00e0 cr\u00e9er une cat\u00e9gorie appel\u00e9e [categorie2]\u00a0; Nous ne modifions pour l'instant aucun code. Le r\u00e9sultat obtenu est le suivant\u00a0:</li> </ul> <ul> <li>en [1], comme pour les requ\u00eates [GET], une requ\u00eate [OPTIONS] est faite par le navigateur\u00a0;</li> <li>en [2], il demande une autorisation d'acc\u00e8s pour une requ\u00eate [POST]. Auparavant c'\u00e9tait [GET]\u00a0;</li> <li>en [3], il demande une autorisation d'envoyer les ent\u00eates HTTP [accept, authorization, content-type]. Auparavant, on avait seulement les deux premiers ent\u00eates\u00a0;</li> <li>en [4], le service web ne donne pas toutes les autorisations demand\u00e9es ce qui provoque l'erreur [5]\u00a0; Nous modifions la m\u00e9thode [AbstractController.sendHeaders] de la fa\u00e7on suivante\u00a0:</li> </ul> <pre><code>package spring.cors.server.service;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\n\npublic abstract class AbstractCorsController {\n\n    @Autowired\n    private boolean isCorsEnabled;\n\n    // envoi des options au client\n    public void setHeaders(String origin, HttpServletResponse response) {\n        // Cors allowed ?\n        if (!isCorsEnabled || origin == null || !origin.startsWith(\"http://localhost\")) {\n            return;\n        }\n        // on fixe le header CORS\n        response.addHeader(\"Access-Control-Allow-Origin\", origin);\n        // on autorise certains headers\n        response.addHeader(\"Access-Control-Allow-Headers\", \"accept, authorization, content-type\");\n        // on autorise le GET et le POST\n        response.addHeader(\"Access-Control-Allow-Methods\", \"GET, POST\");\n    }\n}\n</code></pre> <ul> <li>ligne 21\u00a0: on a ajout\u00e9 l'ent\u00eate HTTP [Content-Type] (la casse n'a pas d'importance)\u00a0;</li> <li>ligne 23\u00a0: on a ajout\u00e9 la m\u00e9thode HTTP [POST]\u00a0; Ceci fait les m\u00e9thodes [POST] sont trait\u00e9es de la m\u00eame fa\u00e7on que les requ\u00eates [GET]. Voici l'exemple de l'URL [/cors-addArticles]\u00a0:</li> </ul> <p>dans [MyControllerWithCors]</p> <pre><code>    @RequestMapping(value = \"/cors-addCategories\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\", produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String addCategories(HttpServletRequest request,\n            @RequestHeader(value = \"Origin\", required = false) String origin, HttpServletResponse httpServletResponse)\n                    throws JsonProcessingException {\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n        // r\u00e9ponse\n        return myController.addCategories(request);\n}\n</code></pre> <p>dans [MyControllerWithHttpOptions]</p> <pre><code>    @RequestMapping(value = \"/cors-addCategories\", method = RequestMethod.OPTIONS)\n    public void addCategories(HttpServletRequest request,\n            @RequestHeader(value = \"Origin\", required = false) String origin, HttpServletResponse httpServletResponse)\n                    throws JsonProcessingException {\n        // ent\u00eates CORS\n        setHeaders(origin, httpServletResponse);\n}\n</code></pre> <p>Le r\u00e9sultat obtenu est le suivant\u00a0:</p> <p>La cat\u00e9gorie [categorie2] a bien \u00e9t\u00e9 ajout\u00e9e dans la base de donn\u00e9es. Le SGBD lui a attribu\u00e9 la cl\u00e9 primaire 1729.</p>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1812-le-controleur-authenticatecorscontroller","title":"18.12. Le contr\u00f4leur [AuthenticateCorsController]","text":"<p>Le contr\u00f4leur [AuthenticateCorsController] est l\u00e0 pour fournir l'URL [/cors-authenticate] qui permet d'appeler l'URL [/authenticate] d\u00e9j\u00e0 existante, avec une requ\u00eate inter-domaines. Son code est le suivant\u00a0:</p> <pre><code>package spring.cors.server.service;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\n\nimport spring.security.service.AuthenticateController;\n\n@Controller\npublic class AuthenticateCorsController extends AbstractCorsController {\n    @Autowired\n    private AuthenticateController authenticateController;\n\n    @RequestMapping(value = \"/cors-authenticate\", method = RequestMethod.GET)\n    @ResponseBody\n    public String authenticate(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse response) throws JsonProcessingException {\n        // ent\u00eates CORS\n        setHeaders(origin, response);\n        // m\u00e9thode d'origine\n        return authenticateController.authenticate();\n    }\n\n    @RequestMapping(value = \"/cors-authenticate\", method = RequestMethod.OPTIONS)\n    public void corsAuthenticate(@RequestHeader(value = \"Origin\", required = false) String origin,\n            HttpServletResponse response) {\n        // ent\u00eates CORS\n        setHeaders(origin, response);\n    }\n\n}\n</code></pre> <p>Voici deux exemples\u00a0:</p> <ul> <li> <p>les r\u00e9ponses affich\u00e9es le sont par le code jS suivant\u00a0: <pre><code>function doGet(url) {\n    // on fait un appel Ajax \u00e0 la main\n    $.ajax({\n        headers : {\n            'Authorization':'Basic '+authorizationCode\n        },\n        url : baseUrl + url,\n        type : 'GET',\n        dataType : 'text',\n        beforeSend : function() {\n        },\n        success : function(data) {\n            // r\u00e9sultat texte\n            response.text(data);\n        },\n        complete : function() {\n        },\n        error : function(jqXHR) {\n            // erreur syst\u00e8me\n            response.text(JSON.stringify(jqXHR.statusCode()));\n        }\n    })\n}\n</code></pre></p> </li> <li> <p>la r\u00e9ponse [1] est affich\u00e9e par la ligne 14 de la fonction [success]\u00a0;</p> </li> <li>la r\u00e9ponse [2] est affich\u00e9e par la ligne 20 de la fonction [error]. La fonction [JSON.stringify] cr\u00e9e la cha\u00eene jSON de l'objet [jqXHR.statusCode()] qui est l'objet encapsulant l'erreur qui s'est produite. Cet objet donne peu d'informations. Il est possible d'exploiter d'autres m\u00e9thodes de l'objet [jqXHR] pour avoir, par exemple, les ent\u00eates HTTP renvoy\u00e9s par le serveur\u00a0;</li> </ul>"},{"location":"cours-gestion-des-acces-inter-domaines.html#1813-conclusion","title":"18.13. Conclusion","text":"<p>Notre application supporte d\u00e9sormais les requ\u00eates inter-domaines. Celles-ci peuvent \u00eatre autoris\u00e9es ou non par configuration dans la classe [AppConfig]\u00a0:</p> <pre><code>@ComponentScan(basePackages = { \"spring.cors.server.service\" })\n@Import({ SecurityConfig.class })\npublic class AppConfig {\n\n    // requ\u00eates inter-domaines\n    @Bean\n    public boolean isCorsEnabled() {\n        return true;\n    }\n\n    @Autowired\n    private DispatcherServlet dispatcherServlet;\n\n    @PostConstruct\n    public void init() {\n        // l'application traite elle-m\u00eame les demandes HTTP [OPTIONS]\n        dispatcherServlet.setDispatchOptionsRequest(true);\n    }\n}\n</code></pre>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html","title":"11. [Cours]\u00a0: Gestion des bases de donn\u00e9es relationnelles avec Spring Data","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, API JPA (Java Persistence API), Spring Data.</p> <p>Nous allons impl\u00e9menter la couche [DAO] du TD avec [Spring Data], une branche de l'\u00e9cosyst\u00e8me Spring. [Spring Data] s'appuie sur une couche JPA (Java Persistence API) qui permet \u00e0 la couche [DAO] de manipuler des objets plut\u00f4t que des ordres SQL. Au final, la couche [DAO] ignore qu'elle dialogue avec une base de donn\u00e9es. Elle ne conna\u00eet que l'interface de la couche [Spring Data].</p> <p>Nous allons d'abord d\u00e9couvrir [Spring Data] sur deux exemples.</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#111-support","title":"11.1. Support","text":"<ul> <li>en [1], le dossier [support / chap-11] contient trois projets Eclipse\u00a0;</li> <li>en [2], le script SQL permettant de cr\u00e9er la base de donn\u00e9es exemple de ce chapitre\u00a0;</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#112-exemple-1","title":"11.2. Exemple 1","text":"<p>Sur le site de Spring existent de nombreux tutoriels pour d\u00e9marrer avec Spring [http://spring.io/guides]. Nous allons utiliser l'un d'eux pour introduire Spring Data. Nous utilisons pour cela Spring Tool Suite (STS).</p> <ul> <li>en [1], nous importons l'un des tutoriels de [spring.io/guides]\u00a0;</li> </ul> <ul> <li>en [2], on choisit le tutoriel [Accessing Data Jpa] qui montre comment acc\u00e9der \u00e0 une base de donn\u00e9es avec Spring Data\u00a0;</li> <li>en [3], on choisit un projet configur\u00e9 par Maven\u00a0;</li> <li>en [4], le tutoriel peut \u00eatre d\u00e9livr\u00e9 sous deux formes\u00a0: [initial] qui est une version vide qu'on remplit en suivant le tutoriel ou [complete] qui est la version finale du tutoriel. Nous choisissons cette derni\u00e8re\u00a0;</li> <li>en [5], on peut choisir de visualiser le tutoriel dans un navigateur\u00a0;</li> <li>en [6], le projet final.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1121-la-configuration-maven-du-projet","title":"11.2.1. La configuration Maven du projet","text":"<p>Les d\u00e9pendances Maven du projet sont configur\u00e9es dans le fichier [pom.xml]\u00a0:</p> <pre><code>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-accessing-data-jpa&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.1.10.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;!-- use UTF-8 for everything --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;start-class&gt;hello.Application&lt;/start-class&gt;\n&lt;/properties&gt;\n</code></pre> <ul> <li>lignes 5-9\u00a0: d\u00e9finissent un projet Maven parent. C'est lui qui d\u00e9finit l'essentiel des d\u00e9pendances du projet. Elles peuvent \u00eatre suffisantes, auquel cas on n'en rajoute pas, ou pas, auquel cas on rajoute les d\u00e9pendances manquantes\u00a0;</li> <li>lignes 12-15\u00a0: d\u00e9finissent une d\u00e9pendance sur [spring-boot-starter-data-jpa]. Cet artifact contient les classes de Spring Data\u00a0;</li> <li>lignes 16-19\u00a0: d\u00e9finissent une d\u00e9pendance sur le SGBD H2 qui permet de cr\u00e9er et g\u00e9rer des bases de donn\u00e9es en m\u00e9moire. Regardons les classes amen\u00e9es par ces d\u00e9pendances\u00a0:</li> </ul> <p>Elles sont tr\u00e8s nombreuses\u00a0:</p> <ul> <li>certaines appartiennent \u00e0 l'\u00e9cosyst\u00e8me Spring (celles commen\u00e7ant par spring)\u00a0;</li> <li>d'autres appartiennent \u00e0 l'\u00e9cosyst\u00e8me Hibernate (hibernate, jboss) dont on utilise ici l'impl\u00e9mentation JPA\u00a0;</li> <li>d'autres sont des biblioth\u00e8ques de tests (junit, hamcrest)\u00a0;</li> <li>d'autres des biblioth\u00e8ques de logs (log4j, logback, slf4j)\u00a0; Nous allons les garder toutes. Pour une application en production, il faudrait ne garder que celles qui sont n\u00e9cessaires.</li> </ul> <p>Ligne 26 du fichier [pom.xml] on trouve la ligne\u00a0:</p> <pre><code>&lt;start-class&gt;hello.Application&lt;/start-class&gt;\n</code></pre> <p>Cette ligne est li\u00e9e aux lignes suivantes\u00a0:</p> <pre><code>&lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt; \n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n</code></pre> <p>Lignes 6-9, le plugin [spring-boot-maven-plugin] permet de g\u00e9n\u00e9rer le jar ex\u00e9cutable de l'application. La ligne 26 du fichier [pom.xml] d\u00e9signe alors la classe ex\u00e9cutable de ce jar.</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1122-la-couche-jpa","title":"11.2.2. La couche [JPA]","text":"<p>L'acc\u00e8s \u00e0 la base de donn\u00e9es se fait au travers d'une couche [JPA], Java Persistence API\u00a0:</p> <p>L'application est basique et g\u00e8re des clients [Customer]. La classe [Customer] fait partie de la couche [JPA] et est la suivante\u00a0:</p> <pre><code>package hello;\n\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\n@Entity\npublic class Customer {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private long id;\n    private String firstName;\n    private String lastName;\n\n    protected Customer() {\n    }\n\n    public Customer(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Customer[id=%d, firstName='%s', lastName='%s']\", id, firstName, lastName);\n    }\n\n}\n</code></pre> <p>Un client a un identifiant [id], un pr\u00e9nom [firstName] et un nom [lastName]. Chaque instance [Customer] repr\u00e9sente une ligne d'une table de la base de donn\u00e9es.</p> <ul> <li>ligne 8\u00a0: annotation JPA qui fait que la persistence des instances [Customer] (Create, Read, Update, Delete) va \u00eatre g\u00e9r\u00e9e par une impl\u00e9mentation JPA. D'apr\u00e8s les d\u00e9pendances Maven, on voit que c'est l'impl\u00e9mentation JPA / Hibernate qui est utilis\u00e9e\u00a0;</li> <li> <p>lignes 11-12\u00a0: annotations JPA qui associent le champ [id] \u00e0 la cl\u00e9 primaire de la table des [Customer]. La ligne 12, indique que l'impl\u00e9mentation JPA utilisera la m\u00e9thode de g\u00e9n\u00e9ration de cl\u00e9 primaire propre au SGBD utilis\u00e9, ici H2\u00a0; Il n'y a pas d'autres annotations JPA. Des valeurs par d\u00e9faut seront alors utilis\u00e9es\u00a0:</p> </li> <li> <p>la table des [Customer] portera le nom de la classe, \u00e7-\u00e0-d [Customer]\u00a0;</p> </li> <li>les colonnes de cette table porteront le nom des champs de la classe\u00a0: [id, firstName, lastName] sachant que la casse n'est pas prise en compte dans le nom d'une colonne de table\u00a0;  On notera qu'\u00e0 aucun moment, l'impl\u00e9mentation JPA utilis\u00e9e n'est nomm\u00e9e.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1123-la-couche-spring-data","title":"11.2.3. La couche [Spring Data]","text":"<p>La classe [CustomerRepository] impl\u00e9mente la couche d'acc\u00e8s \u00e0 la table [Customer]. Son code est le suivant\u00a0:</p> <pre><code>package hello;\n\nimport java.util.List;\n\nimport org.springframework.data.repository.CrudRepository;\n\npublic interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; {\n\n    List&lt;Customer&gt; findByLastName(String lastName);\n}\n</code></pre> <p>C'est donc une interface et non une classe (ligne 7). Elle \u00e9tend l'interface [CrudRepository], une interface de Spring Data (ligne 5). Cette interface est param\u00e9tr\u00e9e par deux types\u00a0: le premier est le type des \u00e9l\u00e9ments g\u00e9r\u00e9s, ici le type [Customer], le second le type de la cl\u00e9 primaire des \u00e9l\u00e9ments g\u00e9r\u00e9s, ici un type [Long]. L'interface [CrudRepository] est la suivante\u00a0:</p> <pre><code>package org.springframework.data.repository;\n\nimport java.io.Serializable;\n\n@NoRepositoryBean\npublic interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {\n\n    &lt;S extends T&gt; S save(S entity);\n\n    &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; entities);\n\n    T findOne(ID id);\n\n    boolean exists(ID id);\n\n    Iterable&lt;T&gt; findAll();\n\n    Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; ids);\n\n    long count();\n\n    void delete(ID id);\n\n    void delete(T entity);\n\n    void delete(Iterable&lt;? extends T&gt; entities);\n\n    void deleteAll();\n}\n</code></pre> <p>Cette interface d\u00e9finit les op\u00e9rations CRUD (Create \u2013 Read \u2013 Update \u2013 Delete) qu'on peut faire sur un type JPA T\u00a0:</p> <ul> <li>ligne 8\u00a0: la m\u00e9thode save permet de persister une entit\u00e9 T en base. Elle rend l'entit\u00e9 persist\u00e9e avec la cl\u00e9 primaire que lui a donn\u00e9e le SGBD. Elle permet \u00e9galement de mettre \u00e0 jour une entit\u00e9 T identifi\u00e9e par sa cl\u00e9 primaire id. Le choix de l'une ou l'autre action se fait selon la valeur de la cl\u00e9 primaire id\u00a0: si celle-ci vaut null c'est l'op\u00e9ration de persistence qui a lieu, sinon c'est l'op\u00e9ration de mise \u00e0 jour\u00a0;</li> <li>ligne 10\u00a0: idem mais pour une liste d'entit\u00e9s\u00a0;</li> <li>ligne 12\u00a0: la m\u00e9thode findOne permet de retrouver une entit\u00e9 T identifi\u00e9e par sa cl\u00e9 primaire id\u00a0;</li> <li>ligne 22\u00a0: la m\u00e9thode delete permet de supprimer une entit\u00e9 T identifi\u00e9e par sa cl\u00e9 primaire id\u00a0;</li> <li>lignes 24-28\u00a0: des variantes de la m\u00e9thode [delete]\u00a0;</li> <li>ligne 16\u00a0: la m\u00e9thode [findAll] permet de retrouver toutes les entit\u00e9s persist\u00e9es T\u00a0;</li> <li>ligne 18\u00a0: idem mais limit\u00e9es aux entit\u00e9s dont on a pass\u00e9 la liste des identifiants\u00a0; Revenons \u00e0 l'interface [CustomerRepository]\u00a0:</li> </ul> <pre><code>package hello;\n\nimport java.util.List;\n\nimport org.springframework.data.repository.CrudRepository;\n\npublic interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; {\n\n    List&lt;Customer&gt; findByLastName(String lastName);\n}\n</code></pre> <ul> <li>la ligne 9 permet de retrouver un [Customer] par son nom [lastName]\u00a0; Et c'est tout pour la couche [DAO]. Il n'y a pas de classe d'impl\u00e9mentation de l'interface pr\u00e9c\u00e9dente. Celle-ci est g\u00e9n\u00e9r\u00e9e \u00e0 l'ex\u00e9cution par [Spring Data]. Les m\u00e9thodes de l'interface [CrudRepository] sont automatiquement impl\u00e9ment\u00e9es. Pour les m\u00e9thodes rajout\u00e9es dans l'interface [CustomerRepository], \u00e7a d\u00e9pend. Revenons \u00e0 la d\u00e9finition de [Customer]\u00a0:</li> </ul> <pre><code>private long id;\nprivate String firstName;\nprivate String lastName;\n</code></pre> <p>La m\u00e9thode de la ligne 9 est impl\u00e9ment\u00e9e automatiquement par [Spring Data] parce qu'elle r\u00e9f\u00e9rence le champ [lastName] (ligne 3) de [Customer]. Lorsqu'il rencontre une m\u00e9thode [findBySomething] dans l'interface \u00e0 impl\u00e9menter, Spring Data l'impl\u00e9mente par la requ\u00eate JPQL (Java Persistence Query Language) suivante\u00a0:</p> <pre><code>select t from T t where t.something=:value\n</code></pre> <p>Il faut donc que le type T ait un champ nomm\u00e9 [something]. Ainsi la m\u00e9thode</p> <pre><code>List&lt;Customer&gt; findByLastName(String lastName);\n</code></pre> <p>va \u00eatre impl\u00e9ment\u00e9e par un code ressemblant au suivant\u00a0:</p> <pre><code>return [em].createQuery(\"select c from Customer c where  c.lastName=:value\").setParameter(\"value\",lastName).getResultList()\n</code></pre> <p>o\u00f9 [em] d\u00e9signe le contexte de persistance JPA. Cela n'est possible que si la classe [Customer] a un champ nomm\u00e9 [lastName], ce qui est le cas.</p> <p>En conclusion, dans les cas simples, Spring Data nous permet d'impl\u00e9menter la couche [DAO] avec une simple interface.</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1124-la-couche-console","title":"11.2.4. La couche [console]","text":"<p>La classe [Application] est la suivante\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application implements CommandLineRunner {\n\n    @Autowired\n    CustomerRepository repository;\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class);\n    }\n\n    @Override\n    public void run(String... strings) throws Exception {\n        // save a couple of customers\n        repository.save(new Customer(\"Jack\", \"Bauer\"));\n        repository.save(new Customer(\"Chloe\", \"O'Brian\"));\n        repository.save(new Customer(\"Kim\", \"Bauer\"));\n        repository.save(new Customer(\"David\", \"Palmer\"));\n        repository.save(new Customer(\"Michelle\", \"Dessler\"));\n\n        // fetch all customers\n        System.out.println(\"Customers found with findAll():\");\n        System.out.println(\"-------------------------------\");\n        for (Customer customer : repository.findAll()) {\n            System.out.println(customer);\n        }\n        System.out.println();\n\n        // fetch an individual customer by ID\n        Customer customer = repository.findOne(1L);\n        System.out.println(\"Customer found with findOne(1L):\");\n        System.out.println(\"--------------------------------\");\n        System.out.println(customer);\n        System.out.println();\n\n        // fetch customers by last name\n        System.out.println(\"Customer found with findByLastName('Bauer'):\");\n        System.out.println(\"--------------------------------------------\");\n        for (Customer bauer : repository.findByLastName(\"Bauer\")) {\n            System.out.println(bauer);\n        }\n    }\n\n}\n</code></pre> <ul> <li>ligne 9\u00a0: la classe impl\u00e9mente l'interface [CommandLineRunner] qui est une interface [Spring Boot] (ligne 4). Cette interfae n'a qu'une m\u00e9thode, celle de la ligne 19\u00a0;</li> <li>ligne 8\u00a0: @SpringBootApplication est une annotation regroupant plusieurs annotations [Spring Boot]\u00a0:</li> <li>@Configuration\u00a0: indique que la classe est une classe de configuration\u00a0;</li> <li>@EnableAutoConfiguration\u00a0: demande \u00e0 [Spring Boot] de cr\u00e9er lui-m\u00eame un certain nombre de beans en fonction de diverses propri\u00e9t\u00e9s, en particulier le contenu du Classpath du projet. Parce que les biblioth\u00e8ques Hibernate sont dans le Classpath, le bean [entityManagerFactory] sera impl\u00e9ment\u00e9 avec Hibernate. Parce que la biblioth\u00e8que du SGBD H2 est dans le Classpath, le bean [dataSource] sera impl\u00e9ment\u00e9 avec H2. Dans le bean [dataSource], on doit d\u00e9finir \u00e9galement l'utilisateur et son mot de passe. Ici Spring Boot utilisera l'administrateur par d\u00e9faut de H2, sa sans mot de passe. Parce que la biblioth\u00e8que [spring-tx] est dans le Classpath, c'est le gestionnaire de transactions de Spring qui sera utilis\u00e9\u00a0;</li> <li>@EnableWebMvc\u00a0: si dans le Classpath se trouve la biblioth\u00e8que [spring-mvc]. Dans ce cas, une auto-configuration est faite pour l'application web\u00a0;</li> <li>@ComponentScan\u00a0: qui dit \u00e0 Spring o\u00f9 chercher les autres beans, configurations et services. Ici ils sont cherch\u00e9s par d\u00e9faut dans le package contenant la classe tagu\u00e9e, \u00e7-\u00e0-d le package [hello]. Ainsi les classes [Customer] et [CustomerRepository] vont-elles \u00eatre trouv\u00e9es. Parce que la premi\u00e8re a l'annotation [@Entity] elle sera catalogu\u00e9e comme entit\u00e9 \u00e0 g\u00e9rer par Hibernate. Parce que la seconde \u00e9tend l'interface [CrudRepository] elle sera enregistr\u00e9e comme bean Spring\u00a0;</li> <li>lignes 11-12\u00a0: le bean [CustomerRepository] est inject\u00e9 dans le code de la classe principale\u00a0;</li> <li>ligne 15\u00a0: la m\u00e9thode statique [run] de la classe [SpringApplication] du projet Spring Boot est ex\u00e9cut\u00e9e. Son param\u00e8tre est la classe qui a une annotation [Configuration] ou [EnableAutoConfiguration]. Tout ce qui a \u00e9t\u00e9 expliqu\u00e9 pr\u00e9c\u00e9demment va alors se d\u00e9rouler. Le r\u00e9sultat est un contexte d'application Spring, \u00e7-\u00e0-d un ensemble de beans g\u00e9r\u00e9s par Spring\u00a0; Les op\u00e9rations qui suivent ne font qu'utiliser les m\u00e9thodes du bean impl\u00e9mentant l'interface [CustomerRepository]. Les r\u00e9sultats console sont les suivants\u00a0:</li> </ul> <pre><code>.   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.2.2.RELEASE)\n\n2015-03-10 15:35:43.661  INFO 5784 --- [           main] hello.Application                        : Starting Application on Gportpers3 with PID 5784 (started by ST in C:\\Users\\Serge Tah\u00e9\\Documents\\workspace-sts-3.6.3.RELEASE\\gs-accessing-data-jpa-complete)\n2015-03-10 15:35:43.708  INFO 5784 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5d11346a: startup date [Tue Mar 10 15:35:43 CET 2015]; root of context hierarchy\n2015-03-10 15:35:45.230  INFO 5784 --- [           main] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit 'default'\n2015-03-10 15:35:45.254  INFO 5784 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [\n    name: default\n    ...]\n2015-03-10 15:35:45.331  INFO 5784 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {4.3.8.Final}\n2015-03-10 15:35:45.332  INFO 5784 --- [           main] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found\n2015-03-10 15:35:45.334  INFO 5784 --- [           main] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist\n2015-03-10 15:35:45.651  INFO 5784 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {4.0.5.Final}\n2015-03-10 15:35:45.754  INFO 5784 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\n2015-03-10 15:35:45.877  INFO 5784 --- [           main] o.h.h.i.ast.ASTQueryTranslatorFactory    : HHH000397: Using ASTQueryTranslatorFactory\n2015-03-10 15:35:46.154  INFO 5784 --- [           main] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export\n2015-03-10 15:35:46.169  INFO 5784 --- [           main] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete\n2015-03-10 15:35:46.779  INFO 5784 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\nCustomers found with findAll():\n-------------------------------\nCustomer[id=1, firstName='Jack', lastName='Bauer']\nCustomer[id=2, firstName='Chloe', lastName='O'Brian']\nCustomer[id=3, firstName='Kim', lastName='Bauer']\nCustomer[id=4, firstName='David', lastName='Palmer']\nCustomer[id=5, firstName='Michelle', lastName='Dessler']\n\nCustomer found with findOne(1L):\n--------------------------------\nCustomer[id=1, firstName='Jack', lastName='Bauer']\n\nCustomer found with findByLastName('Bauer'):\n--------------------------------------------\nCustomer[id=1, firstName='Jack', lastName='Bauer']\nCustomer[id=3, firstName='Kim', lastName='Bauer']\n2015-03-10 15:35:47.040  INFO 5784 --- [           main] hello.Application                        : Started Application in 3.623 seconds (JVM running for 4.324)\n2015-03-10 15:35:47.042  INFO 5784 --- [       Thread-1] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@5d11346a: startup date [Tue Mar 10 15:35:43 CET 2015]; root of context hierarchy\n2015-03-10 15:35:47.044  INFO 5784 --- [       Thread-1] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown\n2015-03-10 15:35:47.046  INFO 5784 --- [       Thread-1] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'\n2015-03-10 15:35:47.047  INFO 5784 --- [       Thread-1] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export\n2015-03-10 15:35:47.051  INFO 5784 --- [       Thread-1] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete\n</code></pre> <ul> <li>lignes 1-8\u00a0: le logo du projet Spring Boot\u00a0;</li> <li>ligne 9\u00a0: la classe [hello.Application] est ex\u00e9cut\u00e9e\u00a0;</li> <li>ligne 10\u00a0: [AnnotationConfigApplicationContext] est une classe impl\u00e9mentant l'interface [ApplicationContext] de Spring. C'est un conteneur de beans\u00a0;</li> <li>ligne 11\u00a0: le bean [entityManagerFactory] est impl\u00e9ment\u00e9 avec la classe [LocalContainerEntityManagerFactory], une classe de Spring\u00a0;</li> <li>ligne 12\u00a0: on voit appara\u00eetre [Hibernate]. C'est cette impl\u00e9mentation JPA qui a \u00e9t\u00e9 choisie\u00a0;</li> <li>ligne 19\u00a0: un dialecte Hibernate est la variante SQL \u00e0 utiliser avec le SGBD. Ici le dialecte [H2Dialect] montre qu'Hibernate va travailler avec le SGBD H2\u00a0;</li> <li>lignes 21-22\u00a0: la base de donn\u00e9es est cr\u00e9\u00e9e. La table [CUSTOMER] est cr\u00e9\u00e9e. Cela signifie qu'Hibernate a \u00e9t\u00e9 configur\u00e9 pour g\u00e9n\u00e9rer les tables \u00e0 partir des d\u00e9finitions JPA, ici la d\u00e9finition JPA de la classe [Customer]\u00a0;</li> <li>lignes 26-30\u00a0: r\u00e9sultat de la m\u00e9thode [findAll] de l'interface\u00a0;</li> <li>ligne 34\u00a0: r\u00e9sultat de la m\u00e9thode [findOne] de l'interface\u00a0;</li> <li>lignes 38-39\u00a0: r\u00e9sultats de la m\u00e9thode [findByLastName]\u00a0;</li> <li>lignes 41 et suivantes\u00a0: logs de la fermeture du contexte Spring.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1125-configuration-manuelle-du-projet-spring-data","title":"11.2.5. Configuration manuelle du projet Spring Data","text":"<p>Nous dupliquons le projet pr\u00e9c\u00e9dent dans le projet [gs-accessing-data-jpa-02]\u00a0:</p> <p>Dans ce nouveau projet, nous n'allons pas nous reposer sur la configuration automatique faite par Spring Boot. Nous allons la faire manuellement. Cela peut \u00eatre utile si les configurations par d\u00e9faut ne nous conviennent pas.</p> <p>Tout d'abord, nous allons expliciter les d\u00e9pendances n\u00e9cessaires dans le fichier [pom.xml]\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-accessing-data-jpa-02&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring Data --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Hibernate --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- H2 Database --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Tomcat JDBC --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;!-- use UTF-8 for everything --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n    &lt;repositories&gt;\n        &lt;repository&gt;\n            &lt;id&gt;spring-releases&lt;/id&gt;\n            &lt;name&gt;Spring Releases&lt;/name&gt;\n            &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;\n        &lt;/repository&gt;\n        &lt;repository&gt;\n            &lt;id&gt;org.jboss.repository.releases&lt;/id&gt;\n            &lt;name&gt;JBoss Maven Release Repository&lt;/name&gt;\n            &lt;url&gt;https://repository.jboss.org/nexus/content/repositories/releases&lt;/url&gt;\n        &lt;/repository&gt;\n    &lt;/repositories&gt;\n\n    &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;spring-releases&lt;/id&gt;\n            &lt;name&gt;Spring Releases&lt;/name&gt;\n            &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;\n        &lt;/pluginRepository&gt;\n    &lt;/pluginRepositories&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 10-14\u00a0: le projet Maven parent dont nous allons utiliser les biblioth\u00e8ques qu'il d\u00e9finit\u00a0;</li> <li>lignes 18-21\u00a0: Spring Data utilis\u00e9 pour acc\u00e9der \u00e0 la base de donn\u00e9es\u00a0;</li> <li>lignes 23-26\u00a0: l'impl\u00e9mentation Hibernate de la sp\u00e9cification JPA\u00a0;</li> <li>lignes 28-31\u00a0: le SGBD H2\u00a0;</li> <li> <p>lignes 33-36\u00a0: les bases de donn\u00e9es sont souvent utilis\u00e9es avec des pools de connexions ouvertes qui \u00e9vitent les ouvertures / fermetures de connexion \u00e0 r\u00e9p\u00e9tition. Ici, l'impl\u00e9mentation utilis\u00e9e est celle de [tomcat-jdbc]\u00a0; Dans le nouveau projet, l'entit\u00e9 [Customer] et l'interface [CustomerRepository] ne changent pas. On va changer la classe [Application] qui va \u00eatre scind\u00e9e en deux classes\u00a0: </p> </li> <li> <p>[Config] qui sera la classe de configuration\u00a0:</p> </li> <li>[Main] qui sera la classe ex\u00e9cutable\u00a0;</li> </ul> <p>La classe ex\u00e9cutable [Application] est d\u00e9sormais la suivante\u00a0:</p> <pre><code>package console;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport repositories.CustomerRepository;\nimport config.AppConfig;\nimport entities.Customer;\n\npublic class Application {\n    public static void main(String[] args) {\n        // instanciation contexte Spring\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n        CustomerRepository repository = context.getBean(CustomerRepository.class);\n\n        // save a couple of customers\n        repository.save(new Customer(\"Jack\", \"Bauer\"));\n        repository.save(new Customer(\"Chloe\", \"O'Brian\"));\n        repository.save(new Customer(\"Kim\", \"Bauer\"));\n        repository.save(new Customer(\"David\", \"Palmer\"));\n        repository.save(new Customer(\"Michelle\", \"Dessler\"));\n\n        ...\n\n        // fermeture contexte\n        context.close();\n    }\n}\n</code></pre> <ul> <li>ligne 9\u00a0: la classe [Application] n'a plus d'annotations de configuration\u00a0;</li> <li>lignes 3-7\u00a0: on notera qu'il n'y a plus d'imports de packages [Spring Boot]\u00a0;</li> <li>ligne 12\u00a0: on instancie les beans Spring. On obtient le contexte de Spring qui contient la r\u00e9f\u00e9rence des beans ainsi cr\u00e9\u00e9s\u00a0;</li> <li>ligne 13\u00a0: on demande une r\u00e9f\u00e9rence sur le bean de type [CustomerRepository]\u00a0; La classe [Config] qui configure le projet est la suivante\u00a0:</li> </ul> <pre><code>package config;\n\nimport javax.persistence.EntityManagerFactory;\n\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.JpaVendorAdapter;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.orm.jpa.vendor.Database;\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\n//@EnableTransactionManagement\n@EnableJpaRepositories(basePackages = { \"repositories\" })\n@Configuration\n// @ComponentScan(basePackages={\"package1\",\"package2\"})\npublic class AppConfig {\n\n    // la base de donn\u00e9es H2\n    @Bean\n    public DataSource dataSource() {\n        // source de donn\u00e9es TomcatJdbc\n        DataSource dataSource = new DataSource();\n        // configuration acc\u00e8s JDBC\n        dataSource.setDriverClassName(\"org.h2.Driver\");\n        dataSource.setUrl(\"jdbc:h2:./demo\");\n        dataSource.setUsername(\"sa\");\n        dataSource.setPassword(\"\");\n        // une connexion ouverte initialement\n        dataSource.setInitialSize(1);\n        // r\u00e9sultat\n        return dataSource;\n    }\n\n    // le provider JPA\n    @Bean\n    public JpaVendorAdapter jpaVendorAdapter() {\n        HibernateJpaVendorAdapter hibernateJpaVendorAdapter = new HibernateJpaVendorAdapter();\n        hibernateJpaVendorAdapter.setShowSql(false);\n        hibernateJpaVendorAdapter.setGenerateDdl(true);\n        hibernateJpaVendorAdapter.setDatabase(Database.H2);\n        return hibernateJpaVendorAdapter;\n    }\n\n    // EntityManagerFactory\n    @Bean\n    public EntityManagerFactory entityManagerFactory(JpaVendorAdapter jpaVendorAdapter, DataSource dataSource) {\n        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();\n        factory.setJpaVendorAdapter(jpaVendorAdapter);\n        factory.setPackagesToScan(\"entities\");\n        factory.setDataSource(dataSource);\n        factory.afterPropertiesSet();\n        return factory.getObject();\n    }\n\n    // Transaction manager\n    @Bean\n    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {\n        JpaTransactionManager txManager = new JpaTransactionManager();\n        txManager.setEntityManagerFactory(entityManagerFactory);\n        return txManager;\n    }\n\n}\n</code></pre> <ul> <li>ligne 17\u00a0: l'annotation [@EnableTransactionManagement] indique que les m\u00e9thodes des interfaces [CrudRepository] doivent se d\u00e9rouler \u00e0 l'int\u00e9rieur d'une transaction. Elle a \u00e9t\u00e9 mise en commentaires car c'est le cas par d\u00e9faut\u00a0;</li> <li>ligne 18\u00a0:  l'annotation [@EnableJpaRepositories] permet de d\u00e9signer les dossiers o\u00f9 se trouvent les interfaces Spring Data [CrudRepository]. Ces interfaces vont devenir des composants Spring et \u00eatre disponibles dans son contexte\u00a0;</li> <li>ligne 19\u00a0: l'annotation [@Configuration] fait de la classe [Config] une classe de configuration Spring\u00a0;</li> <li>ligne 20\u00a0: l'annotation [@ComponentScan] permet de lister les dossiers o\u00f9 les composants Spring doivent \u00eatre recherch\u00e9s. Les composants Spring sont des classes tagu\u00e9es avec des annotations Spring telles que @Service, @Component, @Controller, ... Ici, il n'y en a pas d'autres que ceux qui sont d\u00e9finis au sein de la classe [AppConfig], aussi l'annotation a-t-elle \u00e9t\u00e9 mise en commentaires\u00a0;</li> <li>lignes 24-37\u00a0: d\u00e9finissent la source de donn\u00e9es, la base de donn\u00e9es H2. C'est l'annotation @Bean de la ligne 25 qui fait de l'objet cr\u00e9\u00e9 par cette m\u00e9thode un composant g\u00e9r\u00e9 par Spring. Le nom de la m\u00e9thode peut \u00eatre ici quelconque. Cependant elle doit \u00eatre appel\u00e9e [dataSource] si l'EntityManagerFactory de la ligne 51 est absent et d\u00e9fini par autoconfiguration\u00a0;</li> <li>ligne 30\u00a0: la base de donn\u00e9es s'appellera [demo] et sera g\u00e9n\u00e9r\u00e9e dans le dossier du projet\u00a0;</li> <li>lignes 40-47\u00a0: d\u00e9finissent l'impl\u00e9mentation JPA utilis\u00e9e, ici une impl\u00e9mentation Hibernate. Le nom de la m\u00e9thode peut \u00eatre ici quelconque\u00a0;</li> <li>ligne 43\u00a0: pas de logs SQL\u00a0;</li> <li>ligne 44\u00a0: la base de donn\u00e9es sera cr\u00e9\u00e9e si elle n'existe pas\u00a0;</li> <li>lignes 50-58\u00a0: d\u00e9finissent l'EntityManagerFactory qui va g\u00e9rer la persistance JPA. La m\u00e9thode doit s'appeler obligatoirement [entityManagerFactory]\u00a0;</li> <li>ligne 51\u00a0: la m\u00e9thode re\u00e7oit deux param\u00e8tres ayant le type des deux beans d\u00e9finis pr\u00e9c\u00e9demment. Ceux-ci seront alors construits puis inject\u00e9s par Spring comme param\u00e8tres de la m\u00e9thode\u00a0;</li> <li>ligne 53\u00a0: fixe l'impl\u00e9mentation JPA utilis\u00e9e\u00a0;</li> <li>ligne 54\u00a0: fixe les dossiers o\u00f9 trouver les entit\u00e9s JPA\u00a0;</li> <li>ligne 55\u00a0: fixe la source de donn\u00e9es \u00e0 g\u00e9rer\u00a0;</li> <li>lignes 61-66\u00a0: le gestionnaire de transactions. La m\u00e9thode doit s'appeler obligatoirement [transactionManager]. Elle re\u00e7oit pour param\u00e8tre le bean des lignes 51-58\u00a0;</li> <li>ligne 64\u00a0: le gestionnaire de transactions est associ\u00e9 \u00e0 l'EntityManagerFactory\u00a0; Les m\u00e9thodes pr\u00e9c\u00e9dentes peuvent \u00eatre d\u00e9finies dans un ordre quelconque.</li> </ul> <p>L'ex\u00e9cution du projet donne les m\u00eames r\u00e9sultats. Un nouveau fichier appara\u00eet dans le dossier du projet, celui de la base de donn\u00e9es H2\u00a0:</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1126-creation-dune-archive-executable","title":"11.2.6. Cr\u00e9ation d'une archive ex\u00e9cutable","text":"<p>Pour cr\u00e9er une archive ex\u00e9cutable du projet, on peut proc\u00e9der ainsi\u00a0:</p> <ul> <li>en [1]\u00a0: on cr\u00e9e une configuration d'ex\u00e9cution\u00a0;</li> <li>en [2]\u00a0: de type [Java Application]</li> <li>en [3]\u00a0: d\u00e9signe le projet \u00e0 ex\u00e9cuter (utiliser le bouton Browse)\u00a0;</li> <li>en [4]\u00a0: d\u00e9signe la classe \u00e0 ex\u00e9cuter\u00a0;</li> <li>en [5]\u00a0: le nom de la configuration d'ex\u00e9cution \u2013 peut \u00eatre quelconque\u00a0;</li> </ul> <ul> <li>en [6]\u00a0: on exporte le projet\u00a0;</li> <li>en [7]\u00a0: sous la forme d'une archive JAR ex\u00e9cutable\u00a0;</li> <li>en [8]\u00a0: indique le chemin et le nom du fichier ex\u00e9cutable \u00e0 cr\u00e9er\u00a0;</li> <li>en [9]\u00a0: le nom de la configuration d'ex\u00e9cution cr\u00e9\u00e9e en [5]\u00a0;</li> </ul> <ul> <li>en [10], l'archive cr\u00e9\u00e9e\u00a0; Ceci fait, on ouvre une console dans le dossier contenant l'archive ex\u00e9cutable\u00a0:</li> </ul> <pre><code>.....\\dist&gt;dir\n12/06/2014  09:11        15\u00a0104\u00a0869 gs-accessing-data-jpa-02.jar\n</code></pre> <p>L'archive est ex\u00e9cut\u00e9e de la fa\u00e7on suivante\u00a0:</p> <pre><code>.....\\dist&gt;java -jar gs-accessing-data-jpa-02.jar\n</code></pre> <p>Les r\u00e9sultats obtenus dans la console sont les suivants\u00a0:</p> <pre><code>SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\nmars 10, 2015 5:27:20 PM org.hibernate.jpa.internal.util.LogHelper logPersistenceUnitInformation\nINFO: HHH000204: Processing PersistenceUnitInfo [\n    name: default\n    ...]\nmars 10, 2015 5:27:20 PM org.hibernate.Version logVersion\nINFO: HHH000412: Hibernate Core {4.3.8.Final}\nmars 10, 2015 5:27:20 PM org.hibernate.cfg.Environment &lt;clinit&gt;\nINFO: HHH000206: hibernate.properties not found\nmars 10, 2015 5:27:20 PM org.hibernate.cfg.Environment buildBytecodeProvider\nINFO: HHH000021: Bytecode provider name : javassist\nmars 10, 2015 5:27:22 PM org.hibernate.annotations.common.reflection.java.JavaReflectionManager &lt;clinit&gt;\nINFO: HCANN000001: Hibernate Commons Annotations {4.0.5.Final}\nmars 10, 2015 5:27:22 PM org.hibernate.dialect.Dialect &lt;init&gt;\nINFO: HHH000400: Using dialect: org.hibernate.dialect.H2Dialect\nmars 10, 2015 5:27:22 PM org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory &lt;init&gt;\nINFO: HHH000397: Using ASTQueryTranslatorFactory\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.SchemaUpdate execute\nINFO: HHH000228: Running hbm2ddl schema update\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.SchemaUpdate execute\nINFO: HHH000102: Fetching database metadata\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.SchemaUpdate execute\nINFO: HHH000396: Updating schema\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.DatabaseMetadata getTableMetadata\nINFO: HHH000262: Table not found: Customer\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.DatabaseMetadata getTableMetadata\nINFO: HHH000262: Table not found: Customer\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.DatabaseMetadata getTableMetadata\nINFO: HHH000262: Table not found: Customer\nmars 10, 2015 5:27:22 PM org.hibernate.tool.hbm2ddl.SchemaUpdate execute\nINFO: HHH000232: Schema update complete\nCustomers found with findAll():\n-------------------------------\nCustomer[id=1, firstName='Jack', lastName='Bauer']\nCustomer[id=2, firstName='Chloe', lastName='O'Brian']\nCustomer[id=3, firstName='Kim', lastName='Bauer']\nCustomer[id=4, firstName='David', lastName='Palmer']\nCustomer[id=5, firstName='Michelle', lastName='Dessler']\n\nCustomer found with findOne(1L):\n--------------------------------\nCustomer[id=1, firstName='Jack', lastName='Bauer']\n\nCustomer found with findByLastName('Bauer'):\n--------------------------------------------\nCustomer[id=1, firstName='Jack', lastName='Bauer']\nCustomer[id=3, firstName='Kim', lastName='Bauer']\n</code></pre>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#113-exemple-2","title":"11.3. Exemple 2","text":""},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1131-introduction","title":"11.3.1. Introduction","text":"<p>Nous allons reprendre l'exemple de la table de produits que nous avons utilis\u00e9e pour introduire l'API JDBC et cr\u00e9er l'architecture suivante\u00a0:</p> <p>La base de donn\u00e9es [dbintrospringjpa] a deux tables [PRODUITS] et [CATEGORIES]. La table [CATEGORIES] est la suivante\u00a0:</p> <ul> <li>[ID]\u00a0: cl\u00e9 primaire en mode AUTO_INCREMENT\u00a0;</li> <li>[VERSION]\u00a0: n\u00b0 de version de l'enregistrement\u00a0;</li> <li>[NOM]\u00a0: nom de la cat\u00e9gorie - unique\u00a0; La table [PRODUITS] est la suivante\u00a0:</li> </ul> <ul> <li>[ID]\u00a0: cl\u00e9 primaire en mode AUTO_INCREMENT\u00a0;</li> <li>[VERSION]\u00a0: n\u00b0 de version de l'enregistrement\u00a0;</li> <li>[NOM]\u00a0: nom d'un produit - unique\u00a0;</li> <li>[ID_CATEGORIE]\u00a0: n\u00b0 de sa cat\u00e9gorie - cl\u00e9 \u00e9trang\u00e8re sur le champ [CATEGORIES.ID]\u00a0;</li> <li>[PRIX]\u00a0: son prix\u00a0;</li> <li>[DESCRIPTION]\u00a0: une description du produit\u00a0; Travail \u00e0 faire\u00a0: cr\u00e9ez la base de donn\u00e9es [dbintrospringdata] avec le script SQL [dbintrospringdata.sql] du support\u00a0:</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1132-creation-du-projet-maven","title":"11.3.2. Cr\u00e9ation du projet Maven","text":"<p>Pour cr\u00e9er un squelette de projet Spring Data, on peut proc\u00e9der de la fa\u00e7on suivante\u00a0:</p> <p>1</p><p>2</p><p>4357</p> <ul> <li>en [1], on cr\u00e9e un nouveau projet\u00a0;</li> <li>en [2]\u00a0: de type [Spring Starter Project]\u00a0;</li> <li>le projet g\u00e9n\u00e9r\u00e9 sera un projet Maven. En [3], on indique le nom du groupe du projet\u00a0;</li> <li>en [4]\u00a0: on indique le nom de l'artifact (un jar ici) qui sera cr\u00e9\u00e9 par construction du projet\u00a0;</li> <li>en [5]\u00a0: le nom Eclipse du projet \u2013 peut \u00eatre quelconque (n'a pas \u00e0 \u00eatre identique \u00e0 [4])\u00a0;</li> <li>en [7]\u00a0: on indique qu'on va cr\u00e9er un projet ayant une couche [JPA] avec le SGBD MySQL. Les d\u00e9pendances n\u00e9cessaires \u00e0 un tel projet vont alors \u00eatre incluses dans le fichier [pom.xml]\u00a0;</li> </ul> <ul> <li>en [8], donner le nom du dossier du projet\u00a0;</li> <li>en [9], terminer l'assistant\u00a0;</li> </ul> <ul> <li>en [10]\u00a0: le projet cr\u00e9\u00e9\u00a0; Le fichier [pom.xml] int\u00e8gre les d\u00e9pendances n\u00e9cessaires \u00e0 un projet JPA\u00a0:</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;istia.st.springdata&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-spring-data-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;intro-spring-data-01&lt;/name&gt;\n    &lt;description&gt;d\u00e9mo spring data avec table de produits&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;start-class&gt;demo.IntroSpringData01Application&lt;/start-class&gt;\n        &lt;java.version&gt;1.7&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 14-19\u00a0: le projet Maven parent - d\u00e9finit un grand nombre de biblioth\u00e8ques avec leurs versions - on utilise ces biblioth\u00e8ques comme d\u00e9pendances Maven sans pr\u00e9ciser leur version\u00a0;</li> <li>lignes 28-31\u00a0: la d\u00e9pendance n\u00e9cessaire \u00e0 JPA \u2013 va inclure [Spring Data]\u00a0;</li> <li>lignes 32-36\u00a0: la d\u00e9pendance sur le pilote JDBC de MySQL\u00a0;</li> <li>lignes 37-41\u00a0: les d\u00e9pendances n\u00e9cessaires aux tests JUnit int\u00e9gr\u00e9s avec Spring\u00a0; La classe ex\u00e9cutable [Application] ne fait rien mais est pr\u00e9configur\u00e9e\u00a0:</li> </ul> <pre><code>package demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class IntroSpringData01Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(IntroSpringData01Application.class, args);\n    }\n}\n</code></pre> <ul> <li>l'annotation [@SpringBootApplication] fait de la classe une classe d'auto-configuration du projet\u00a0; La classe de tests [ApplicationTests] ne fait rien mais est pr\u00e9configur\u00e9e\u00a0:</li> </ul> <pre><code>package demo;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = IntroSpringData01Application.class)\npublic class IntroSpringData01ApplicationTests {\n\n    @Test\n    public void contextLoads() {\n    }\n\n}\n</code></pre> <ul> <li>ligne 9\u00a0: l'annotation [@SpringApplicationConfiguration] permet d'exploiter le fichier de configuration [Application]. La classe de test b\u00e9n\u00e9ficiera ainsi de tous les beans qui seront d\u00e9finis par ce fichier\u00a0;</li> <li>ligne 8\u00a0: l'annotation [@RunWith] permet l'int\u00e9gration de Spring avec JUnit\u00a0: la classe va pouvoir \u00eatre ex\u00e9cut\u00e9e comme un test JUnit. [@RunWith] est une annotation JUnit (ligne 4) alors que la classe [SpringJUnit4ClassRunner] est une classe Spring (ligne 6)\u00a0; Maintenant que nous avons un squelette d'application JPA, nous pouvons le compl\u00e9ter pour \u00e9crire le projet de la couche de persistance associ\u00e9e \u00e0 la base de donn\u00e9es des produits.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1133-le-projet-eclipse","title":"11.3.3. Le projet Eclipse","text":"<p>Nous faisons \u00e9voluer le projet pr\u00e9c\u00e9dent de la fa\u00e7on suivante\u00a0:</p> <ul> <li>[AppConfig.java]\u00a0: la classe de configuration du projet Spring\u00a0;</li> <li>[Main.java]\u00a0: la classe ex\u00e9cutable du projet\u00a0;</li> <li>[IDao.java]\u00a0: l'interface de la couche [DAO]\u00a0;</li> <li>[Dao.java]\u00a0: la classe d'impl\u00e9mentation de la couche [DAO]\u00a0;</li> <li>[AbstractEntity.java]\u00a0: la classe parent des classes [Produit] et [Categorie]\u00a0;</li> <li>[Produit.java]\u00a0: classe associ\u00e9e \u00e0 une ligne de la table [PRODUITS] de la base de donn\u00e9es\u00a0;</li> <li>[Categorie.java]\u00a0: classe associ\u00e9e \u00e0 une ligne de la table [CATEGORIES] de la base de donn\u00e9es\u00a0;</li> <li>[ProduitsRepository]\u00a0: l'interface Spring Data d'acc\u00e8s \u00e0 la table [PRODUITS]\u00a0;</li> <li>[CategoriesRepository]\u00a0: l'interface Spring Data d'acc\u00e8s \u00e0 la table [CATEGORIES]\u00a0;</li> <li>[pom.xml]\u00a0: le fichier de configuration du projet Maven\u00a0; Ce projet impl\u00e9mente l'architecture suivante\u00a0:</li> </ul> <p>La couche [DAO] ne voit que la couche impl\u00e9ment\u00e9e par [Spring Data].</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1134-configuration-maven","title":"11.3.4. Configuration Maven","text":"<p>Le fichier [pom.xml] du projet Maven est le suivant\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;istia.st.springdata&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-spring-data-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;intro-spring-data-01&lt;/name&gt;\n    &lt;description&gt;d\u00e9mo spring data avec table de produits&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring Data --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Hibernate --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- MySQL Database --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Tomcat JDBC --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- biblioth\u00e8que jSON --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Google Guava --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n            &lt;artifactId&gt;guava&lt;/artifactId&gt;\n            &lt;version&gt;16.0.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- biblioth\u00e8que de logs --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <p>Cette configuration est celle utilis\u00e9e et expliqu\u00e9e au paragraphe 11.2.5, page 175. Nous y ajoutons les biblioth\u00e8ques suivantes\u00a0:</p> <ul> <li>lignes 42-49\u00a0: une biblioth\u00e8que jSON utilis\u00e9e par la m\u00e9thode [toString] de la classe [Produit]\u00a0;</li> <li>lignes 51-55\u00a0: la biblioth\u00e8que [Google Guava] qui am\u00e8ne des m\u00e9thodes utilitaires pour g\u00e9rer des collections d'\u00e9l\u00e9ments. Elle sera utilis\u00e9e par la classe [Dao] qui impl\u00e9mente la couche [DAO]\u00a0;</li> <li>lignes 56-67\u00a0: les biblioth\u00e8ques n\u00e9cessaires aux tests JUnit\u00a0;</li> <li>lignes 69-72\u00a0: une biblioth\u00e8que de logs\u00a0;</li> <li>lignes 81-86\u00a0: les plugins Maven n\u00e9cessaires au projet\u00a0;</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1135-les-entites-de-la-couche-jpa","title":"11.3.5. Les entit\u00e9s de la couche [JPA]","text":"<p>Couche[Spring Data]Pilote[JDBC]Couche[JPA]Couche[console]Couche[DAO]Spring 4SGBD</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#11351-la-classe-abstractentity","title":"11.3.5.1. La classe [AbstractEntity]","text":"<p>La classe [AbstractEntity] est la suivante\u00a0:</p> <pre><code>package spring.data.entities;\n\nimport javax.persistence.Column;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.MappedSuperclass;\nimport javax.persistence.Version;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n@MappedSuperclass\npublic abstract class AbstractEntity {\n    // propri\u00e9t\u00e9s\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\")\n    protected Long id;\n    @Version\n    @Column(name = \"VERSION\")\n    protected Long version;\n\n    // constructeurs\n    public AbstractEntity() {\n\n    }\n\n    public AbstractEntity(Long id, Long version) {\n        this.id = id;\n        this.version = version;\n    }\n\n    // red\u00e9finition [equals] et [hashcode]\n    @Override\n    public int hashCode() {\n        return (id != null ? id.hashCode() : 0);\n    }\n\n    @Override\n    public boolean equals(Object entity) {\n        if (!(entity instanceof AbstractEntity)) {\n            return false;\n        }\n        String class1 = this.getClass().getName();\n        String class2 = entity.getClass().getName();\n        if (!class2.equals(class1)) {\n            return false;\n        }\n        AbstractEntity other = (AbstractEntity) entity;\n        return id != null &amp;&amp; this.id.longValue() == other.id.longValue();\n    }\n\n    // signature jSON\n    public String toString() {\n        ObjectMapper mapper = new ObjectMapper();\n        try {\n            return mapper.writeValueAsString(this);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    // getters et setters\n....\n}\n</code></pre> <p>Cette classe a pour objectif de fournir une classe m\u00e8re aux entit\u00e9s JPA en encapsulant \u00e0 un unique endroit les propri\u00e9t\u00e9s [id, version] (lignes 19, 22) communes aux deux entit\u00e9s [Produit] et [Categorie] li\u00e9es \u00e0 la base de donn\u00e9es. Ces propri\u00e9t\u00e9s sont li\u00e9es aux colonnes [ID, VERSION] des tables (lignes 18, 21).</p> <ul> <li>ligne 13\u00a0: l'annotation [@MappedSuperclass] indique que la classe est une classe parent d'entit\u00e9s JPA\u00a0;</li> <li>ligne 16\u00a0: l'annotation [@Id] indique que le champ [id] (il pourrait avoir un autre nom) est associ\u00e9 \u00e0 la cl\u00e9 primaire d'une table\u00a0;</li> <li>ligne 17\u00a0: l'annotation [@GeneratedValue(strategy=GenerationType.IDENTITY)] fixe le mode de g\u00e9n\u00e9ration des cl\u00e9s primaires. Le mode [GenerationType.IDENTITY] va utiliser avec MySQL le mode [AUTO_INCREMENT]. Avec un autre SGBD, ce mode utiliserait une autre m\u00e9thode. L'int\u00e9r\u00eat est que le d\u00e9veloppeur n'a pas \u00e0 s'en pr\u00e9occuper et que son code reste valide quelque soit le SGBD utilis\u00e9\u00a0;</li> <li>ligne 18\u00a0: l'annotation [@Column] indique la colonne associ\u00e9e au champ. Lorsque cette annotation n'est pas pr\u00e9sente, JPA assume que la colonne porte le m\u00eame nom que le champ. C'est le cas ici. On n'aurait donc pu ne pas mettre cette annotation\u00a0;</li> <li>ligne 20\u00a0: l'annotation [@Version] indique que le champ [version] est associ\u00e9 \u00e0 une colonne de versioning. L'impl\u00e9mentation JPA va incr\u00e9menter ce n\u00b0 de version \u00e0 chaque fois que l'entit\u00e9 sera modifi\u00e9e. Ce n\u00b0 sert \u00e0 emp\u00eacher la mise \u00e0 jour simultan\u00e9e de l'entit\u00e9 par deux utilisateur diff\u00e9rents\u00a0: deux utilisateurs U1 et U2 lisent l'entit\u00e9 E avec un n\u00b0 de version \u00e9gal \u00e0 V1. U1 modifie E et persiste cette modification en base\u00a0: le n\u00b0 de version passe alors \u00e0 V1+1. U2 modifie E \u00e0 son tour et persiste cette modification en base\u00a0: il recevra une exception car il poss\u00e8de une version (V1) diff\u00e9rente de celle en base (V1+1)\u00a0;</li> <li>lignes 35-52\u00a0: red\u00e9finition des m\u00e9thodes [hashCode] et [equals]. Par d\u00e9faut, [obj1.equals(obj2)] vaut true si [obj1==obj2], \u00e7-\u00e0-d si ob1 et obj2 sont deux pointeurs \u00e9gaux. Si on veut comparer les objets point\u00e9s plut\u00f4t que les pointeurs eux-m\u00eames, il faut red\u00e9finir la m\u00e9thode [equals] et la m\u00e9thode [hashCode]. Celle-ci doit rendre la m\u00eame valeur pour deux objets que la m\u00e9thode [equals] dit \u00e9gaux\u00a0;</li> <li>lignes 42-51\u00a0: deux objets de type [AbstractEntity] ou d\u00e9riv\u00e9s seront dits \u00e9gaux si leurs cl\u00e9s primaires [id] sont \u00e9gales\u00a0;</li> <li>lignes 35-38\u00a0: la m\u00e9thode [hashCode] rend bien la m\u00eame valeur pour deux objets [AbstractEntity] identiques et donc ayant la m\u00eame cl\u00e9 primaire [id]\u00a0;</li> <li>lignes 55-63\u00a0: la m\u00e9thode [toString] rend la cha\u00eene jSon de l'objet [this]. Si cet objet d\u00e9signe une classe fille, cette m\u00e9thode rendra alors la cha\u00eene jSON de la classe fille. Cela nous dispense de cr\u00e9er une m\u00e9thode [toString] dans les classes filles\u00a0;</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#11352-lentite-jpa-produit","title":"11.3.5.2. L'entit\u00e9 JPA [Produit]","text":"<p>La classe [Produit] est une entit\u00e9 JPA associ\u00e9e \u00e0 une ligne de la table [PRODUITS]\u00a0:</p> <pre><code>package spring.data.entities;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\n\nimport com.fasterxml.jackson.annotation.JsonFilter;\n\n@Entity\n@Table(name = \"PRODUITS\")\n@JsonFilter(\"jsonFilterProduit\")\npublic class Produit extends AbstractEntity {\n\n    // propri\u00e9t\u00e9s\n    @Column(name = \"NOM\")\n    private String nom;\n\n    @Column(name = \"CATEGORIE_ID\", insertable = false, updatable = false)    \n    private Long idCategorie;\n\n    @Column(name = \"PRIX\")\n    private double prix;\n\n    @Column(name = \"DESCRIPTION\")\n    private String description;\n\n    // la cat\u00e9gorie\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"CATEGORIE_ID\")    \n    private Categorie categorie;\n\n    // constructeurs\n    public Produit() {\n\n    }\n\n    public Produit(String nom, double prix, String description) {\n        this.nom = nom;\n        this.prix = prix;\n        this.description = description;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>ligne 12\u00a0: l'annotation [@Entity] fait de la classe [Produit] une entit\u00e9 g\u00e9r\u00e9e par la couche [JPA]\u00a0;</li> <li>ligne 13\u00a0: l'annotation [@Table(name = \"PRODUITS\")] indique que la classe [Produit] est l'image objet d'une ligne de la table [PRODUITS] de la base de donn\u00e9es\u00a0;</li> <li>ligne 14\u00a0: le nom du filtre jSON \u00e0 appliquer \u00e0 l'entit\u00e9. Nous allons voir que la propri\u00e9t\u00e9 [categorie] de la ligne 13 n'est pas toujours disponible. Il faut alors l'exclure de la repr\u00e9sentation jSON de l'objet. Pour cela nous avons besoin d'un filtre. C'est donc dans un filtre nomm\u00e9 [jsonFilterCategorie] que nous indiquerons si on veut ou non la propri\u00e9t\u00e9 [categorie]\u00a0;</li> <li>ligne 18\u00a0: l'annotation [@Column] associe le champ [nom] \u00e0 la colonne [NOM] de la table [PRODUITS]. Lorsque le champ porte le m\u00eame nom que la colonne associ\u00e9e, l'annotation [@Column] peut \u00eatre omise. Ce serait le cas ici\u00a0;</li> <li>lignes 31-33\u00a0: la cat\u00e9gorie du produit\u00a0;</li> <li>ligne 31\u00a0: l'annotation [@ManyToOne] indique que la colonne de l'annotation de la ligne 32 [@JoinColumn(name = \"CATEGORIE_ID\")] est cl\u00e9 \u00e9trang\u00e8re de la table [PRODUITS] de l'entit\u00e9 [Produit] sur la table [CATEGORIES] associ\u00e9e \u00e0 l'entit\u00e9 de la ligne 33. Cette annotation doit annoter une entit\u00e9 JPA. Ainsi la classe de  la ligne 33 doit \u00eatre une entit\u00e9 JPA\u00a0;</li> <li>ligne 31\u00a0: l'annotation [fetch = FetchType.LAZY] demande \u00e0 ce que lorsqu'on ram\u00e8ne un produit de la table [PRODUITS], sa cat\u00e9gorie (ligne 33) ne soit pas ramen\u00e9e imm\u00e9diatement (lazy loading). Elle est alors obtenue lors du premier appel \u00e0 la m\u00e9thode [getCategorie]. Cet attribut n'est pas contraignant. L'impl\u00e9mentation JPA utilis\u00e9e a le droit de l'ignorer. C'est parce que la propri\u00e9t\u00e9 [categorie] peut \u00eatre pr\u00e9sente ou non que nous avons introduit le filtre jSON de la ligne 14. Les impl\u00e9mentations JPA existantes (Hibernate, Eclipselink, OpenJPA) ne g\u00e8rent pas cette annotation de la m\u00eame fa\u00e7on. Hibernate enrichit la m\u00e9thode [getCategorie] initiale (qui se contente de rendre le champ categorie) par un appel au SGBD pour aller chercher la cat\u00e9gorie. Pour que cela soit possible, il faut que la connexion au SGBD utilis\u00e9e initialement pour obtenir le produit soit encore ouverte sinon on a une exception.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#11353-lentite-jpa-categorie","title":"11.3.5.3. L'entit\u00e9 JPA [Categorie]","text":"<p>La classe [Categorie] est une entit\u00e9 JPA associ\u00e9e \u00e0 une ligne de la table [CATEGORIES]\u00a0:</p> <p>Son code est le suivant\u00a0:</p> <pre><code>package spring.data.entities;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.persistence.CascadeType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.OneToMany;\nimport javax.persistence.Table;\n\nimport com.fasterxml.jackson.annotation.JsonFilter;\n\n@Entity\n@Table(name = \"CATEGORIES\")\n@JsonFilter(\"jsonFilterCategorie\")\npublic class Categorie extends AbstractEntity {\n\n    // propri\u00e9t\u00e9s\n    @Column(name = \"NOM\")\n    private String nom;\n\n    // les produits associ\u00e9s\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"categorie\", cascade = { CascadeType.ALL })\n    public Set&lt;Produit&gt; produits = new HashSet&lt;Produit&gt;();\n\n    // constructeurs\n    public Categorie() {\n\n    }\n\n    public Categorie(String nom) {\n        this.nom = nom;\n    }\n\n    // m\u00e9thodes\n    public void addProduit(Produit produit) {\n        // on ajoute le produit\n        produits.add(produit);\n        // on fixe sa cat\u00e9gorie\n        produit.setCategorie(this);\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>lignes 21-22\u00a0: le nom de la cat\u00e9gorie\u00a0;</li> <li>lignes 25-26\u00a0: les produits de cette cat\u00e9gorie\u00a0;</li> <li>ligne 25\u00a0: l'annotation [@OneToMany] est la relation inverse de la relation [@ManyToOne] que nous avons rencontr\u00e9e dans l'entit\u00e9 [Produit]. L'attribut [mappedBy = \"categorie\"] indique le champ de l'entit\u00e9 [Produit] annot\u00e9 par la relation inverse [@ManyToOne]. L'attribut [cascade = { CascadeType.ALL }] demande \u00e0 ce que les op\u00e9rations (persist, merge, remove) faites sur une @Entity [Categorie] soient cascad\u00e9es sur les [produits] de la ligne 26. On peut indiquer des cascades partielles avec les constantes [CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE]\u00a0;</li> <li>ligne 25\u00a0: l'attribut [fetch = FetchType.LAZY] demande \u00e0 ce que, lorsqu'on ram\u00e8ne une cat\u00e9gorie de la table [CATEGORIES], ses produits ne soient pas imm\u00e9diatement ramen\u00e9s. Ils le seront lors du premier appel \u00e0 la m\u00e9thode [getProduits]. Les impl\u00e9mentations JPA existantes (Hibernate, Eclipselink, OpenJPA) ne g\u00e8rent pas cette annotation de la m\u00eame fa\u00e7on. Hibernate enrichit la m\u00e9thode [getProduits] initiale (qui se contente de rendre le champ produits) par un appel au SGBD pour aller chercher les produits de la cat\u00e9gorie. Pour que cela soit possible, il faut que la connexion au SGBD utilis\u00e9e initialement pour obtenir la cat\u00e9gorie soit encore ouverte. Cet attribut est contraignant. L'impl\u00e9mentation JPA ne peut l'ignorer. Parce que la propri\u00e9t\u00e9 [produits] peut \u00eatre ou non initialis\u00e9e, nous avons introduit le filtre jSON de la ligne 17 qui nous permettra d'indiquer si on veut ou non cette propri\u00e9t\u00e9\u00a0;</li> <li>ligne 26\u00a0: le type [Set] est une interface. Le type [HashSet] est une classe impl\u00e9mentant cette interface. Elle impl\u00e9mente une collection d'\u00e9l\u00e9ments appel\u00e9e ensemble. Un ensemble ne peut contenir deux objets identiques. Ici les objets sont de type [Produit]. Ainsi dans l'ensemble, on ne pourra avoir deux objets identiques. Comme la m\u00e9thode [equals] de la classe parent [AbstractEntity] a \u00e9t\u00e9 red\u00e9finie pour dire que deux produits sont identiques s'ils ont la m\u00eame cl\u00e9 primaire, alors le champ [produits] ne pourra contenir deux produits de m\u00eame cl\u00e9 primaire\u00a0;</li> <li>lignes 38-43\u00a0: la m\u00e9thode [addProduit] permet d'ajouter un produit \u00e0 la cat\u00e9gorie\u00a0;</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1136-la-couche-spring-data","title":"11.3.6. La couche [Spring Data]","text":"<p>Couche[Spring Data]Pilote[JDBC]Couche[JPA]Couche[console]Couche[DAO]Spring 4SGBD</p> <p>L'interface [CategoriesRepository] g\u00e8re les acc\u00e8s \u00e0 la table [CATEGORIES]\u00a0:</p> <pre><code>package spring.data.repositories;\n\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.CrudRepository;\n\nimport spring.data.entities.Categorie;\n\npublic interface CategoriesRepository extends CrudRepository&lt;Categorie, Long&gt; {\n\n    // categorie avec ses produits\n    @Query(\"select c from Categorie c left join fetch c.produits p where c.id=?1\")\n    public Categorie getCategorieByIdWithProduits(Long id);\n\n    @Query(\"select c from Categorie c left join fetch c.produits p where c.nom=?1\")\n    public Categorie getCategorieByNameWithProduits(String nom);\n\n    // une cat\u00e9gorie sans ses produits d\u00e9sign\u00e9e par son nom\n    public Categorie findByNom(String nom);\n}\n</code></pre> <ul> <li>ligne 8\u00a0: l'interface [CrudRepository] a \u00e9t\u00e9 utilis\u00e9e et expliqu\u00e9e page 171\u00a0. On rappelle que\u00a0:</li> <li>le 1er type de l'interface est l'entit\u00e9 JPA g\u00e9r\u00e9e pour des acc\u00e8s CRUD (findOne, findAll, save, delete, deleteAll),</li> <li>le second type est celui de la cl\u00e9 primaire de l'entit\u00e9 JPA, ici un entier [Long]\u00a0;</li> <li>ligne 12\u00a0: la m\u00e9thode de la ligne 12 est impl\u00e9ment\u00e9e par la requ\u00eate JPQL (Java Persistence Query Language) de la ligne 11. Celle-ci requ\u00eate des entit\u00e9s JPA. Dans une telle requ\u00eate\u00a0:</li> <li>les tables sont remplac\u00e9es par leurs entit\u00e9s JPA associ\u00e9es\u00a0;</li> <li>les colonnes sont remplac\u00e9es par des champs des entit\u00e9s JPA utilis\u00e9es dans la requ\u00eate\u00a0;</li> <li>ligne 11\u00a0: la requ\u00eate JPQL ram\u00e8ne une cat\u00e9gorie avec ses produits. On se rappelle que dans l'entit\u00e9 [Categorie], le champ [produits] avait l'attribut [fetch = FetchType.LAZY] (lazy loading). Dans la requ\u00eate JPQL, on force le chargement des produits avec le mot cl\u00e9 [fetch]. Le param\u00e8tre ?1 de la requ\u00eate sera remplac\u00e9 \u00e0 l'ex\u00e9cution par la valeur du 1er param\u00e8tre de la m\u00e9thode de la ligne 12, donc par le param\u00e8tre [Long id]\u00a0;</li> <li>lignes 14-15\u00a0: une m\u00e9thode analogue pour une cat\u00e9gorie identifi\u00e9e par son nom\u00a0;</li> <li>ligne 18\u00a0: la m\u00e9thode [findByNom] sera automatiquement impl\u00e9ment\u00e9e par [Spring Data] car le type [Category] a un champ [nom]\u00a0; L'interface [ProduitsRepository] g\u00e8re les acc\u00e8s \u00e0 la table [PRODUITS]\u00a0:</li> </ul> <pre><code>package spring.data.repositories;\n\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.CrudRepository;\n\nimport spring.data.entities.Produit;\n\npublic interface ProduitsRepository extends CrudRepository&lt;Produit, Long&gt; {\n\n    // un produit avec sa cat\u00e9gorie\n    @Query(\"select p from Produit p left join fetch p.categorie c where p.id=?1\")\n    public Produit getProduitByIdWithCategorie(Long id);\n\n    @Query(\"select p from Produit p left join fetch p.categorie c where p.nom=?1\")\n    public Produit getProduitByNameWithCategorie(String nom);\n\n    // un produit sans sa cat\u00e9gorie d\u00e9sign\u00e9 par son nom\n    public Produit findByNom(String nom);\n}\n</code></pre> <p>Les explications sont les m\u00eames que pour l'interface [CategoriesRepository].</p> <p>Ces interfaces vont \u00eatre impl\u00e9ment\u00e9es par des classes g\u00e9n\u00e9r\u00e9es par [Spring Data] au moment de l'ex\u00e9cution du projet. On appelle de telles classes des [proxy]. Par d\u00e9faut, les m\u00e9thodes de la classe d'impl\u00e9mentation s'ex\u00e9cutent dans une transaction. Le fait que ces interfaces \u00e9tendent la classe [CrudRepository] font d'elles des composants Spring.</p>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1137-la-couche-dao","title":"11.3.7. La couche [DAO]","text":"<p>Couche[Spring Data]Pilote[JDBC]Couche[JPA]Couche[console]Couche[DAO]Spring 4SGBD</p> <p>L'interface [IDao] de la couche [DAO] est la suivante\u00a0:</p> <pre><code>package spring.data.dao;\n\nimport java.util.List;\n\nimport spring.data.entities.Categorie;\nimport spring.data.entities.Produit;\n\npublic interface IDao {\n\n    // insertion d'une liste de produits\n    public List&lt;Produit&gt; addProduits(List&lt;Produit&gt; produits);\n\n    // suppression de tous les produits\n    public void deleteAllProduits();\n\n    // mise \u00e0 jour d'une liste de produits\n    public List&lt;Produit&gt; updateProduits(List&lt;Produit&gt; produits);\n\n    // obtention de tous les produits\n    public List&lt;Produit&gt; getAllProduits();\n\n    // insertion d'une liste de categories\n    public List&lt;Categorie&gt; addCategories(List&lt;Categorie&gt; categories);\n\n    // suppression de tous les categories\n    public void deleteAllCategories();\n\n    // mise \u00e0 jour d'une liste de categories\n    public List&lt;Categorie&gt; updateCategories(List&lt;Categorie&gt; categories);\n\n    // obtention de tous les categories\n    public List&lt;Categorie&gt; getAllCategories();\n\n    // un produit particulier avec ou non sa cat\u00e9gorie\n    public Produit getProduitByIdWithoutCategorie(Long idProduit);\n\n    public Produit getProduitByIdWithCategorie(Long idProduit);\n\n    public Produit getProduitByNameWithCategorie(String nom);\n\n    public Produit getProduitByNameWithoutCategorie(String nom);\n\n    // une cat\u00e9gorie particuli\u00e8re avec ou pas ses produits\n    public Categorie getCategorieByIdWithoutProduits(Long idCategorie);\n\n    public Categorie getCategorieByIdWithProduits(Long idCategorie);\n\n    public Categorie getCategorieByNameWithProduits(String nom);\n\n    public Categorie getCategorieByNameWithoutProduits(String nom);\n}\n</code></pre> <p>On a adopt\u00e9 ici la r\u00e8gle que toute m\u00e9thode qui modifie les objets qu'elle a en param\u00e8tres d'entr\u00e9e doit alors les rendre dans son r\u00e9sultat. La raison de cette r\u00e8gle a \u00e9t\u00e9 expliqu\u00e9e au paragraphe 4.2, page 34\u00a0: elle permet \u00e0 une couche et \u00e0 son client d'\u00eatre dans deux JVM s\u00e9par\u00e9es et donc de travailler en client / serveur.</p> <p>L'impl\u00e9mentation [Dao] de cette interface est la suivante\u00a0:</p> <pre><code>package spring.data.dao;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.collect.Lists;\n\nimport spring.data.entities.Categorie;\nimport spring.data.entities.Produit;\nimport spring.data.repositories.CategoriesRepository;\nimport spring.data.repositories.ProduitsRepository;\n\n@Component\npublic class Dao implements IDao {\n\n    @Autowired\n    private ProduitsRepository produitsRepository;\n\n    @Autowired\n    private CategoriesRepository categoriesRepository;\n\n    @Override\n    public List&lt;Produit&gt; addProduits(List&lt;Produit&gt; produits) {\n        try {\n            return Lists.newArrayList(produitsRepository.save(produits));\n        } catch (Exception e) {\n            throw new DaoException(101, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public void deleteAllProduits() {\n        try {\n            produitsRepository.deleteAll();\n        } catch (Exception e) {\n            throw new DaoException(102, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public List&lt;Produit&gt; updateProduits(List&lt;Produit&gt; produits) {\n        try {\n            return Lists.newArrayList(produitsRepository.save(produits));\n        } catch (Exception e) {\n            throw new DaoException(103, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public List&lt;Categorie&gt; addCategories(List&lt;Categorie&gt; categories) {\n        try {\n            return Lists.newArrayList(categoriesRepository.save(categories));\n        } catch (Exception e) {\n            throw new DaoException(104, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public void deleteAllCategories() {\n        try {\n            categoriesRepository.deleteAll();\n        } catch (Exception e) {\n            throw new DaoException(105, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public List&lt;Categorie&gt; updateCategories(List&lt;Categorie&gt; categories) {\n        try {\n            return Lists.newArrayList(categoriesRepository.save(categories));\n        } catch (Exception e) {\n            throw new DaoException(106, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public List&lt;Categorie&gt; getAllCategories() {\n        try {\n            return Lists.newArrayList(categoriesRepository.findAll());\n        } catch (Exception e) {\n            throw new DaoException(107, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public List&lt;Produit&gt; getAllProduits() {\n        try {\n            return Lists.newArrayList(produitsRepository.findAll());\n        } catch (Exception e) {\n            throw new DaoException(108, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Produit getProduitByIdWithCategorie(Long idProduit) {\n        try {\n            return produitsRepository.getProduitByIdWithCategorie(idProduit);\n        } catch (Exception e) {\n            throw new DaoException(109, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Categorie getCategorieByIdWithProduits(Long idCategorie) {\n        try {\n            return categoriesRepository.getCategorieByIdWithProduits(idCategorie);\n        } catch (Exception e) {\n            throw new DaoException(110, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Categorie getCategorieByNameWithProduits(String nom) {\n        try {\n            return categoriesRepository.getCategorieByNameWithProduits(nom);\n        } catch (Exception e) {\n            throw new DaoException(111, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Produit getProduitByNameWithCategorie(String nom) {\n        try {\n            return produitsRepository.getProduitByNameWithCategorie(nom);\n        } catch (Exception e) {\n            throw new DaoException(112, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Produit getProduitByIdWithoutCategorie(Long idProduit) {\n        try {\n            return produitsRepository.findOne(idProduit);\n        } catch (Exception e) {\n            throw new DaoException(113, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Categorie getCategorieByIdWithoutProduits(Long idCategorie) {\n        try {\n            return categoriesRepository.findOne(idCategorie);\n        } catch (Exception e) {\n            throw new DaoException(114, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Produit getProduitByNameWithoutCategorie(String nom) {\n        try {\n            return produitsRepository.findByNom(nom);\n        } catch (Exception e) {\n            throw new DaoException(115, getMessagesForException(e));\n        }\n    }\n\n    @Override\n    public Categorie getCategorieByNameWithoutProduits(String nom) {\n        try {\n            return categoriesRepository.findByNom(nom);\n        } catch (Exception e) {\n            throw new DaoException(116, getMessagesForException(e));\n        }\n    }\n\n}\n</code></pre> <ul> <li>ligne 16\u00a0: l'annotation [@Component] fait de la classe [Dao] un composant Spring\u00a0;</li> <li>lignes 19-23\u00a0: injection des r\u00e9f\u00e9rences sur les deux interfaces [CrudRepository] de [Spring Data]. Cette injection aura lieu lors de l'instantiation des objets Spring, en g\u00e9n\u00e9ral au d\u00e9but de l'ex\u00e9cution du projet Spring ;</li> <li>on notera lignes 28 et 46 que la m\u00e9thode [save] de l'interface [produitsRepository] est utilis\u00e9e aussi bien pour l'insertion que pour la mise \u00e0 jour de produits. [Spring Data] utilise la cl\u00e9 primaire du produit pour savoir s'il doit faire une insertion ou une mise \u00e0 jour. Si la cl\u00e9 primaire vaut [null], ce sera une insertion sinon ce sera une mise \u00e0 jour\u00a0;</li> <li>ligne 82\u00a0: on utilise la m\u00e9thode [Lists.newArrayList] de la biblioth\u00e8que Guava pour obtenir une liste de produits. La m\u00e9thode [produitsRepository.findAll()] rend un type [Iterable&lt;Produit&gt;]\u00a0;</li> <li>ligne 28\u00a0: la m\u00e9thode [produitsRepository.save(produits)] rend un type [Iterable&lt;Produit&gt;]. Il en est de m\u00eame pour les autres op\u00e9rations [save] de la classe\u00a0; Dans la classe [Dao] ci-dessus, les exceptions qui peuvent se produire sont encapsul\u00e9es dans le type [DaoException] suivant\u00a0:</li> </ul> <pre><code>package spring.data.dao;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// classe d'exception pour l'application Elections\n// l'exception est non contr\u00f4l\u00e9e\n\npublic class DaoException extends RuntimeException implements Serializable {\n\n    // serial ID\n    private static final long serialVersionUID = 1L;\n\n    // champs locaux\n    private int code;\n    private List&lt;String&gt; erreurs;\n\n    // constructeurs\n    public DaoException() {\n        super();\n    }\n\n    public DaoException(int code, Throwable e) {\n        // parent\n        super(e);\n        // local\n        this.code = code;\n        this.erreurs = getErreursForException(e);\n    }\n\n    public DaoException(int code, String message, Throwable e) {\n        // parent\n        super(message, e);\n        // local\n        this.code = code;\n        this.erreurs = getErreursForException(e);\n    }\n\n    public DaoException(int code, String message) {\n        // parent\n        super(message);\n        // local\n        this.code = code;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        erreurs.add(message);\n        this.erreurs = erreurs;\n    }\n\n    public DaoException(int code, List&lt;String&gt; erreurs) {\n        // parent\n        super();\n        // local\n        this.code = code;\n        this.erreurs = erreurs;\n    }\n\n    // liste des messages d'erreur d'une exception\n    private List&lt;String&gt; getErreursForException(Throwable th) {\n        // on r\u00e9cup\u00e8re la liste des messages d'erreur de l'exception\n        Throwable cause = th;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        while (cause != null) {\n            // on r\u00e9cup\u00e8re le message seulement s'il est !=null et non blanc\n            String message = cause.getMessage();\n            if (message != null) {\n                message = message.trim();\n                if (message.length() != 0) {\n                    erreurs.add(message);\n                }\n            }\n            // cause suivante\n            cause = cause.getCause();\n        }\n        return erreurs;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la classe d\u00e9rive de la classe [RuntimeException] et est donc une exception non contr\u00f4l\u00e9e\u00a0;</li> <li>ligne 16\u00a0: un code d'erreur\u00a0;</li> <li>ligne 17\u00a0: une liste de messages d'erreur, ceux associ\u00e9s \u00e0 la pile des exceptions qui ont provoqu\u00e9 la [DaoException]\u00a0;</li> <li>lignes 59-76\u00a0: la m\u00e9thode priv\u00e9e [getMessagesForException] permet d'obtenir la liste des messages d'erreurs associ\u00e9es aux exception de la pile d'exceptions. Il est en effet possible d'empiler les exceptions avec les constructeurs suivants de la classe Exception\u00a0:</li> <li>Exception(String message, Throwable cause)\u00a0: cr\u00e9e une exception avec un message et l'exception qu'on veut encapsuler\u00a0;</li> <li> <p>Exception(Throwable cause)\u00a0: cr\u00e9e une exception avec l'exception qu'on veut encapsuler\u00a0; Le type [Throwable] est la classe parent de la classe [Exception]. Si les constructeurs pr\u00e9c\u00e9dents sont ex\u00e9cut\u00e9s de fa\u00e7on r\u00e9p\u00e9t\u00e9e, l'exception finale contient alors plusieurs exceptions. On dit qu'on a une pile d'exceptions. </p> </li> <li> <p>la derni\u00e8re cause d'une exception e1 est obtenue par l'expression [e1.getCause()]\u00a0;</p> </li> <li>l'avant-derni\u00e8re cause d'une exception e1 est obtenue par l'expression [e1.getCause().getCause()]\u00a0;</li> <li>on poursuit ainsi jusqu'\u00e0 obtenir [getCause()==null]\u00a0;</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1138-configuration-du-projet-spring","title":"11.3.8. Configuration du projet Spring","text":"<p>La classe [DaoConfig] configure la couche [DAO]\u00a0:</p> <pre><code>package spring.data.config;\n\nimport javax.persistence.EntityManagerFactory;\n\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.JpaVendorAdapter;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.orm.jpa.vendor.Database;\nimport org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;\nimport org.springframework.transaction.PlatformTransactionManager;\n\n@EnableJpaRepositories(basePackages = { \"spring.data.repositories\" })\n@Configuration\n@ComponentScan(basePackages = { \"spring.data.dao\" })\npublic class DaoConfig {\n\n    // constantes\n    final static String URL = \"jdbc:mysql://localhost:3306/dbIntroSpringData\";\n    final static String USER = \"root\";\n    final static String PASSWD = \"\";\n    final static String DRIVER_CLASSNAME = \"com.mysql.jdbc.Driver\";\n    final static String[] ENTITIES_PACKAGES = { \"spring.data.entities\" };\n\n    // la source de donn\u00e9es [tomcat-jdbc]\n    @Bean\n    public DataSource dataSource() {\n        // source de donn\u00e9es TomcatJdbc\n        DataSource dataSource = new DataSource();\n        // configuration acc\u00e8s JDBC\n        dataSource.setDriverClassName(DRIVER_CLASSNAME);\n        dataSource.setUsername(USER);\n        dataSource.setPassword(PASSWD);\n        dataSource.setUrl(URL);\n        // une connexion ouverte initialement\n        dataSource.setInitialSize(1);\n        // r\u00e9sultat\n        return dataSource;\n    }\n\n    // le provider JPA\n    @Bean\n    public JpaVendorAdapter jpaVendorAdapter() {\n        HibernateJpaVendorAdapter hibernateJpaVendorAdapter = new HibernateJpaVendorAdapter();\n        hibernateJpaVendorAdapter.setShowSql(false);\n        hibernateJpaVendorAdapter.setDatabase(Database.MYSQL);\n        return hibernateJpaVendorAdapter;\n    }\n\n    // EntityManagerFactory\n    @Bean\n    public EntityManagerFactory entityManagerFactory(JpaVendorAdapter jpaVendorAdapter, DataSource dataSource) {\n        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();\n        factory.setJpaVendorAdapter(jpaVendorAdapter);\n        factory.setPackagesToScan(packagesToScan());\n        factory.setDataSource(dataSource);\n        factory.afterPropertiesSet();\n        return factory.getObject();\n    }\n\n    // Transaction manager\n    @Bean\n    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {\n        JpaTransactionManager txManager = new JpaTransactionManager();\n        txManager.setEntityManagerFactory(entityManagerFactory);\n        return txManager;\n    }\n\n    @Bean\n    public String[] packagesToScan() {\n        return ENTITIES_PACKAGES;\n    }\n\n}\n</code></pre> <p>Une configuration analogue a \u00e9t\u00e9 rencontr\u00e9e et expliqu\u00e9e page 177. Nous y avons ajout\u00e9 les annotations Spring suivantes\u00a0:</p> <ul> <li>ligne 17\u00a0: l'annotation [@EnableJpaRepositories] sert \u00e0 indiquer les packages o\u00f9 se trouvent les interfaces [CrudRepository] de [Spring Data]\u00a0;</li> <li>ligne 18\u00a0: la classe est une classe de configuration Spring. Cette information est importante. Si on l'enl\u00e8ve le projet fonctionne. Mais plus loin dans le document, lorsqu'on construira des projets qui s'appuient sur celui-ci, alors certains d'entre-eux ne fonctionnent plus si l'annotation de la ligne 18 est enlev\u00e9e\u00a0;</li> <li>ligne 19\u00a0: l'annotation [@ComponentScan] indique les packages o\u00f9 se trouvent les objets Spring. Ce sont les classes annot\u00e9es par [@Component, @Service, @Controller, ...]. Ici le composant Spring [Dao] va \u00eatre trouv\u00e9 et instanci\u00e9\u00a0;</li> <li>lignes 73-76\u00a0: nous avons d\u00e9fini un bean qui repr\u00e9sente le tableau des packages \u00e0 scanner pour trouver des entit\u00e9s JPA. Cela permettra \u00e0 un projet qui importe la classe [DaoConfig] de red\u00e9finir ce bean et de changer ainsi les packages scann\u00e9s ligne 59. Plus loin dans le document, nous allons rencontrer cette probl\u00e9matique\u00a0; La classe [AppConfig] configure l'ensemble du projet\u00a0:</li> </ul> <pre><code>package spring.data.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\nimport com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n\n@Configuration\n@Import({DaoConfig.class})\npublic class AppConfig {\n    // filtres jSON\n    @Bean(name = \"jsonMapper\")\n    public ObjectMapper jsonMapper() {\n        return new ObjectMapper();\n    }\n\n    @Bean(name = \"jsonMapperCategorieWithProduits\")\n    public ObjectMapper jsonMapperCategorieWithProduits() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(\n                new SimpleFilterProvider().addFilter(\"jsonFilterCategorie\", SimpleBeanPropertyFilter.serializeAllExcept())\n                        .addFilter(\"jsonFilterProduit\", SimpleBeanPropertyFilter.serializeAllExcept(\"categorie\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperProduitWithCategorie\")\n    public ObjectMapper jsonMapperProduitWithCategorie() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(\n                new SimpleFilterProvider().addFilter(\"jsonFilterProduit\", SimpleBeanPropertyFilter.serializeAllExcept())\n                        .addFilter(\"jsonFilterCategorie\", SimpleBeanPropertyFilter.serializeAllExcept(\"produits\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperCategorieWithoutProduits\")\n    public ObjectMapper jsonMapperCategorieWithoutProduits() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(new SimpleFilterProvider().addFilter(\"jsonFilterCategorie\",\n                SimpleBeanPropertyFilter.serializeAllExcept(\"produits\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n\n    @Bean(name = \"jsonMapperProduitWithoutCategorie\")\n    public ObjectMapper jsonMapperProduitWithoutCategorie() {\n        // mappeur jSON\n        ObjectMapper mapper = new ObjectMapper();\n        // filtres\n        mapper.setFilters(new SimpleFilterProvider().addFilter(\"jsonFilterProduit\",\n                SimpleBeanPropertyFilter.serializeAllExcept(\"categorie\")));\n        // r\u00e9sultat\n        return mapper;\n    }\n}\n</code></pre> <ul> <li>ligne 11\u00a0: la classe est une classe de configuration Spring\u00a0;</li> <li>ligne 12\u00a0: qui importe les beans d\u00e9finis par la classe [DaoConfig] que nous venons de voir\u00a0;</li> <li>la couche [console] utilise des mappeurs jSON qui sont d\u00e9finis ici\u00a0;</li> <li>lignes 14-64\u00a0: d\u00e9finissent cinq mappeurs jSON\u00a0;</li> <li>lignes 15-18\u00a0: le filtre jSON [jsonMapper] n'a pas de filtres\u00a0;</li> <li>lignes 20-30\u00a0: le filtre jSON [jsonMapperCategorieWithProduits] permet de s\u00e9rialiser / d\u00e9s\u00e9rialiser un objet [Categorie] avec ses produits\u00a0;</li> <li>lignes 32-42\u00a0: le filtre jSON [jsonMapperProduitWithCategorie] permet de s\u00e9rialiser / d\u00e9s\u00e9rialiser un objet [Produit] avec sa cat\u00e9gorie\u00a0;</li> <li>lignes 43-53\u00a0: le filtre jSON [jsonMapperCategorieWithoutProduits] permet de s\u00e9rialiser / d\u00e9s\u00e9rialiser un objet [Categorie] sans ses produits\u00a0;</li> <li>lignes 55-64\u00a0: le filtre jSON [jsonMapperProduitWithoutCategorie] permet de s\u00e9rialiser / d\u00e9s\u00e9rialiser un objet [Produit] sans sa cat\u00e9gorie\u00a0; On notera que l'on construit un filtre jSON pour une entit\u00e9 T, on doit configurer non seulement le filtre de l'entit\u00e9 T mais \u00e9galement ceux des entit\u00e9s Ti qu'elle-m\u00eame peut contenir.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#1139-la-couche-console","title":"11.3.9. La couche [console]","text":"<p>Couche[Spring Data]Pilote[JDBC]Couche[JPA]Couche[console]Couche[DAO]Spring 4SGBD</p> <p>La classe [Main] est la suivante\u00a0:</p> <pre><code>package spring.data.console;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.collect.Lists;\n\nimport spring.data.config.AppConfig;\nimport spring.data.dao.DaoException;\nimport spring.data.dao.IDao;\nimport spring.data.entities.Categorie;\nimport spring.data.entities.Produit;\n\npublic class Main {\n\n    public static void main(String[] args) throws JsonProcessingException {\n        AnnotationConfigApplicationContext context = null;\n        try {\n            // instanciation contexte Spring\n            context = new AnnotationConfigApplicationContext(AppConfig.class);\n            ObjectMapper jsonMapperCategorieWithProduits = context.getBean(\"jsonMapperCategorieWithProduits\",\n                    ObjectMapper.class);\n            ObjectMapper jsonMapperProduitWithCategorie = context.getBean(\"jsonMapperProduitWithCategorie\",\n                    ObjectMapper.class);\n            ObjectMapper jsonMapperCategorieWithoutProduits = context.getBean(\"jsonMapperCategorieWithoutProduits\",\n                    ObjectMapper.class);\n            ObjectMapper jsonMapperProduitWithoutCategorie = context.getBean(\"jsonMapperProduitWithoutCategorie\",\n                    ObjectMapper.class);\n            IDao dao = context.getBean(IDao.class);\n            // --------------------------------------------------------------------------------------\n            // on vide la base de donn\u00e9es\n            log(\"Vidage de la base de donn\u00e9es\", 1);\n            // on vide la table [CATEGORIES] - par cascade la table [PRODUITS] va \u00eatre vid\u00e9e\n            dao.deleteAllCategories();\n            // --------------------------------------------------------------------------------------\n            log(\"Remplissage de la base\", 1);\n            // on remplit les tables\n            List&lt;Categorie&gt; categories = new ArrayList&lt;Categorie&gt;();\n            for (int i = 0; i &lt; 2; i++) {\n                Categorie categorie = new Categorie(String.format(\"categorie%d\", i));\n                for (int j = 0; j &lt; 5; j++) {\n                    categorie.addProduit(new Produit(String.format(\"produit%d%d\", i, j), 100 * (1 + (double) (i * 10 + j) / 100),\n                            String.format(\"desc%d%d\", i, j)));\n                }\n                categories.add(categorie);\n            }\n            // ajout de la cat\u00e9gorie - par cascade les produits vont eux aussi \u00eatre ins\u00e9r\u00e9s\n            dao.addCategories(categories);\n            // --------------------------------------------------------------------------------------\n            log(\"Affichage de la base\", 1);\n            // liste des cat\u00e9gories\n            log(\"Liste des cat\u00e9gories\", 2);\n            affiche(dao.getAllCategories(), jsonMapperCategorieWithoutProduits);\n            // liste des produits\n            log(\"Liste des produits\", 2);\n            affiche(dao.getAllProduits(), jsonMapperProduitWithoutCategorie);\n            // cat\u00e9gorie 1 avec ses produits\n            Categorie categorie = dao.getCategorieByNameWithProduits(\"categorie1\");\n            log(\"Cat\u00e9gorie 1 avec ses produits\", 2);\n            affiche(categorie, jsonMapperCategorieWithProduits);\n            // le produit [produit14] avec sa cat\u00e9gorie\n            Produit p = dao.getProduitByNameWithCategorie(\"produit14\");\n            log(\"Produit [produit14] avec sa cat\u00e9gorie\", 2);\n            affiche(p, jsonMapperProduitWithCategorie);\n            // --------------------------------------------------------------------------------------\n            log(\"Mise \u00e0 jour du prix des produits de [categorie1]\", 1);\n            log(\"Produits de la cat\u00e9gorie [categorie1] avant la mise \u00e0 jour\", 2);\n            Categorie categorie1 = dao.getCategorieByNameWithProduits(\"categorie1\");\n            Set&lt;Produit&gt; produits = categorie1.getProduits();\n            affiche(categorie1, jsonMapperCategorieWithProduits);\n            for (Produit produit : produits) {\n                produit.setPrix(1.1 * produit.getPrix());\n            }\n            dao.updateProduits(Lists.newArrayList(produits));\n            log(\"Produits de la cat\u00e9gorie [categorie1] apr\u00e8s la mise \u00e0 jour\", 2);\n            affiche(dao.getCategorieByNameWithProduits(\"categorie1\"), jsonMapperCategorieWithProduits);\n            // --------------------------------------------------------------------------------------\n            log(\"Vidage de la base de donn\u00e9es\", 1);\n            // on vide la table [CATEGORIES] - par cascade la table [PRODUITS] va \u00eatre vid\u00e9e\n            dao.deleteAllCategories();\n            // affichage de la base\n            log(\"Liste des categories avant l'ajout\", 2);\n            affiche(dao.getAllCategories(), jsonMapperCategorieWithoutProduits);\n            log(\"Liste des produits avant l'ajout\", 2);\n            affiche(dao.getAllProduits(), jsonMapperProduitWithoutCategorie);\n            log(\"Ajout d'une cat\u00e9gorie [cat1] avec deux produits de m\u00eame nom\", 1);\n            // on fait l'insertion\n            categorie = new Categorie(\"cat1\");\n            categorie.addProduit(new Produit(\"x\", 1.0, \"\"));\n            categorie.addProduit(new Produit(\"x\", 1.0, \"\"));\n            // ajout de la cat\u00e9gorie - par cascade les produits vont eux aussi \u00eatre ins\u00e9r\u00e9s\n            try {\n                dao.addCategories(Lists.newArrayList(categorie));\n            } catch (DaoException e) {\n                System.out.println(e);\n            }\n            // v\u00e9rification\n            log(\"Liste des categories apr\u00e8s l'ajout\", 2);\n            affiche(dao.getAllCategories(), jsonMapperCategorieWithoutProduits);\n            log(\"Liste des produits apr\u00e8s l'ajout\", 2);\n            affiche(dao.getAllProduits(), jsonMapperProduitWithoutCategorie);\n        } catch (DaoException e) {\n            System.out.println(e);\n        } finally {\n            if (context != null) {\n                // fini\n                context.close();\n            }\n        }\n        System.out.println(\"Travail termin\u00e9\");\n    }\n\n    // affichage d'un \u00e9l\u00e9ment de type T\n    static private &lt;T&gt; void affiche(T element, ObjectMapper jsonMapper) throws JsonProcessingException {\n        System.out.println(jsonMapper.writeValueAsString(element));\n    }\n\n    // affichage d'une liste d'\u00e9l\u00e9ments de type T\n    static private &lt;T&gt; void affiche(List&lt;T&gt; elements, ObjectMapper jsonMapper) throws JsonProcessingException {\n        for (T element : elements) {\n            affiche(element, jsonMapper);\n        }\n    }\n\n    private static void log(String message, int mode) {\n        // affiche message\n        String toPrint = null;\n        switch (mode) {\n        case 1:\n            toPrint = String.format(\"%s --------------------------------\", message);\n            break;\n        case 2:\n            toPrint = String.format(\"-- %s\", message);\n            break;\n        }\n        System.out.println(toPrint);\n    }\n}\n</code></pre> <ul> <li>ligne 25\u00a0: instanciation des beans Spring \u00e0 partir de la classe de configuration [AppConfig]\u00a0;</li> <li>lignes 26-33\u00a0: r\u00e9cup\u00e9ration des r\u00e9f\u00e9rences sur les mappeurs jSON. On utilise la signature suivante de la m\u00e9thode [ApplicationContext].getBean\u00a0:</li> <li>[ApplicationContext].getBean(String id, Class classe)\u00a0: qu'on utilise lorsqu'il y a plusieurs beans ayant le type [classe]. Dans ce cas, on pr\u00e9cise l'identifiant du bean demand\u00e9. Si celui-ci a \u00e9t\u00e9 d\u00e9fini avec l'annotation [@Bean], son identifiant est le nom de la m\u00e9thode annot\u00e9e. S'il a \u00e9t\u00e9 d\u00e9fini avec l'annotation [@Bean(\u00ab\u00a0identifiant\u00a0\u00bb], son identifiant est celui indiqu\u00e9 dans l'annotation\u00a0;</li> <li>ligne 34\u00a0: r\u00e9cup\u00e9ration d'une r\u00e9f\u00e9rence sur la couche [DAO]\u00a0;</li> <li>lignes 37-39\u00a0: vidage de la base de donn\u00e9es. On vide la table des cat\u00e9gories (ligne 39). Parce qu'on a \u00e9crit\u00a0: <pre><code>    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"categorie\", cascade = { CascadeType.ALL })\n    public Set&lt;Produit&gt; produits = new HashSet&lt;Produit&gt;();\n</code></pre></li> </ul> <p>lorsqu'une cat\u00e9gorie est supprim\u00e9e, tous les produits qui lui sont li\u00e9s le sont aussi\u00a0;</p> <ul> <li>lignes 43-53\u00a0: remplissage de la table avec 2 cat\u00e9gories de 5 produits chacune. Ligne 50, l'insertion des deux cat\u00e9gories va provoquer en m\u00eame temps l'insertion de leurs produits, toujours parce qu'on a \u00e9crit [cascade = { CascadeType.ALL }]\u00a0;</li> <li>ligne 58\u00a0: on affiche les cat\u00e9gories. On utilise le mappeur jSON [jsonMapperCategorieWithoutProduits] pour afficher les cat\u00e9gories sans leurs produits. En effet la m\u00e9thode [dao.getAllCategories()] rend les cat\u00e9gories sans leurs produits (lazy loading)\u00a0;</li> <li>ligne 61\u00a0: on affiche les produits sans leur cat\u00e9gorie. En effet la m\u00e9thode [dao.getAllProduits()] rend les produits sans leur cat\u00e9gorie (lazy loading)\u00a0;</li> <li>lignes 63-65\u00a0: affichent la cat\u00e9gorie de nom [categorie1] avec ses produits (eager loading)\u00a0;</li> <li>lignes 67-69\u00a0: affiche un produit avec sa cat\u00e9gorie\u00a0;</li> <li>lignes 71-81\u00a0: on augmente de 10% tous les prix des produits de la cat\u00e9gorie [categorie1]\u00a0;</li> <li>lignes 91-101\u00a0: on ajoute une cat\u00e9gorie avec deux produits de m\u00eame nom. Or dans la table [PRODUITS] on a une contrainte d'unicit\u00e9 sur la colonne [NOM]. L'insertion du 2i\u00e8me produit va donc \u00eatre rejet\u00e9e et une exception lanc\u00e9e. Or la m\u00e9thode [dao.addProduits] s'ex\u00e9cute dans une transaction. Le fait que la seconde insertion \u00e9choue doit donc \u00e9galement annuler l'insertion du premier produit ainsi que celle de leur cat\u00e9gorie [cat1]. C'est ce qu'on veut v\u00e9rifier\u00a0;</li> <li>lignes 119-121\u00a0: une m\u00e9thode g\u00e9n\u00e9rique capable d'afficher la cha\u00eene jSON de tout \u00e9l\u00e9ment de type T. La s\u00e9rialisation jSON est contr\u00f4l\u00e9e par le mappeur pass\u00e9 en param\u00e8tre\u00a0;</li> <li>lignes 124-128\u00a0: une m\u00e9thode analogue, cette-fois pour une liste d'\u00e9l\u00e9ments de type T\u00a0; L'ex\u00e9cution de la classe [Main] donne les r\u00e9sultats suivants (hors logs de Spring)\u00a0:</li> </ul> <pre><code>Vidage de la base de donn\u00e9es --------------------------------\nRemplissage de la base --------------------------------\nAffichage de la base --------------------------------\n-- Liste des cat\u00e9gories\n{\"id\":4,\"version\":0,\"nom\":\"categorie0\"}\n{\"id\":5,\"version\":0,\"nom\":\"categorie1\"}\n-- Liste des produits\n{\"id\":13,\"version\":0,\"nom\":\"produit00\",\"idCategorie\":4,\"prix\":100.0,\"description\":\"desc00\"}\n{\"id\":14,\"version\":0,\"nom\":\"produit01\",\"idCategorie\":4,\"prix\":101.0,\"description\":\"desc01\"}\n{\"id\":15,\"version\":0,\"nom\":\"produit02\",\"idCategorie\":4,\"prix\":102.0,\"description\":\"desc02\"}\n{\"id\":16,\"version\":0,\"nom\":\"produit03\",\"idCategorie\":4,\"prix\":103.0,\"description\":\"desc03\"}\n{\"id\":17,\"version\":0,\"nom\":\"produit04\",\"idCategorie\":4,\"prix\":104.0,\"description\":\"desc04\"}\n{\"id\":18,\"version\":0,\"nom\":\"produit10\",\"idCategorie\":5,\"prix\":110.0,\"description\":\"desc10\"}\n{\"id\":19,\"version\":0,\"nom\":\"produit11\",\"idCategorie\":5,\"prix\":111.0,\"description\":\"desc11\"}\n{\"id\":20,\"version\":0,\"nom\":\"produit12\",\"idCategorie\":5,\"prix\":112.0,\"description\":\"desc12\"}\n{\"id\":21,\"version\":0,\"nom\":\"produit13\",\"idCategorie\":5,\"prix\":113.0,\"description\":\"desc13\"}\n{\"id\":22,\"version\":0,\"nom\":\"produit14\",\"idCategorie\":5,\"prix\":114.0,\"description\":\"desc14\"}\n-- Cat\u00e9gorie 1 avec ses produits\n{\"id\":5,\"version\":0,\"nom\":\"categorie1\",\"produits\":[{\"id\":18,\"version\":0,\"nom\":\"produit10\",\"idCategorie\":5,\"prix\":110.0,\"description\":\"desc10\"},{\"id\":19,\"version\":0,\"nom\":\"produit11\",\"idCategorie\":5,\"prix\":111.0,\"description\":\"desc11\"},{\"id\":20,\"version\":0,\"nom\":\"produit12\",\"idCategorie\":5,\"prix\":112.0,\"description\":\"desc12\"},{\"id\":21,\"version\":0,\"nom\":\"produit13\",\"idCategorie\":5,\"prix\":113.0,\"description\":\"desc13\"},{\"id\":22,\"version\":0,\"nom\":\"produit14\",\"idCategorie\":5,\"prix\":114.0,\"description\":\"desc14\"}]}\n-- Produit [produit14] avec sa cat\u00e9gorie\n{\"id\":22,\"version\":0,\"nom\":\"produit14\",\"idCategorie\":5,\"prix\":114.0,\"description\":\"desc14\",\"categorie\":{\"id\":5,\"version\":0,\"nom\":\"categorie1\"}}\nMise \u00e0 jour du prix des produits de [categorie1] --------------------------------\n-- Produits de la cat\u00e9gorie [categorie1] avant la mise \u00e0 jour\n{\"id\":5,\"version\":0,\"nom\":\"categorie1\",\"produits\":[{\"id\":18,\"version\":0,\"nom\":\"produit10\",\"idCategorie\":5,\"prix\":110.0,\"description\":\"desc10\"},{\"id\":19,\"version\":0,\"nom\":\"produit11\",\"idCategorie\":5,\"prix\":111.0,\"description\":\"desc11\"},{\"id\":20,\"version\":0,\"nom\":\"produit12\",\"idCategorie\":5,\"prix\":112.0,\"description\":\"desc12\"},{\"id\":21,\"version\":0,\"nom\":\"produit13\",\"idCategorie\":5,\"prix\":113.0,\"description\":\"desc13\"},{\"id\":22,\"version\":0,\"nom\":\"produit14\",\"idCategorie\":5,\"prix\":114.0,\"description\":\"desc14\"}]}\n-- Produits de la cat\u00e9gorie [categorie1] apr\u00e8s la mise \u00e0 jour\n{\"id\":5,\"version\":0,\"nom\":\"categorie1\",\"produits\":[{\"id\":18,\"version\":1,\"nom\":\"produit10\",\"idCategorie\":5,\"prix\":121.0,\"description\":\"desc10\"},{\"id\":19,\"version\":1,\"nom\":\"produit11\",\"idCategorie\":5,\"prix\":122.1,\"description\":\"desc11\"},{\"id\":20,\"version\":1,\"nom\":\"produit12\",\"idCategorie\":5,\"prix\":123.2,\"description\":\"desc12\"},{\"id\":21,\"version\":1,\"nom\":\"produit13\",\"idCategorie\":5,\"prix\":124.3,\"description\":\"desc13\"},{\"id\":22,\"version\":1,\"nom\":\"produit14\",\"idCategorie\":5,\"prix\":125.4,\"description\":\"desc14\"}]}\nVidage de la base de donn\u00e9es --------------------------------\n-- Liste des categories avant l'ajout\n-- Liste des produits avant l'ajout\nAjout d'une cat\u00e9gorie [cat1] avec deux produits de m\u00eame nom --------------------------------\nLes erreurs suivantes se sont produites : \n- org.hibernate.exception.ConstraintViolationException: could not execute statement\n- could not execute statement\n- Duplicate entry 'x' for key 'NOM'\n-- Liste des categories apr\u00e8s l'ajout\n-- Liste des produits apr\u00e8s l'ajout\nTravail termin\u00e9\n</code></pre> <ul> <li>lignes 4-17\u00a0: les cat\u00e9gories et produits ins\u00e9r\u00e9s dans la table\u00a0;</li> <li>lignes 18-19\u00a0: une cat\u00e9gorie avec ses produits\u00a0;</li> <li>lignes 20-21\u00a0: un produit avec sa cat\u00e9gorie\u00a0;</li> <li>lignes 22-26\u00a0: mise \u00e0 jour du prix de certains produits. Ligne 24, on voit que les prix ont bien augment\u00e9 de 10%\u00a0;</li> <li>lignes 27-36\u00a0: ajout de la cat\u00e9gorie [cat1] avec deux produits de m\u00eame nom. On voit que la table est la m\u00eame avant (lignes 28-29) et apr\u00e8s ajout (lignes 35-36) montrant par l\u00e0 que toutes les insertions de la transaction ont bien \u00e9t\u00e9 annul\u00e9es\u00a0;</li> <li>lignes 31-34\u00a0: l'exception qui s'est produite lors de l'insertion du second produit et qui a fait \u00e9chouer toute la transaction\u00a0;</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#11310-le-test-unitaire-junit","title":"11.3.10. Le test unitaire JUnit","text":"<p>La classe [Test01] est la suivante\u00a0:</p> <pre><code>package spring.data.tests;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.collect.Lists;\n\nimport spring.data.config.AppConfig;\nimport spring.data.dao.DaoException;\nimport spring.data.dao.IDao;\nimport spring.data.entities.Categorie;\nimport spring.data.entities.Produit;\n\n@SpringApplicationConfiguration(classes = AppConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // couche [DAO]\n    @Autowired\n    private IDao dao;\n\n    // filtres jSON\n    @Autowired\n    @Qualifier(\"jsonMapper\")\n    private ObjectMapper jsonMapper;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithProduits\")\n    private ObjectMapper jsonMapperCategorieWithProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithCategorie\")\n    private ObjectMapper jsonMapperProduitWithCategorie;\n    @Autowired\n    @Qualifier(\"jsonMapperCategorieWithoutProduits\")\n    private ObjectMapper jsonMapperCategorieWithoutProduits;\n    @Autowired\n    @Qualifier(\"jsonMapperProduitWithoutCategorie\")\n    private ObjectMapper jsonMapperProduitWithoutCategorie;\n\n    @Before\n    public void cleanAndFill() {\n        // on nettoie la base avant chaque test\n        log(\"Vidage de la base de donn\u00e9es\", 1);\n        // on vide la table [CATEGORIES] - par cascade la table [PRODUITS] va \u00eatre vid\u00e9e\n        dao.deleteAllCategories();\n        // --------------------------------------------------------------------------------------\n        log(\"Remplissage de la base\", 1);\n        // on remplit les tables\n        List&lt;Categorie&gt; categories = new ArrayList&lt;Categorie&gt;();\n        for (int i = 0; i &lt; 2; i++) {\n            Categorie categorie = new Categorie(String.format(\"categorie%d\", i));\n            for (int j = 0; j &lt; 5; j++) {\n                categorie.addProduit(new Produit(String.format(\"produit%d%d\", i, j), 100 * (1 + (double) (i * 10 + j) / 100),\n                        String.format(\"desc%d%d\", i, j)));\n            }\n            categories.add(categorie);\n        }\n        // ajout de la cat\u00e9gorie - par cascade les produits vont eux aussi \u00eatre ins\u00e9r\u00e9s\n        categories = dao.addCategories(categories);\n    }\n\n    @Test\n    public void showDataBase() throws BeansException, JsonProcessingException {\n        // liste des cat\u00e9gories\n        log(\"Liste des cat\u00e9gories\", 2);\n        List&lt;Categorie&gt; categories = dao.getAllCategories();\n        affiche(categories, jsonMapperCategorieWithoutProduits);\n        // liste des produits\n        log(\"Liste des produits\", 2);\n        List&lt;Produit&gt; produits = dao.getAllProduits();\n        affiche(produits, jsonMapperProduitWithoutCategorie);\n        // quelques v\u00e9rifications\n        Assert.assertEquals(2, categories.size());\n        Assert.assertEquals(10, produits.size());\n        Categorie categorie = findCategorieByName(\"categorie0\", categories);\n        Assert.assertNotNull(categorie);\n        Produit produit = findProduitByName(\"produit03\", produits);\n        Assert.assertNotNull(produit);\n        Long idCategorie = produit.getIdCategorie();\n        Assert.assertEquals(categorie.getId(), idCategorie);\n    }\n\n    @Test\n    public void getCategorieByNameWithProduits() {\n        log(\"getCategorieByNameWithProduits\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithProduits(\"categorie1\");\n        Assert.assertNotNull(categorie1);\n        Assert.assertEquals(5, categorie1.getProduits().size());\n    }\n\n    @Test\n    public void getCategorieByNameWithoutProduits() {\n        log(\"getCategorieByNameWithoutProduits\", 1);\n        Categorie categorie1 = dao.getCategorieByNameWithoutProduits(\"categorie1\");\n        Assert.assertNotNull(categorie1);\n        Assert.assertEquals(\"categorie1\", categorie1.getNom());\n    }\n\n    @Test\n    public void getProduitByIdWithCategorie() {\n        log(\"getProduitByNameWithCategorie\", 1);\n        Produit produit = dao.getProduitByNameWithCategorie(\"produit03\");\n        Produit produit2 = dao.getProduitByIdWithCategorie(produit.getId());\n        Assert.assertNotNull(produit2);\n        Assert.assertEquals(produit2.getNom(), produit.getNom());\n        Assert.assertEquals(produit2.getId(), produit.getId());\n        Assert.assertEquals(produit.getCategorie().getId(), produit2.getCategorie().getId());\n    }\n\n    @Test\n    public void getProduitByIdWithoutCategorie() {\n        log(\"getProduitByIdWithoutCategorie\", 1);\n        Produit produit = dao.getProduitByNameWithCategorie(\"produit03\");\n        Produit produit2 = dao.getProduitByIdWithoutCategorie(produit.getId());\n        Assert.assertNotNull(produit2);\n        Assert.assertEquals(produit2.getNom(), produit.getNom());\n        Assert.assertEquals(produit2.getId(), produit.getId());\n    }\n...\n    // -------------- m\u00e9thodes priv\u00e9es\n    private Produit findProduitByName(String nom, List&lt;Produit&gt; produits) {\n        for (Produit produit : produits) {\n            if (produit.getNom().equals(nom)) {\n                return produit;\n            }\n        }\n        return null;\n    }\n\n    private Categorie findCategorieByName(String nom, List&lt;Categorie&gt; categories) {\n        for (Categorie categorie : categories) {\n            if (categorie.getNom().equals(nom)) {\n                return categorie;\n            }\n        }\n        return null;\n    }\n\n    // affichage d'un \u00e9l\u00e9ment de type T\n    static private &lt;T&gt; void affiche(T element, ObjectMapper jsonMapper) throws JsonProcessingException {\n        System.out.println(jsonMapper.writeValueAsString(element));\n    }\n\n    // affichage d'une liste d'\u00e9l\u00e9ments de type T\n    static private &lt;T&gt; void affiche(List&lt;T&gt; elements, ObjectMapper jsonMapper) throws JsonProcessingException {\n        for (T element : elements) {\n            affiche(element, jsonMapper);\n        }\n    }\n\n    private static void log(String message, int mode) {\n        // affiche message\n        String toPrint = null;\n        switch (mode) {\n        case 1:\n            toPrint = String.format(\"%s --------------------------------\", message);\n            break;\n        case 2:\n            toPrint = String.format(\"-- %s\", message);\n            break;\n        }\n        System.out.println(toPrint);\n    }\n\n    private static void show(String title, List&lt;String&gt; messages) {\n        // titre\n        System.out.println(String.format(\"%s : \", title));\n        // messages\n        for (String message : messages) {\n            System.out.println(String.format(\"- %s\", message));\n        }\n    }\n\n}\n</code></pre> <ul> <li>ligne 27\u00a0: le test unitaire est configur\u00e9 par la classe [AppConfig] d\u00e9j\u00e0 pr\u00e9sent\u00e9e au paragraphe 11.3.8, page 198\u00a0;</li> <li>lignes 32-33\u00a0: injection  d'une r\u00e9f\u00e9rence sur la couche [DAO]\u00a0;</li> <li>lignes 36-50\u00a0: injection des cinq mappeurs jSON\u00a0;</li> <li>lignes 60-71\u00a0: apr\u00e8s avoir vid\u00e9 la base (ligne 57), on remplit la base de donn\u00e9es avec 2 cat\u00e9gories contenant chacune 5 produits. Cette m\u00e9thode est ex\u00e9cut\u00e9e avant chaque test \u00e0 cause de l'annotation [@Before] de la ligne 52\u00a0;</li> <li>lignes 75-93\u00a0: affiche le contenu de la base\u00a0;</li> <li>lignes 95-101\u00a0: demande une cat\u00e9gorie avec ses produits, cat\u00e9gorie identifi\u00e9e par son nom\u00a0;</li> <li>lignes 103-109\u00a0: demande une cat\u00e9gorie sans ses produits, cat\u00e9gorie identifi\u00e9e par son nom\u00a0;</li> <li>lignes 111-120\u00a0: demande un produit avec sa cat\u00e9gorie, produit identifi\u00e9 par son n\u00b0\u00a0;</li> <li>lignes 122-130\u00a0: demande un produit sans sa cat\u00e9gorie, produit identifi\u00e9 par son n\u00b0\u00a0;</li> <li>lignes 133-184\u00a0: des m\u00e9thodes priv\u00e9es partag\u00e9es par les diff\u00e9rents tests\u00a0; Travail \u00e0 faire\u00a0: ex\u00e9cutez le test. Il doit r\u00e9ussir.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#11311-gestion-des-logs","title":"11.3.11. Gestion des logs","text":"<p>Les logs de l'application console ou du test JUnit sont configur\u00e9s par le fichier [logback.xml] suivant\u00a0:</p> <p>Le fichier doit s'appeler [logback.xml] et \u00eatre dans le Classpath du projet. Pour cela, il a \u00e9t\u00e9 plac\u00e9 ici dans le dossier [src/main/resources] qui fait partie du Classpath. Son contenu est le suivant\u00a0:</p> <pre><code>&lt;configuration&gt; \n\n  &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; \n    &lt;!-- encoders are  by default assigned the type\n         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;\n    &lt;encoder&gt;\n      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n    &lt;/encoder&gt;\n  &lt;/appender&gt;\n\n  &lt;!-- contr\u00f4le niveau des logs --&gt;\n  &lt;root level=\"info\"&gt; &lt;!-- info, debug, warn --&gt;\n    &lt;appender-ref ref=\"STDOUT\" /&gt;\n  &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <ul> <li>ligne 12\u00a0: la balise [&lt;root level=\"info\"&gt;] affiche les logs de niveau [info]. A la place de [info], on peut mettre\u00a0:</li> <li>[debug]\u00a0: c'est le niveau le plus d\u00e9taill\u00e9 de logs. Il est conseill\u00e9 de l'utiliser pendant la phase de d\u00e9bogage du projet car il y a des logs tr\u00e8s int\u00e9ressants sur les \u00e9changes client / serveur. C'est une fa\u00e7on de comprendre ce qui se passe 'sous le capot'\u00a0;</li> <li>[off]\u00a0: pas de logs du tout\u00a0;</li> <li>[warn]\u00a0: un niveau de logs interm\u00e9diaire o\u00f9 Spring affiche des anomalies qui ne pas pour autant des erreurs. Il faut les regarder si on n'obtient pas le r\u00e9sultat escompt\u00e9\u00a0; Travail \u00e0 faire\u00a0: passez le niveau de la ligne 12 \u00e0 [debug] puis ex\u00e9cutez le test unitaire. Regardez la diff\u00e9rence de logs.</li> </ul>"},{"location":"cours-gestion-des-bases-de-donnees-relationnelles-avec-spring-data.html#11312-generation-de-larchive-maven-du-projet","title":"11.3.12. G\u00e9n\u00e9ration de l'archive Maven du projet","text":"<p>Pour installer l'archive du projet dans le d\u00e9p\u00f4t local Maven, proc\u00e9dez comme suit [1-3]\u00a0:</p> <p>L'archive va \u00eatre g\u00e9n\u00e9r\u00e9e avec les identifiants trouv\u00e9s dans le fichier [pom.xml]\u00a0:</p> <pre><code>    &lt;groupId&gt;istia.st.springdata&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-spring-data-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;packaging&gt;jar&lt;/packaging&gt;\n</code></pre> <p>La localisation du d\u00e9p\u00f4t local Maven peut \u00eatre trouv\u00e9 dans la configuration d'Eclipse\u00a0:</p> <p>Il est alors possible de v\u00e9rifier la bonne installation de l'artifact Maven\u00a0:</p> <p>D\u00e9sormais, un autre projet Maven local pourra utiliser cette archive.</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html","title":"6. [Cours]\u00a0: Introduction \u00e0 l'API JDBC","text":"<p>Mots cl\u00e9s : bases de donn\u00e9es relationnelles, API JDBC, SQLException.</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#61-support","title":"6.1. Support","text":"<p>Le dossier [support / chap-06] contient les projets Eclipse de ce chapitre.</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#62-architecture","title":"6.2. Architecture","text":"<p>La couche JDBC (Java DataBase Connectivity) est une interface d'acc\u00e8s universelle aux bases de donn\u00e9es. Elle pr\u00e9sente toujours la m\u00eame interface \u00e0 la couche [DAO]. Si on change de SGBD, il suffit de changer le pilote JDBC. La couche [DAO] ne change pas.</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#63-les-etapes-dexploitation-dune-base-de-donnees","title":"6.3. Les \u00e9tapes d'exploitation d'une base de donn\u00e9es","text":"<p>Dans l'architecture ci-dessus, l'exploitation d'une base de donn\u00e9es par le programme console comporte les \u00e9tapes suivantes\u00a0:</p> <ul> <li>chargement du pilote JDBC de la base de donn\u00e9es\u00a0;</li> <li>ouverture d'une connexion avec la base\u00a0;</li> <li>\u00e9mission d'un ordre SQL sur la base et traitement des r\u00e9sultats de l'ordre SQL\u00a0;</li> <li>fermeture de la connexion\u00a0; L'\u00e9tape 1 ne se fait qu'une fois. Les \u00e9tapes 2-4 se font de fa\u00e7on r\u00e9p\u00e9t\u00e9e. On notera qu'on ne laisse pas une connexion ouverte. On la ferme d\u00e8s qu'on en n'a plus besoin.</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#631-etape-1-chargement-en-memoire-du-pilote-jdbc","title":"6.3.1. \u00e9tape 1 - chargement en m\u00e9moire du pilote JDBC","text":"<p>Le code</p> <pre><code>        // chargement du pilote JDBC\n        try {\n            Class.forName(nom de la classe du pilote JDBC);\n        } catch (ClassNotFoundException e1) {\n            // traiter l'exception\n}\n</code></pre> <p>L'op\u00e9ration de la ligne 3 a pour but de charger en m\u00e9moire le pilote JDBC de la base de donn\u00e9es. Cette op\u00e9ration n'a besoin d'\u00eatre faite qu'une fois. La r\u00e9p\u00e9ter ne cause cependant pas d'erreur. La classe du pilote JDBC est cherch\u00e9e dans le Classpath du projet. Il faut donc que dans le projet Eclipse, le [jar] contenant la classe du pilote JDBC ait \u00e9t\u00e9 inclus dans le Classpath du projet.</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#632-etape-2-ouverture-dune-connexion","title":"6.3.2. \u00e9tape 2 - ouverture d'une connexion","text":"<p>Une fois le pilote JDBC en place, on lui demande d'ouvrir une connexion avec la BD\u00a0:</p> <p>Le code</p> <pre><code>package spring.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class IntroJdbc01 {\n\n...\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n...\n        } catch (SQLException e1) {\n            // on traite l'exception\n            ...\n        } finally {\n         // fermer la connexion\n         if (connexion != null) {\n            try {\n                connexion.close();\n            } catch (SQLException e2) {\n                // traiter l'exception\n                ...\n            }\n         }\n}\n</code></pre> <ul> <li>lignes 3-7\u00a0: les classes d'impl\u00e9mentation de l'interface JDBC sont toutes dans le package [java.sql]. Par ailleurs, en cas d'erreur elles lancent toutes une exception de type [SQLException] (ligne 19, 27). Cette exception d\u00e9rive de la classe [Exception] et est une exception dite contr\u00f4l\u00e9e\u00a0: on est oblig\u00e9 de mettre un try / catch pour la g\u00e9rer ou de fa\u00e7on alternative de ne pas la g\u00e9rer et d'indiquer que la m\u00e9thode laisse sortir l'exception en compl\u00e9tant la signature de la m\u00e9thode par [throws SQLException]\u00a0;</li> <li>ligne 17, [DriverManager.getConnection] est une m\u00e9thode statique qui attend trois param\u00e8tres\u00a0:</li> <li>[url] : l'URL de la base de donn\u00e9es. C'est une cha\u00eene de caract\u00e8res d\u00e9pendante de la BD utilis\u00e9e. Pour MySQL, elle est de la forme [jdbc:mysql://localhost:3306/nom_de_la_bd];</li> <li>[user]\u00a0: le propri\u00e9taire de la connexion\u00a0;</li> <li>[passwd]\u00a0: son mot de passe\u00a0;</li> <li>lignes 24-30\u00a0: la connexion doit \u00eatre ferm\u00e9e dans la clause [finally] afin qu'elle soit ferm\u00e9e qu'il y ait exception ou non.</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#633-etape-3-emission-dordres-sql-select","title":"6.3.3. \u00e9tape 3 - \u00e9mission d'ordres SQL [SELECT]","text":"<p>Une fois obtenue une connexion, on peut \u00e9mettre des ordres SQL. La fa\u00e7on de g\u00e9rer des ordres de lecture [SELECT] diff\u00e8re de celle utilis\u00e9e pour les op\u00e9rations de mise \u00e0 jour [UPDATE, INSERT, DELETE]. Nous commen\u00e7ons par les ordres SQL [SELECT]\u00a0:</p> <p>Le code</p> <pre><code>Connection connexion = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // en mode lecture seule\n            connexion.setReadOnly(true);\n            // on lit la table [PRODUITS]\n            ps = connexion.prepareStatement(\"SELECT ID, NOM, CATEGORIE, PRIX, DESCRIPTION FROM PRODUITS\");\n            rs = ps.executeQuery();\n            System.out.println(\"Liste des produits : \");\n            while (rs.next()) {\n                System.out.println(new Produit(rs.getInt(1), rs.getString(2), rs.getInt(3), rs.getDouble(4), rs.getString(5)));\n            }\n            // commit transaction\n            connexion.commit();\n        } catch (SQLException e1) {\n            // on traite l'exception\n             doCatchException(connexion,e1);\n        } finally {\n            // on traite le finally\n            doFinally(rs, ps, connexion);\n        }\n\n    private void doFinally(ResultSet rs, PreparedStatement ps, Connection connexion) {\n....\n}\n</code></pre> <ul> <li>lignes 8, 10\u00a0: ouverture d'une transaction (ligne 8) en mode lecture seule (ligne 10). Une transaction est une s\u00e9quence d'ordes SQL qui soit tous r\u00e9ussissent soit tous \u00e9chouent. Ainsi dans une transaction comportant N ordres SQL, si l'ordre I+1 \u00e9choue, alors les I pr\u00e9c\u00e9dents seront annul\u00e9s. Pour une op\u00e9ration de lecture, une transaction n'est pas n\u00e9cessaire. N\u00e9anmoins cr\u00e9er une transaction en lecture seule peut permettre \u00e0 certains SGBD de faire certaines optimisations\u00a0;</li> <li>ligne 12\u00a0: utilisation d'un [PreparedStatement]. Un [PreparedStatement] a normalement des param\u00e8tres not\u00e9s par le caract\u00e8re\u00a0?. Ici il n'en a pas. Un [PreparedStatement] est un ordre pr\u00e9par\u00e9 par le SGBD. Cette pr\u00e9paration a un co\u00fbt et elle n'est faite qu'une fois. Ensuite cet ordre pr\u00e9par\u00e9 est ex\u00e9cut\u00e9 par le SGBD avec diff\u00e9rents param\u00e8tres effectifs qui vont venir remplacer les param\u00e8tres formels\u00a0?. A noter qu'il est pr\u00e9f\u00e9rable de nommer les colonnes d\u00e9sir\u00e9es plut\u00f4t que d'utiliser la notation * pour obtenir toutes les colonnes. En pr\u00e9cisant le nom des colonnes on peut ensuite obtenir leurs valeurs \u00e0 partir de leur position dans la requ\u00eate SELECT\u00a0;</li> <li>ligne 13\u00a0: ex\u00e9cution du [PreparedStatement]. On r\u00e9cup\u00e8re un objet de type [ResultSet]\u00a0; Un objet de type [ResultSet] repr\u00e9sente une table, c\u2019est \u00e0 dire un ensemble de lignes et de colonnes. A un moment donn\u00e9, on n\u2019a acc\u00e8s qu\u2019\u00e0 une ligne de la table appel\u00e9e ligne courante. Lors de la cr\u00e9ation initiale du [ResultSet], il n'y a pas de ligne courante. Il faut faire une op\u00e9ration [ResultSet.next()] pour l'obtenir. La signature de la m\u00e9thode next est la suivante :</li> </ul> <pre><code>    boolean next()\n</code></pre> <p>Cette m\u00e9thode tente de passer \u00e0 la ligne suivante du [ResultSet] et rend true si elle r\u00e9ussit, false sinon. En cas de r\u00e9ussite, la ligne suivante devient la nouvelle ligne courante. La ligne pr\u00e9c\u00e9dente est perdue et on ne pourra revenir en arri\u00e8re pour la r\u00e9cup\u00e9rer.</p> <p>La table du [ResultSet] a des colonnes nomm\u00e9es labelCol1, labelCol2,... pr\u00e9cis\u00e9es dans la requ\u00eate [SELECT] ex\u00e9cut\u00e9e. Avec la requ\u00eate\u00a0:</p> <pre><code>SELECT ID as myId, NOM as myNom, CATEGORIE as myCategorie, PRIX as myPrix, DESCRIPTION as myDescription FROM PRODUITS\n</code></pre> <ul> <li>la colonne [ID] ira dans une colonne du [ResultSet] nomm\u00e9e [myId]\u00a0;</li> <li>la colonne [NOM] ira dans une colonne du [ResultSet] nomm\u00e9e [myNom]\u00a0;</li> <li>... Ci-dessus, les identifiants [myCol] sont appel\u00e9s des labels de colonne. En l'absence de ces labels, les noms des colonnes du [ResultSet] sont d\u00e9pendants du SGBD. Lorsque le [SELECT] op\u00e8re sur une unique table, les labels des colonnes seront par d\u00e9faut les noms des colonnes demand\u00e9es par le SELECT. Le probl\u00e8me surgit lorsque le [SELECT] op\u00e8re sur plusieurs tables et que dans celles-ci on trouve des noms de colonnes identiques comme dans l'exemple suivant\u00a0:</li> </ul> <pre><code>SELECT PRODUITS.NOM, CATEGORIES.NOM FROM PRODUITS, CATEGORIES WHERE PRODUITS.CATEGORIE_ID=CATEGORIES.ID\n</code></pre> <p>en imaginant que la table [PRODUITS] ait une cl\u00e9 \u00e9trang\u00e8re vers la table [CATEGORIES] symbolis\u00e9e par la relation [Produits].CATEGORIE_ID --&gt; [CATEGORIES].ID, et que les tables [PRODUITS] et [CATEGORIES] aient toutes les deux un champ [NOM]. Dans ce cas, les noms donn\u00e9s dans le [ResultSet] aux colonnes [PRODUITS.NOM] et [CATEGORIES.NOM] sont d\u00e9pendants du SGBD. Pour la portabilit\u00e9 entre SGBD, il faut donc utiliser des labels de colonnes ici et on \u00e9crira\u00a0:</p> <pre><code>SELECT PRODUITS.NOM as p_NOM, CATEGORIES.NOM as c_NOM FROM PRODUITS, CATEGORIES WHERE PRODUITS.CATEGORIE_ID=CATEGORIES.ID\n</code></pre> <p>Pour exploiter les diff\u00e9rents champs de la ligne courante du [ResultSet], on dispose des m\u00e9thodes suivantes :</p> <pre><code>Type getType(\"labelColi\") \n</code></pre> <p>pour obtenir la colonne nomm\u00e9e \u00ablabelColi\u00bb de la ligne courante et donc la colonne du [SELECT] ayant ce label. Type d\u00e9signe le type du champ coli. On peut utiliser les m\u00e9thodes [getType] suivantes\u00a0: getInt, getLong, getString, getDouble, getFloat, getDate, ... Au lieu d'utiliser le nom de la colonne, on peut utiliser sa position dans la requ\u00eate [SELECT] ex\u00e9cut\u00e9e\u00a0:</p> <pre><code>Type getType(i) \n</code></pre> <p>o\u00f9 i est l\u2019indice de la colonne d\u00e9sir\u00e9e (i&gt;=1).</p> <ul> <li>lignes 15-17\u00a0: r\u00e9cup\u00e9ration des valeurs lues dans la BD\u00a0;</li> <li>ligne 19\u00a0: la transaction est valid\u00e9e (on dit \u00e9galement committ\u00e9e). Cela la termine et lib\u00e8re les ressources que le SGBD avait mobilis\u00e9es pour elle\u00a0;</li> <li> <p>ligne 25\u00a0: les ressources sont lib\u00e9r\u00e9es dans le [finally]. Celui-ci appelle la m\u00e9thode [doFinally] suivante\u00a0: <pre><code>private void doFinally(ResultSet rs, PreparedStatement ps, Connection connexion) {\n        // fermeture ResultSet\n        if (rs != null) {\n            try {\n                rs.close();\n            } catch (SQLException e1) {\n\n            }\n        }\n        // fermeture [PreparedStatement]\n        if (ps != null) {\n            try {\n                ps.close();\n            } catch (SQLException e2) {\n\n            }\n        }\n        if (connexion != null) {\n            try {\n                // fermer la connexion\n                connexion.close();\n            } catch (SQLException e3) {\n                // traiter l'exception\n            }\n        }\n    }\n</code></pre></p> </li> <li> <p>lignes 3-9\u00a0: fermeture du [ResultSet]\u00a0;</p> </li> <li>lignes 11-17\u00a0: fermeture du [PreparedStatement]\u00a0;</li> <li> <p>lignes 18-27\u00a0: fermeture de la connexion\u00a0; Les fermetures des lignes 3-17 semblent redondantes dans la mesure on ferme la connexion lignes 18-25. En fait, dans certains cas elles ne le sont pas et il est conseill\u00e9 de les laisser [http://stackoverflow.com/questions/4507440/must-jdbc-resultsets-and-statements-be-closed-separately-although-the-connection].</p> </li> <li> <p>ligne 22\u00a0: l'exception est trait\u00e9e par la m\u00e9thode [doCatchException] suivante\u00a0: <pre><code>    private static void doCatchException(Connection connexion, Throwable th) {\n        // annulation transaction\n        try {\n            if (connexion != null) {\n                connexion.rollback();\n            }\n        } catch (SQLException e2) {\n            // traiter l'exception\n        }\n}\n</code></pre></p> </li> <li> <p>lignes 4-6\u00a0: la transaction est annul\u00e9e. Cela la termine et le SGBD va pouvoir rel\u00e2cher les ressources mobilis\u00e9es pour elle\u00a0;</p> </li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#634-etape-3-emission-dordres-sql-insert-update-delete","title":"6.3.4. \u00e9tape 3 - \u00e9mission d'ordres SQL [INSERT, UPDATE, DELETE]","text":"<p>Les ordres SQL [INSERT, UPDATE, DELETE] sont des op\u00e9rations de mise \u00e0 jour\u00a0: elles modifient la base de donn\u00e9es mais ne ram\u00e8nent aucune ligne. La seule information rendue est le nombre de lignes affect\u00e9es par l'op\u00e9ration de mise \u00e0 jour.</p> <p>Le code</p> <pre><code>Connection connexion = null;\n        PreparedStatement ps = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // en mode lecture / \u00e9criture\n            connexion.setReadOnly(false);\n            // on met \u00e0 jour la table\n            ps = connexion.prepareStatement(\"UPDATE PRODUITS SET PRIX=PRIX*1.1 WHERE CATEGORIE=?\");\n            // cat\u00e9gorie 1\n            ps.setInt(1, 10);\n            // ex\u00e9cution\n            int nbLignes=ps.executeUpdate();\n            // commit transaction\n            connexion.commit();\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, ps, connexion);\n        }\n    }\n</code></pre> <ul> <li>ligne 9\u00a0: la connexion est utilis\u00e9e en lecture et \u00e9criture\u00a0;</li> <li>ligne 11\u00a0: un [PreparedStatement] avec 1 param\u00e8tre (symbolis\u00e9 par ?). On peut avoir plusieurs param\u00e8tres. Ils sont num\u00e9rot\u00e9s \u00e0 partir de 1\u00a0;</li> <li>ligne 13\u00a0: on affecte sa valeur \u00e0 l'unique param\u00e8tre. Le 1er param\u00e8tre de [setType] est la position du param\u00e8tre dans le [PreparedStatement] (1, 2, ...) et le second la valeur qui lui est attribu\u00e9e. On peut utiliser les m\u00e9thodes [setInt, setLong, setFloat, setDouble, setString, setDate, ...]\u00a0;</li> <li>ligne 15\u00a0: on utilise la m\u00e9thode [executeUpdate] et non [executeQuery] r\u00e9serv\u00e9e aux ordres SELECT. La m\u00e9thode rend le nombre de lignes affect\u00e9es par l'op\u00e9ration. Peut \u00eatre 0.</li> <li>ligne 17\u00a0: la transaction est valid\u00e9e\u00a0;</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#635-etape-4-fermeture-de-la-connexion","title":"6.3.5. \u00e9tape 4 - fermeture de la connexion","text":"<p>Une connexion doit \u00eatre ferm\u00e9e le plus vite possible dans un contexte multi-utilisateurs car un SGBD accepte un nombre limit\u00e9 de connexions ouvertes. Dans les exemples pr\u00e9c\u00e9dents, elle \u00e9tait ferm\u00e9e dans la clause [finally] des op\u00e9rations SQL afin qu'elle soit ferm\u00e9e qu'il y ait eu exception ou pas.</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#64-un-projet-exemple","title":"6.4. Un projet exemple","text":""},{"location":"cours-introduction-a-lx27api-jdbc.html#641-support","title":"6.4.1. Support","text":"<p>Le dossier [support / chap5] contient les projets Eclipse de ce chapitre [1, 2]. Le dossier [database] contient le script SQL permettant de cr\u00e9er la base MySQL exemple de ce chapitre [1, 3].</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#642-la-base-de-donnees-exploitee","title":"6.4.2. La base de donn\u00e9es exploit\u00e9e","text":"<p>Les exemples qui suivent exploitent la base de donn\u00e9es MySQL suivante\u00a0:</p> <ul> <li>[ID]\u00a0: cl\u00e9 primaire en mode AUTO_INCREMENT (si on ne donne pas de cl\u00e9 primaire, le SGBD la g\u00e9n\u00e8re)\u00a0;</li> <li>[NOM]\u00a0: nom d'un produit - unique\u00a0;</li> <li>[CATEGORIE]\u00a0: n\u00b0 de sa cat\u00e9gorie\u00a0;</li> <li>[PRIX]\u00a0: son prix\u00a0;</li> <li>[DESCRIPTION]\u00a0: une description du produit\u00a0; On la cr\u00e9era avec l'outil [WampServer] de la fa\u00e7on suivante [1-9]\u00a0:</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#643-le-projet-eclipse","title":"6.4.3. Le projet Eclipse","text":"<p>Le projet est un projet Maven d\u00e9fini par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.jdbc&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-jdbc-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;5.1.34&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n            &lt;version&gt;2.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 8-12\u00a0: le pilote JDBC du SGBD MySQL5\u00a0;</li> <li>lignes 13-17\u00a0: une biblioth\u00e8que capable de g\u00e9rer du jSON (Javascript Object Notation) (cf paragraphe 22.6, page 423). Nous allons l'utiliser pour afficher sous forme jSON les produits de la base de donn\u00e9es\u00a0;</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#644-la-classe-des-produits","title":"6.4.4. La classe des produits","text":"<p>La classe [Produit] est la suivante\u00a0:</p> <pre><code>package istia.st.jdbc;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic class Produit {\n\n    // champs\n    private int id;\n    private String nom;\n    private int categorie;\n    private double prix;\n    private String description;\n\n    // constructeurs\n    public Produit() {\n\n    }\n\n    public Produit(int id, String nom, int categorie, double prix, String description) {\n        this.id = id;\n        this.nom = nom;\n        this.categorie = categorie;\n        this.prix = prix;\n        this.description = description;\n    }\n\n    // getters et setters\n    ...\n\n    // to String\n    public String toString() {\n        try {\n            return new ObjectMapper().writeValueAsString(this);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n</code></pre> <ul> <li>ligne 34\u00a0: on utilise la biblioth\u00e8que jSON pour afficher la cha\u00eene jSON du produit. Cela donne un affichage analogue au suivant\u00a0: <pre><code>Liste des produits : \n{\"id\":1,\"nom\":\"NOM1\",\"categorie\":1,\"prix\":100.0,\"description\":\"DESC1\"}\n{\"id\":2,\"nom\":\"NOM2\",\"categorie\":1,\"prix\":101.0,\"description\":\"DESC2\"}\n</code></pre></li> </ul> <p>L'int\u00e9r\u00eat de la m\u00e9thode [toString] ci-dessus est que si on ajoute / retranche des champs \u00e0 la classe, sa m\u00e9thode [toString] est toujours valide. Par ailleurs, si les champs sont eux-m\u00eames des objets (listes, tableaux, dictionnaires, objets utilisateur), les biblioth\u00e8ques jSON savent les transformer \u00e0 leur tour en cha\u00eene jSON\u00a0;</p>"},{"location":"cours-introduction-a-lx27api-jdbc.html#645-la-classe-static","title":"6.4.5. La classe [Static]","text":"<p>La classe [Static] regroupe dans des m\u00e9thodes du code utilis\u00e9 fr\u00e9quemment dans la classe principale\u00a0:</p> <pre><code>package istia.st.jdbc;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Static {\n\n    public static List&lt;String&gt; getErreursFromThrowable(Throwable th) {\n        // on r\u00e9cup\u00e8re la liste des msg d'erreur de l'exception\n        List&lt;String&gt; erreurs = new ArrayList&lt;String&gt;();\n        while (th != null) {\n            // message d'erreur du throwable\n            erreurs.add(th.getMessage());\n            // on passe \u00e0 la cause du throwable\n            th = th.getCause();\n        }\n        // r\u00e9sultat\n        return erreurs;\n    }\n\n    public static void show(String title, List&lt;String&gt; messages){\n        // titre\n        System.out.println(String.format(\"%s : \",title));\n        // messages\n        for(String message : messages){\n            System.out.println(String.format(\"- %s\",message));\n        }\n    }\n}\n</code></pre> <ul> <li>lignes 8-19\u00a0: permet d'avoir la liste des erreurs encapsul\u00e9es dans un objet de type [Throwable] qui est la classe m\u00e8re de la classe [Exception]\u00a0;</li> <li>lignes 21-28\u00a0: affiche \u00e0 l'\u00e9cran une liste de messages\u00a0; Ce code pourrait \u00eatre dans la classe principale parce qu'ici c'est la seule \u00e0 l'utiliser. On se place ici dans un cas plus large ou d'autres classes auraient besoin de ce code.</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#646-le-squelette-de-la-classe-principale","title":"6.4.6. Le squelette de la classe principale","text":"<pre><code>package istia.st.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class IntroJdbc01 {\n\n    // constantes\n    final static String url = \"jdbc:mysql://localhost:3306/dbIntroJdbc\";\n    final static String user = \"root\";\n    final static String passwd = \"\";\n    final static String insert = \"INSERT INTO PRODUITS(ID, NOM, CATEGORIE, PRIX, DESCRIPTION) VALUES (?, ?, ?, ?, ?)\";\n    final static String delete = \"DELETE FROM PRODUITS\";\n    final static String select = \"SELECT ID, NOM, CATEGORIE, PRIX, DESCRIPTION FROM PRODUITS\";\n    final static String update = \"UPDATE PRODUITS SET PRIX=PRIX*1.1 WHERE CATEGORIE=?\";\n    final static String insert2 = \"INSERT INTO PRODUITS(ID, NOM, CATEGORIE, PRIX, DESCRIPTION) VALUES (100,'X',1,1,'x')\";\n\n    public static void main(String[] args) {\n        // chargement du pilote JDBC de MySQL\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n        } catch (ClassNotFoundException e1) {\n            doCatchException(\"Pilote JDBC introuvable\", null, e1);\n            return;\n        }\n        // on vide la table [PRODUITS]\n        delete();\n        // on la remplit\n        insert();\n        // on la lit\n        select();\n        // mise \u00e0 jour\n        update();\n        // affichage\n        select();\n        // insertion de deux \u00e9l\u00e9ments identiques\n        // l'insertion doit \u00e9chouer et aucun des deux \u00e9l\u00e9ments n'est ins\u00e9r\u00e9 \u00e0 cause de la transaction\n        insert2();\n        // on v\u00e9rifie\n        select();\n        // fini\n        System.out.println(\"Travail termin\u00e9\");\n    }\n\n    // liste des produits\n    private static void select() {\n...\n    }\n\n    // suppression produits\n    public static void delete() {\n...\n    }\n\n    // ajout produits\n    public static void insert() {\n...\n    }\n\n    // ajout 2 produits\n    public static void insert2() {\n...\n    }\n\n    // mise \u00e0 jour de certains produits\n    public static void update() {\n..\n    }\n\n    private static void doFinally(ResultSet rs, PreparedStatement ps, Connection connexion) {\n        // fermeture ResultSet\n        if (rs != null) {\n            try {\n                rs.close();\n            } catch (SQLException e1) {\n\n            }\n        }\n        // fermeture [PreparedStatement]\n        if (ps != null) {\n            try {\n                ps.close();\n            } catch (SQLException e2) {\n\n            }\n        }\n        // fermer la connexion\n        if (connexion != null) {\n            try {\n                connexion.close();\n            } catch (SQLException e3) {\n                // on affiche les msg d'erreur\n                Static.show(\"Les erreurs suivantes se sont produites lors de la fermeture de la connexion\",\n                        Static.getErreursFromThrowable(e3));\n            }\n        }\n    }\n\n    private static void doCatchException(String title, Connection connexion, Throwable th) {\n        // on affiche les msg d'erreur\n        Static.show(title, Static.getErreursFromThrowable(th));\n        // annulation transaction\n        try {\n            if (connexion != null) {\n                connexion.rollback();\n            }\n        } catch (SQLException e2) {\n            // on affiche les msg d'erreur\n            Static.show(title, Static.getErreursFromThrowable(e2));\n        }\n    }\n}\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#647-suppression-du-contenu-de-la-table-des-produits","title":"6.4.7. Suppression du contenu de la table des produits","text":"<p>La m\u00e9thode [delete] supprime le contenu de la table\u00a0:</p> <pre><code>// suppression produits\n    public static void delete() {\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // on vide la table [PRODUITS]\n            ps = connexion.prepareStatement(delete);\n            ps.executeUpdate();\n            // commit transaction\n            connexion.commit();\n            // retour au mode par d\u00e9faut\n            connexion.setAutoCommit(true);\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(\"Les erreurs suivantes se sont produites \u00e0 la suppression du contenu de la table\", connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, null, connexion);\n        }\n    }\n</code></pre> <p>Cet exemple utilise des transactions. Une transaction permet de regrouper des ordres SQL qui doivent \u00eatre tous r\u00e9ussis ou tous annul\u00e9s. Il y a quatre op\u00e9rations \u00e0 conna\u00eetre\u00a0:</p> <ul> <li>d\u00e9but d'une transaction : [connexion.setAutoCommit(false)]\u00a0;</li> <li>fin d'une transaction avec succ\u00e8s\u00a0: [connexion.commit()]. Dans ce cas, toutes les op\u00e9rations faites sur la BD lors de la transaction sont valid\u00e9es\u00a0;</li> <li>fin d'une transaction avec \u00e9chec \u00a0: [connexion.rollback()]. Dans ce cas, toutes les op\u00e9rations faites sur la BD lors de la transaction sont annul\u00e9es\u00a0;</li> <li>retour au mode [auto-commit] qui est le mode par d\u00e9faut de l'API JDBC\u00a0: [connexion.setAutoCommit(true)]. Dans ce mode, chaque ordre SQL fait l'objet d'une transaction. Ainsi si on fait deux insertions dont la deuxi\u00e8me \u00e9choue\u00a0:</li> <li>en mode [AutoCommit=true], la premi\u00e8re insertion reste (elle a \u00e9t\u00e9 valid\u00e9e par le 1er AutoCommit)\u00a0;</li> <li>en mode [AutoCommit=false], la premi\u00e8re insertion est annul\u00e9e\u00a0; Dans nos exemples, \u00e0 chaque fois que se produit une exception, nous annulons la transaction dans la m\u00e9thode [doCatchException]\u00a0:</li> </ul> <pre><code>    private static void doCatchException(String title, Connection connexion, Throwable th) {\n        // on affiche les msg d'erreur\n        Static.show(title, Static.getErreursFromThrowable(th));\n        // annulation transaction\n        try {\n            if (connexion != null) {\n                connexion.rollback();\n            }\n        } catch (SQLException e2) {\n            // on affiche les msg d'erreur\n            Static.show(\"Erreur lors de l'annulation de la transaction\", Static.getErreursFromThrowable(e2));\n        }\n}\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#648-creation-du-contenu-de-la-table-des-produits","title":"6.4.8. Cr\u00e9ation du contenu de la table des produits","text":"<p>La m\u00e9thode [insert] cr\u00e9e le contenu de la table\u00a0:</p> <pre><code>// ajout produits\n    public static void insert() {\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // on remplit la table\n            ps = connexion.prepareStatement(insert);\n            for (int i = 0; i &lt; 10; i++) {\n                // pr\u00e9paration\n                int n = i + 1;\n                ps.setInt(1, n);\n                ps.setString(2, String.format(\"NOM%s\", n));\n                ps.setInt(3, n / 5 + 1);\n                ps.setDouble(4, 100 * (1 + (double) i / 100));\n                ps.setString(5, String.format(\"DESC%s\", n));\n                // ex\u00e9cution\n                ps.executeUpdate();\n            }\n            // commit transaction\n            connexion.commit();\n            // retour au mode par d\u00e9faut\n            connexion.setAutoCommit(true);\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(\"Les erreurs suivantes se sont produites \u00e0 la cr\u00e9ation du contenu de la table\", connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, null, connexion);\n        }\n    }\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#649-affichage-du-contenu-de-la-table-des-produits","title":"6.4.9. Affichage du contenu de la table des produits","text":"<p>La m\u00e9thode [select] affiche le contenu de la table\u00a0:</p> <pre><code>    // liste des produits\n    private static void select() {\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // on lit la table [PRODUITS]\n            ps = connexion.prepareStatement(select);\n            rs = ps.executeQuery();\n            System.out.println(\"Liste des produits : \");\n            while (rs.next()) {\n                System.out.println(new Produit(rs.getInt(1), rs.getString(2), rs.getInt(3), rs.getDouble(4), rs.getString(5)));\n            }\n            // commit transaction\n            connexion.commit();\n            // retour au mode par d\u00e9faut\n            connexion.setAutoCommit(true);\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(\"Les erreurs suivantes se sont produites \u00e0 la lecture de la table\", connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, null, connexion);\n        }\n}\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#6410-mise-a-jour-du-contenu-de-la-table","title":"6.4.10. Mise \u00e0 jour du contenu de la table","text":"<p>La m\u00e9thode [update] met \u00e0 jour certains produits\u00a0:</p> <pre><code>// mise \u00e0 jour de certains produits\n    public static void update() {\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // on met \u00e0 jour la table\n            ps = connexion.prepareStatement(update);\n            // cat\u00e9gorie 1\n            ps.setInt(1, 1);\n            // ex\u00e9cution\n            ps.executeUpdate();\n            // commit transaction\n            connexion.commit();\n            // retour au mode par d\u00e9faut\n            connexion.setAutoCommit(true);\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(\"Les erreurs suivantes se sont produites \u00e0 la mise \u00e0 jour du contenu de la table\", connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, null, connexion);\n        }\n    }\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#6411-role-de-la-transaction","title":"6.4.11. R\u00f4le de la transaction","text":"<p>La m\u00e9thode [insert2] ins\u00e8re deux produits de m\u00eame cl\u00e9 primaire dans la table, ce qui n'est pas possible. Comme on est dans une transaction, le premi\u00e8re insertion va \u00eatre annul\u00e9e.</p> <pre><code>// ajout de  2 produits de m\u00eames cl\u00e9s primaires\n    public static void insert2() {\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        try {\n            // ouverture connexion\n            connexion = DriverManager.getConnection(url, user, passwd);\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n            // on ajoute 1 ligne\n            ps = connexion.prepareStatement(insert2);\n            // ex\u00e9cution\n            ps.executeUpdate();\n            // on ajoute la m\u00eame ligne une 2\u00e8me fois donc avec la m\u00eame cl\u00e9 primaire\n            // l'insertion doit \u00e9chouer et aucun des deux \u00e9l\u00e9ments ne doit \u00eatre ins\u00e9r\u00e9 \u00e0 cause de la transaction\n            ps.executeUpdate();\n            // commit transaction\n            connexion.commit();\n            // retour au mode par d\u00e9faut\n            connexion.setAutoCommit(true);\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(\"Les erreurs suivantes se sont produites lors de l'ajout\", connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, null, connexion);\n        }\n    }\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#6412-resultats","title":"6.4.12. R\u00e9sultats","text":"<p>Les r\u00e9sultats de l'ex\u00e9cution de la m\u00e9thode [main] donne les r\u00e9sultats suivants\u00a0:</p> <pre><code>Liste des produits : \n{\"id\":1,\"nom\":\"NOM1\",\"categorie\":1,\"prix\":100.0,\"description\":\"DESC1\"}\n{\"id\":2,\"nom\":\"NOM2\",\"categorie\":1,\"prix\":101.0,\"description\":\"DESC2\"}\n{\"id\":3,\"nom\":\"NOM3\",\"categorie\":1,\"prix\":102.0,\"description\":\"DESC3\"}\n{\"id\":4,\"nom\":\"NOM4\",\"categorie\":1,\"prix\":103.0,\"description\":\"DESC4\"}\n{\"id\":5,\"nom\":\"NOM5\",\"categorie\":2,\"prix\":104.0,\"description\":\"DESC5\"}\n{\"id\":6,\"nom\":\"NOM6\",\"categorie\":2,\"prix\":105.0,\"description\":\"DESC6\"}\n{\"id\":7,\"nom\":\"NOM7\",\"categorie\":2,\"prix\":106.0,\"description\":\"DESC7\"}\n{\"id\":8,\"nom\":\"NOM8\",\"categorie\":2,\"prix\":107.0,\"description\":\"DESC8\"}\n{\"id\":9,\"nom\":\"NOM9\",\"categorie\":2,\"prix\":108.0,\"description\":\"DESC9\"}\n{\"id\":10,\"nom\":\"NOM10\",\"categorie\":3,\"prix\":109.0,\"description\":\"DESC10\"}\nListe des produits : \n{\"id\":1,\"nom\":\"NOM1\",\"categorie\":1,\"prix\":110.0,\"description\":\"DESC1\"}\n{\"id\":2,\"nom\":\"NOM2\",\"categorie\":1,\"prix\":111.0,\"description\":\"DESC2\"}\n{\"id\":3,\"nom\":\"NOM3\",\"categorie\":1,\"prix\":112.0,\"description\":\"DESC3\"}\n{\"id\":4,\"nom\":\"NOM4\",\"categorie\":1,\"prix\":113.0,\"description\":\"DESC4\"}\n{\"id\":5,\"nom\":\"NOM5\",\"categorie\":2,\"prix\":104.0,\"description\":\"DESC5\"}\n{\"id\":6,\"nom\":\"NOM6\",\"categorie\":2,\"prix\":105.0,\"description\":\"DESC6\"}\n{\"id\":7,\"nom\":\"NOM7\",\"categorie\":2,\"prix\":106.0,\"description\":\"DESC7\"}\n{\"id\":8,\"nom\":\"NOM8\",\"categorie\":2,\"prix\":107.0,\"description\":\"DESC8\"}\n{\"id\":9,\"nom\":\"NOM9\",\"categorie\":2,\"prix\":108.0,\"description\":\"DESC9\"}\n{\"id\":10,\"nom\":\"NOM10\",\"categorie\":3,\"prix\":109.0,\"description\":\"DESC10\"}\nLes erreurs suivantes se sont produites lors de l'ajout : \n- Duplicate entry '100' for key 'PRIMARY'\nListe des produits : \n{\"id\":1,\"nom\":\"NOM1\",\"categorie\":1,\"prix\":110.0,\"description\":\"DESC1\"}\n{\"id\":2,\"nom\":\"NOM2\",\"categorie\":1,\"prix\":111.0,\"description\":\"DESC2\"}\n{\"id\":3,\"nom\":\"NOM3\",\"categorie\":1,\"prix\":112.0,\"description\":\"DESC3\"}\n{\"id\":4,\"nom\":\"NOM4\",\"categorie\":1,\"prix\":113.0,\"description\":\"DESC4\"}\n{\"id\":5,\"nom\":\"NOM5\",\"categorie\":2,\"prix\":104.0,\"description\":\"DESC5\"}\n{\"id\":6,\"nom\":\"NOM6\",\"categorie\":2,\"prix\":105.0,\"description\":\"DESC6\"}\n{\"id\":7,\"nom\":\"NOM7\",\"categorie\":2,\"prix\":106.0,\"description\":\"DESC7\"}\n{\"id\":8,\"nom\":\"NOM8\",\"categorie\":2,\"prix\":107.0,\"description\":\"DESC8\"}\n{\"id\":9,\"nom\":\"NOM9\",\"categorie\":2,\"prix\":108.0,\"description\":\"DESC9\"}\n{\"id\":10,\"nom\":\"NOM10\",\"categorie\":3,\"prix\":109.0,\"description\":\"DESC10\"}\nTravail termin\u00e9\n</code></pre>"},{"location":"cours-introduction-a-lx27api-jdbc.html#65-utilisation-dune-source-de-donnees-de-type-datasource","title":"6.5. Utilisation d'une source de donn\u00e9es de type [DataSource]","text":"<p>Nous allons reprendre l'application pr\u00e9c\u00e9dente en utilisant une source de donn\u00e9es de type [javax.sql.DataSource]\u00a0:</p> <p></p> <p>Nous allons utiliser une source de donn\u00e9es impl\u00e9ment\u00e9e par la classe [org.apache.tomcat.jdbc.pool.DataSource]. Cette classe utilise un pool de connexions \u00e7-\u00e0-d un ensemble de connexions ouvertes\u00a0:</p> <ul> <li>lorsque le pool est instanci\u00e9, un certain nombre de connexions est ouvert avec la base de donn\u00e9es. Ce nombre est configurable\u00a0;</li> <li>lorsque le code Java ouvre une connexion, celle-ci est fournie par le pool\u00a0;</li> <li>lorsque le code Java ferme une connexion, celle-ci est rendue au pool\u00a0; Au final, les connexions ne sont ouvertes qu'une fois, ce qui am\u00e9liore la performance d'acc\u00e8s \u00e0 la base de donn\u00e9es. La source de donn\u00e9es sera d\u00e9finie dans une classe de configuration Spring</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#651-le-projet-eclipse","title":"6.5.1. Le projet Eclipse","text":"<p>Le projet est un projet Maven d\u00e9fini par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.jdbc&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-jdbc-02&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;dependencies&gt;\n        &lt;!-- MySQL --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;5.1.34&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- biblioth\u00e8que jSON --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n            &lt;version&gt;2.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Tomcat Jdbc --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;\n            &lt;version&gt;8.0.20&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 21-25\u00a0: d\u00e9pendance sur Spring\u00a0;</li> <li>lignes 27-31\u00a0: d\u00e9pendance sur la biblioth\u00e8que qui fournit la source de donn\u00e9es\u00a0; La classe de configuration de Spring [AppConfig] est la suivante\u00a0:</li> </ul> <pre><code>package istia.st.jdbc;\n\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class AppConfig {\n\n    // constantes\n    final static String URL = \"jdbc:mysql://localhost:3306/dbIntroJdbc\";\n    final static String USER = \"root\";\n    final static String PASSWD = \"\";\n    final static String INSERT = \"INSERT INTO PRODUITS(ID, NOM, CATEGORIE, PRIX, DESCRIPTION) VALUES (?, ?, ?, ?, ?)\";\n    final static String DELETE = \"DELETE FROM PRODUITS\";\n    final static String SELECT = \"SELECT ID, NOM, CATEGORIE, PRIX, DESCRIPTION FROM PRODUITS\";\n    final static String UPDATE = \"UPDATE PRODUITS SET PRIX=PRIX*1.1 WHERE CATEGORIE=?\";\n    final static String INSERT2 = \"INSERT INTO PRODUITS(ID, NOM, CATEGORIE, PRIX, DESCRIPTION) VALUES (100,'X',1,1,'x')\";\n    final static String DRIVER_CLASSNAME = \"com.mysql.jdbc.Driver\";\n\n    @Bean\n    public DataSource dataSource() {\n        // source de donn\u00e9es TomcatJdbc\n        DataSource dataSource = new DataSource();\n        // configuration acc\u00e8s JDBC\n        dataSource.setDriverClassName(DRIVER_CLASSNAME);\n        dataSource.setUsername(USER);\n        dataSource.setPassword(PASSWD);\n        dataSource.setUrl(URL);\n        // une connexion ouverte initialement\n        dataSource.setInitialSize(1);\n        // r\u00e9sultat\n        return dataSource;\n    }\n}\n</code></pre> <ul> <li>lignes 11-19\u00a0: les constantes pr\u00e9c\u00e9demment d\u00e9finies dans [IntroJdbc01] ont migr\u00e9 dans [AppConfig]\u00a0;</li> <li>lignes 31-34\u00a0: le bean Spring d\u00e9finissant la source de donn\u00e9es\u00a0;</li> <li>ligne 24\u00a0: cr\u00e9ation de la source de donn\u00e9es encore non configur\u00e9e\u00a0;</li> <li>lignes 26-29\u00a0: les informations qui permettent \u00e0 la source de donn\u00e9es de se connecter \u00e0 la base de donn\u00e9es\u00a0;</li> <li>ligne 31\u00a0; cr\u00e9e un pool de 1 connexion. On n'en a pas besoin de plus ici. Il n'y a jamais plusieurs connexions simultan\u00e9es\u00a0;</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#652-la-classe-principale","title":"6.5.2. La classe principale","text":"<p>La classe principale [IntroJdbc02] est la suivante\u00a0:</p> <pre><code>package istia.st.jdbc;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport javax.sql.DataSource;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class IntroJdbc02 {\n    // source de donn\u00e9es\n    private static DataSource dataSource;\n\n    public static void main(String[] args) {\n        // r\u00e9cup\u00e9ration du contexte Spring\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        // r\u00e9cup\u00e9ration de la source de donn\u00e9es\n        dataSource = ctx.getBean(DataSource.class);\n        // on vide la table [PRODUITS]\n        delete();\n...\n        // fini\n        ctx.close();\n        System.out.println(\"Travail termin\u00e9\");\n    }\n\n    // liste des produits\n    private static void select() {\n        Connection connexion = null;\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        try {\n            // ouverture connexion\n            connexion = dataSource.getConnection();\n            // d\u00e9but transaction\n            connexion.setAutoCommit(false);\n...\n        } catch (SQLException e1) {\n            // on traite l'exception\n            doCatchException(\"Les erreurs suivantes se sont produites \u00e0 la lecture de la table\", connexion, e1);\n        } finally {\n            // on traite le finally\n            doFinally(null, null, connexion);\n        }\n    }\n...\n}\n</code></pre> <ul> <li>ligne 14\u00a0: la source de donn\u00e9es. On notera qu'elle est de type [javax.sql.DataSource] qui est une interface\u00a0;</li> <li>ligne 18\u00a0: instanciation des objets Spring\u00a0;</li> <li>ligne 20\u00a0: obtention d'une r\u00e9f\u00e9rence sur la source de donn\u00e9es. On notera qu'\u00e0 aucun moment on ne cite la classe r\u00e9ellement utilis\u00e9e. Ainsi ici, rien ne laisse supposer qu'on utilise une impl\u00e9mentation [TomcatJdbc]\u00a0;</li> <li>ligne 36\u00a0: obtention d'une connexion ouverte\u00a0;</li> <li>le reste du code est identique \u00e0 celui de la classe [IntroJdbc01]\u00a0;</li> </ul>"},{"location":"cours-introduction-a-lx27api-jdbc.html#66-conclusion","title":"6.6. Conclusion","text":"<p>On trouvera davantage d'informations sur la gestion des bases de donn\u00e9es dans le document [Exploiter une base relationnelle avec l'\u00e9cosyst\u00e8me Spring].</p>"},{"location":"cours-introduction-au-framework-spring.html","title":"5. [Cours]\u00a0: Introduction au framework Spring","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances.</p> <p>Spring est apparu en 2004 d'abord en tant que conteneur d'objets. Depuis, il a \u00e9volu\u00e9 en de multiple ramifications\u00a0: Spring MVC, Spring Data, Spring Batch, ... [http://spring.io]. Nous ne pr\u00e9sentons dans ce chapitre que le conteneur d'objets. Voici quelques points de rep\u00e8re\u00a0:</p> <ul> <li>une application a de multiples classes et certaines d'entre-elles se partagent des objets qui doivent \u00eatre uniques (singletons). Spring cr\u00e9e et g\u00e8re ces singletons\u00a0;</li> <li>Spring place ces singletons dans une structure appel\u00e9e contexte\u00a0;</li> <li>les classes ont acc\u00e8s aux singletons de l'application en les demandant \u00e0 Spring via leur nom, leur type ou les deux\u00a0;</li> <li>Spring cr\u00e9e les singletons et g\u00e8re leurs d\u00e9pendances \u00e9ventuelles\u00a0: un singleton peut en effet avoir des r\u00e9f\u00e9rences sur un ou plusieurs autres singletons. Lorsque Spring cr\u00e9e un singleton, il cr\u00e9e \u00e9galement leurs d\u00e9pendances\u00a0;</li> <li>lorsqu'une application s'appuyant sur Spring d\u00e9marre, elle peut demander \u00e0 Spring de cr\u00e9er tous les singletons de l'application. Ceux-ci seront ensuite disponibles dans le contexte de Spring\u00a0;</li> <li>Spring facilite l'utilisation des architectures en couches et la programmation par interfaces. Dans les cas simples, chaque couche est impl\u00e9ment\u00e9e par un singleton et impl\u00e9mente une interface. Si l'application travaille avec les interfaces des couches et non avec leurs classes d'impl\u00e9mentation, alors on obtient une architecture \u00e9volutive qui permet de changer l'impl\u00e9mentation d'une couche sans changer les autres gr\u00e2ce aux deux caract\u00e9ristiques suivantes\u00a0:</li> <li>l'application obtient une r\u00e9f\u00e9rence sur la couche via son nom. Spring lui d\u00e9livre une r\u00e9f\u00e9rence sur la classe impl\u00e9mentant la couche\u00a0;</li> <li> <p>l'application utilise cette r\u00e9f\u00e9rence comme celle de l'interface de la couche et non comme celle d'une classe\u00a0; La d\u00e9claration des singletons peut \u00eatre faite de trois fa\u00e7ons qui peuvent \u00eatre mix\u00e9es\u00a0:</p> </li> <li> <p>au sein d'un fichier XML,</p> </li> <li>dans une classe sp\u00e9ciale de configuration\u00a0;</li> <li> <p>avec toute classe \u00e0 l'aide d'annotations\u00a0; Nous pr\u00e9sentons dans la suite trois exemples de configuration\u00a0:</p> </li> <li> <p>[exemple-01]\u00a0: configuration centralis\u00e9e dans un unique fichier XML\u00a0;</p> </li> <li>[exemple-02]\u00a0: configuration centralis\u00e9e dans une unique classe Java\u00a0;</li> <li>[exemple-03]\u00a0: configuration distribu\u00e9e sur plusieurs classes Java\u00a0; Le dernier exemple [exemple-04] s'int\u00e9resse \u00e0 la configuration Spring d'une architecture en couches. C'est l'exemple le plus important. C'est lui qui sera repris constamment pour configurer les architectures du document.</li> </ul> <p>Ces quatre exemples posent les bases de ce qui suit\u00a0:</p> <ul> <li>configuration Spring et injection de d\u00e9pendances\u00a0;</li> <li>utilisation de Maven pour g\u00e9rer les d\u00e9pendances d'un projet\u00a0;</li> <li>utilisation de JUnit pour tester les projets\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#51-support","title":"5.1. Support","text":"<p>Le dossier [support / chap-05] contient les projets Eclipse de ce chapitre.</p>"},{"location":"cours-introduction-au-framework-spring.html#52-exemple-01","title":"5.2. Exemple-01","text":""},{"location":"cours-introduction-au-framework-spring.html#521-le-projet-eclipse","title":"5.2.1. Le projet Eclipse","text":""},{"location":"cours-introduction-au-framework-spring.html#522-la-classe-personne","title":"5.2.2. La classe [Personne]","text":"<pre><code>package istia.st.spring.core;\n\npublic class Personne {\n\n    // champs\n    private String nom;\n    private String prenom;\n    private int age;\n\n    // constructeurs\n    public Personne() {\n\n    }\n\n    public Personne(String nom, String pr\u00e9nom, int \u00e2ge) {\n        this.nom = nom;\n        this.prenom = pr\u00e9nom;\n        this.age = \u00e2ge;\n    }\n\n    // toString\n    public String toString() {\n        return String.format(\"Personne[%s, %s,%d]\", prenom, nom, age);\n    }\n\n    // getters et setters\n\n    public String getNom() {\n        return nom;\n    }\n\n    public void setNom(String nom) {\n        this.nom = nom;\n    }\n\n    public String getPrenom() {\n        return prenom;\n    }\n\n    public void setPrenom(String prenom) {\n        this.prenom = prenom;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n}\n</code></pre> <p>Note\u00a0: les getters et setters peuvent \u00eatre g\u00e9n\u00e9r\u00e9s automatiquement de la fa\u00e7on suivante [1-2]\u00a0:</p>"},{"location":"cours-introduction-au-framework-spring.html#523-la-classe-appartement","title":"5.2.3. La classe [Appartement]","text":"<pre><code>package istia.st.spring.core;\n\npublic class Appartement {\n\n    // champs\n    private Personne proprietaire;\n    private int surface;\n\n    // getters et setters\n\n    public Personne getProprietaire() {\n        return proprietaire;\n    }\n\n    public void setProprietaire(Personne proprietaire) {\n        this.proprietaire = proprietaire;\n    }\n\n    public int getSurface() {\n        return surface;\n    }\n\n    public void setSurface(int surface) {\n        this.surface = surface;\n    }\n\n    // toString\n    public String toString() {\n        return String.format(\"Appartement[%s, %s]\", proprietaire, surface);\n    }\n\n}\n</code></pre> <p>Note\u00a0: cette classe n'a pas de constructeur explicite. Dans ce cas, existe toujours par d\u00e9faut, le constructeur sans param\u00e8tres qui ne fait rien. Lorsqu'on cr\u00e9e des constructeurs, ce constructeur par d\u00e9faut n'existe plus implicitement. Il faut alors le d\u00e9finir explicitement\u00a0:</p> <pre><code>public Appartement(){\n}\n</code></pre>"},{"location":"cours-introduction-au-framework-spring.html#524-le-fichier-de-configuration-de-spring","title":"5.2.4. Le fichier de configuration de Spring","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd\"&gt;\n    &lt;!-- Personne 01 --&gt;\n    &lt;bean id=\"personne_01\" class=\"istia.st.spring.core.Personne\"&gt;\n        &lt;constructor-arg index=\"0\" value=\"dubois\" /&gt;\n        &lt;constructor-arg index=\"1\" value=\"paul\" /&gt;\n        &lt;constructor-arg index=\"2\" value=\"34\" /&gt;\n    &lt;/bean&gt;\n    &lt;!-- Personne 02 --&gt;\n    &lt;bean id=\"personne_02\" class=\"istia.st.spring.core.Personne\"&gt;\n        &lt;property name=\"nom\" value=\"martin\" /&gt;\n        &lt;property name=\"prenom\" value=\"micheline\" /&gt;\n        &lt;property name=\"age\" value=\"18\" /&gt;\n    &lt;/bean&gt;\n    &lt;!-- une liste de personnes --&gt;\n    &lt;util:list id=\"club\"&gt;\n        &lt;ref bean=\"personne_01\" /&gt;\n        &lt;ref bean=\"personne_02\" /&gt;\n    &lt;/util:list&gt;\n    &lt;!-- un appartement --&gt;\n    &lt;bean id=\"appartement\" class=\"istia.st.spring.core.Appartement\"&gt;\n        &lt;property name=\"surface\" value=\"100\" /&gt;\n        &lt;property name=\"proprietaire\" ref=\"personne_01\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre> <ul> <li>lignes 2, 27\u00a0: les singletons sont d\u00e9finis au sein d'une balise &lt;beans&gt;\u00a0;</li> <li>lignes 6-10\u00a0: chaque singleton est d\u00e9fini par une balise &lt;bean&gt;\u00a0;</li> <li>ligne 6\u00a0: [id] est l'identifiant du singleton. [class] est le nom complet de la classe \u00e0 instancier\u00a0;</li> <li>lignes 7-9\u00a0: les trois valeurs \u00e0 passer au constructeur de la classe [Personne]\u00a0;</li> <li>lignes 12-16\u00a0: la classe [Personne] est d'abord cr\u00e9\u00e9e avec son constructeur par d\u00e9faut [new Personne()]. Puis pour chaque balise [property], un setter de la classe est utilis\u00e9. Par exemple pour la ligne 13, la m\u00e9thode [setNom(\"martin\")] va \u00eatre ex\u00e9cut\u00e9e. Il faut donc que la m\u00e9thode [setNom] existe. C'est un point important \u00e0 se rappeler\u00a0;</li> <li>lignes 18-21\u00a0: la balise &lt;util:list&gt; permet de d\u00e9finir un singleton qui est une liste\u00a0;</li> <li>ligne 19\u00a0: d\u00e9signe le singleton [personne_01] d\u00e9fini ligne 6. On a l\u00e0 ce qu'on appelle une injection de d\u00e9pendances. Deux attributs sont utilisables pour initialiser le champ d'un singleton\u00a0:</li> <li>[value]\u00a0: pour affecter au champ une valeur primitive (cha\u00eene, nombre, date, ...),</li> <li>[ref]\u00a0: pour affecter au champ la r\u00e9f\u00e9rence d'un objet Spring\u00a0; Note\u00a0: le fichier de configuration Spring peut \u00eatre g\u00e9n\u00e9r\u00e9 de la fa\u00e7on suivante [1-4]\u00a0:</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#525-la-classe-executable","title":"5.2.5. La classe ex\u00e9cutable","text":"<pre><code>package istia.st.spring.core;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Demo01 {\n\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public static void main(String[] args) {\n        // r\u00e9cup\u00e9ration du contexte Spring\n        ApplicationContext ctx = new ClassPathXmlApplicationContext(\"config-01.xml\");\n        // on r\u00e9cup\u00e8re les beans\n        Personne p01 = ctx.getBean(\"personne_01\", Personne.class);\n        Personne p02 = ctx.getBean(\"personne_02\", Personne.class);\n        List&lt;Personne&gt; club = ctx.getBean(\"club\", new ArrayList&lt;Personne&gt;().getClass());\n        Appartement appart01 = ctx.getBean(Appartement.class);\n        // on les affiche\n        System.out.println(\"personnes--------\");\n        System.out.println(p01);\n        System.out.println(p02);\n        System.out.println(\"club--------\");\n        for (Personne p : club) {\n            System.out.println(p);\n        }\n        System.out.println(\"appartement--------\");\n        System.out.println(appart01);\n        // les beans r\u00e9cup\u00e9r\u00e9s sont des singletons\n        // on peut les demander plusieurs fois, on r\u00e9cup\u00e8re toujours le m\u00eame bean\n        Personne p01b = ctx.getBean(\"personne_01\", Personne.class);\n        System.out.println(String.format(\"beans [p01,p01b] identiques ? %s\", p01b == p01));\n    }\n}\n</code></pre> <ul> <li>ligne 14\u00a0: cr\u00e9e le contexte Spring. Tous les singletons d\u00e9finis dans le fichier [config-01.xml] sont alors instanci\u00e9s\u00a0;</li> <li>ligne 16\u00a0: demande une r\u00e9f\u00e9rence sur le singleton identifi\u00e9 par [personne_01] de type [Personne]. Ce second param\u00e8tre est facultatif mais alors on re\u00e7oit une r\u00e9f\u00e9rence sur un type [Object], r\u00e9f\u00e9rence qu'il faut alors transtyper vers le type [Personne]\u00a0;</li> <li>ligne 19\u00a0: on n'utilise pas le nom du bean mais uniquement son type car il n'y a qu'un singleton de type [Appartement]\u00a0;</li> <li>ligne 18\u00a0: on a utilis\u00e9 \u00e0 la fois l'identifiant et le type du singleton d\u00e9sir\u00e9. L'identifiant est superflu puisque qu'il n'y a qu'un singleton de type [new ArrayList&lt;Personne&gt;().getClass()]\u00a0;</li> <li>lignes 32-33\u00a0: montrent que si on demande plusieurs fois le m\u00eame singleton, on obtient bien toujours la m\u00eame r\u00e9f\u00e9rence, montrant par l\u00e0 qu'on a bien affaire \u00e0 un singleton. Ce point est important \u00e0 comprendre\u00a0; Note\u00a0: une classe ex\u00e9cutable peut \u00eatre g\u00e9n\u00e9r\u00e9e de la fa\u00e7on suivante [1-6]\u00a0:</li> </ul> <ul> <li>c'est le fait de cocher [6] qui va faire que la classe g\u00e9n\u00e9r\u00e9e va contenir une m\u00e9thode statique [main] qui va la rendre ex\u00e9cutable\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#526-les-dependances-du-projet","title":"5.2.6. Les d\u00e9pendances du projet","text":"<ul> <li>d\u00e9pendances Spring\u00a0: [spring-core, spring-beans, spring-context, spring-expression, commons-logging]\u00a0; Les d\u00e9pendances sont ajout\u00e9es au projet de la fa\u00e7on suivante\u00a0:</li> </ul> <ul> <li>en [1]\u00a0: clic droit sur le projet / [Build Path] / [Configure Build Path]\u00a0;</li> </ul> <ul> <li>en [2]\u00a0: [Add JARs] si les JARs \u00e0 ajouter sont dans un dossier du projet. Sinon [Add External JARs]\u00a0;</li> </ul> <ul> <li> <p>en [3], s\u00e9lectionnez les JARs \u00e0 ajouter au ClassPath du projet (ils sont ici dans le dossier [lib] \u00e0 l'int\u00e9rieur du projet)\u00a0; D\u00e9finition\u00a0: le [ClassPath] d'un projet est l'ensemble des dossiers explor\u00e9s par la JVM (Java Virtual Machine) qui ex\u00e9cute le projet, pour trouver une classe r\u00e9f\u00e9renc\u00e9e par celui-ci. Pour un projet Eclipse, le [ClassPath] est form\u00e9 des \u00e9l\u00e9ments suivants\u00a0:</p> </li> <li> <p>le dossier [bin] du projet\u00a0;</p> </li> <li>les \u00e9l\u00e9ments du [Build Path] du projet\u00a0; Le dossier [bin] est le dossier produit par la compilation du dossier [src]. Donc tout ce qui est plac\u00e9 dans le dossier [src] fait automatiquement partie du [ClassPath] (m\u00eame si ce n'est pas un fichier .java). Donc dans le projet pr\u00e9c\u00e9dent, le fichier de configuration de spring [config-01.xml] qui est dans le dossier [src] fera partie du [Classpath] du projet \u00e0 l'ex\u00e9cution.</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#527-les-resultats","title":"5.2.7. Les r\u00e9sultats","text":"<pre><code>f\u00e9vr. 21, 2014 1:16:23 PM org.springframework.context.support.AbstractApplicationContext prepareRefresh\nInfos: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3ac67f69: startup date [Fri Feb 21 13:16:23 CET 2014]; root of context hierarchy\nf\u00e9vr. 21, 2014 1:16:23 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\nInfos: Loading XML bean definitions from class path resource [config-01.xml]\npersonnes--------\nPersonne[paul, dubois,34]\nPersonne[micheline, martin,18]\nclub--------\nPersonne[paul, dubois,34]\nPersonne[micheline, martin,18]\nappartement--------\nAppartement[Personne[paul, dubois,34], 100]\nbeans [p01,p01b] identiques ? true\n</code></pre>"},{"location":"cours-introduction-au-framework-spring.html#53-exemple-02","title":"5.3. Exemple-02","text":""},{"location":"cours-introduction-au-framework-spring.html#531-le-projet-eclipse","title":"5.3.1. Le projet Eclipse","text":""},{"location":"cours-introduction-au-framework-spring.html#532-la-classe-de-configuration-de-spring","title":"5.3.2. La classe de configuration de Spring","text":"<pre><code>package istia.st.spring.core;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class Config {\n\n    @Bean\n    public Personne personne_01() {\n        return new Personne(\"Paul\", \"Dubois\", 34);\n    }\n\n    @Bean\n    public Personne personne_02() {\n        return new Personne(\"Martin\", \"Micheline\", 18);\n    }\n\n    @Bean\n    public List&lt;Personne&gt; club(Personne personne_01, Personne personne_02) {\n        List&lt;Personne&gt; personnes = new ArrayList&lt;Personne&gt;();\n        personnes.add(personne_01);\n        personnes.add(personne_02);\n        return personnes;\n    }\n\n    @Bean\n    public Appartement appartement(Personne personne_01) {\n        Appartement appartement = new Appartement();\n        appartement.setSurface(200);\n        appartement.setPropri\u00e9taire(personne_01);\n        return appartement;\n    }\n}\n</code></pre> <ul> <li>ligne 9\u00a0: l'annotation [@Configuration] est une annotation Spring. Elle indique que la classe annot\u00e9e d\u00e9finit des singletons. Ceux-ci sont d\u00e9finis \u00e0 l'aide de l'annotation [@Bean]. Spring va ex\u00e9cuter toutes les m\u00e9thodes annot\u00e9es par [@Bean]. Celles-ci cr\u00e9ent les singletons de l'application\u00a0;</li> <li>lignes 12-15\u00a0: d\u00e9finit un singleton identifi\u00e9 par [personne_01], \u00e7-\u00e0-d le nom de la m\u00e9thode.</li> <li>ligne 23\u00a0: les param\u00e8tres [personne_01, personne_02] portent les noms de singletons. Spring va automatiquement les initialiser avec les r\u00e9f\u00e9rences de ces singletons. On parle d'injection de param\u00e8tres\u00a0; Cette fa\u00e7on de configurer les singletons est plus explicite que celle qui utilise le fichier XML. En fait, on reproduit nous-m\u00eames ce que faisait Spring implicitement \u00e0 partir du fichier XML.</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#533-la-classe-executable","title":"5.3.3. La classe ex\u00e9cutable","text":"<pre><code>package istia.st.spring.core;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Demo02 {\n\n    @SuppressWarnings({ \"unchecked\", \"resource\" })\n    public static void main(String[] args) {\n        // r\u00e9cup\u00e9ration du contexte Spring\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(Config.class);\n        // on r\u00e9cup\u00e8re les beans\n        Personne p01 = ctx.getBean(\"personne_01\", Personne.class);\n        Personne p02 = ctx.getBean(\"personne_02\", Personne.class);\n        List&lt;Personne&gt; club = ctx.getBean(\"club\", new ArrayList&lt;Personne&gt;().getClass());\n        Appartement appart01 = ctx.getBean(Appartement.class);\n        // on les affiche\n        System.out.println(\"personnes--------\");\n        System.out.println(p01);\n        System.out.println(p02);\n        System.out.println(\"club--------\");\n        for (Personne p : club) {\n            System.out.println(p);\n        }\n        System.out.println(\"appartement--------\");\n        System.out.println(appart01);\n        // les beans r\u00e9cup\u00e9r\u00e9s sont des singletons\n        // on peut les demander plusieurs fois, on r\u00e9cup\u00e8re toujours le m\u00eame bean\n        Personne p01b = ctx.getBean(\"personne_01\", Personne.class);\n        System.out.println(String.format(\"beans [p01,p01b] identiques ? %s\", p01b == p01));\n    }\n}\n</code></pre> <ul> <li>la ligne 13 provoque l'instanciation de tous les beans d\u00e9finis dans la classe [Config]\u00a0;</li> <li>le reste du code ne change pas\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#534-les-dependances-du-projet","title":"5.3.4. Les d\u00e9pendances du projet","text":"<p>Les d\u00e9pendances sont fix\u00e9es par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.spring.core&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core-02&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;spring-core-02&lt;/name&gt;\n    &lt;description&gt;Introduction \u00e0 Spring&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.7&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;4.1.3.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <p>La gestion \u00e0 la main des d\u00e9pendances d'un projet devient un casse-t\u00eate lorsqu'on utilise des biblioth\u00e8ques Java dont on ne conna\u00eet pas les d\u00e9pendances. Ainsi le framework [Hibernate] qui g\u00e8re l'acc\u00e8s aux bases de donn\u00e9es a des dizaines de d\u00e9pendances. Le projet [Maven] r\u00e9soud ce probl\u00e8me. On nomme la d\u00e9pendance dont on a besoin. Celle-ci est cherch\u00e9e automatiquement dans des d\u00e9p\u00f4ts Maven r\u00e9partis sur le net. Si la d\u00e9pendance demand\u00e9e a elle-m\u00eame des d\u00e9pendances, alors celles-ci sont automatiquement t\u00e9l\u00e9charg\u00e9es \u00e9galement. Ces d\u00e9pendances t\u00e9l\u00e9charg\u00e9es sont stock\u00e9es dans un d\u00e9p\u00f4t local au poste. Si une autre application a besoin plus tard de la m\u00eame d\u00e9pendance, celle-ci ne sera pas t\u00e9l\u00e9charg\u00e9e mais cherch\u00e9e dans le d\u00e9p\u00f4t local. Une d\u00e9pendance est caract\u00e9ris\u00e9e par les \u00e9l\u00e9ments suivants\u00a0:</p> <ul> <li>ligne 17\u00a0: une balise &lt;dependency&gt;\u00a0;</li> <li>ligne 18\u00a0: un attribut [groupId] qui identifie en g\u00e9n\u00e9ral l'entreprise qui a cr\u00e9\u00e9 la d\u00e9pendance\u00a0;</li> <li>ligne 19\u00a0: un attribut [artifactId] qui identifie la d\u00e9pendance\u00a0;</li> <li> <p>ligne 20\u00a0:  un attribut [version] qui identifie la version d\u00e9sir\u00e9e\u00a0; La g\u00e9n\u00e9ration du projet va elle-m\u00eame produire un composant Maven d\u00e9fini par les lignes 4-8\u00a0:</p> </li> <li> <p>lignes 4-6\u00a0: les attributs [ groupId, artifactId,version] que nous venons de d\u00e9crire\u00a0;</p> </li> <li> <p>lignes 7-8\u00a0: sont des attributs facultatifs\u00a0; Nous allons revenir un peu plus loin sur le r\u00f4le des lignes 24-40. Pour transformer un projet Eclipse ordinaire en un projet Maven, il faut faire deux choses\u00a0:</p> </li> <li> <p>cr\u00e9er le fichier [pom.xml] pr\u00e9c\u00e9dent\u00a0;</p> </li> <li>d\u00e9clarer que le projet est d\u00e9sormais un projet Maven [1-4]\u00a0:</li> </ul> <p>L'ic\u00f4ne d'un projet Maven a un M [4]. Le S indique que le projet a des \u00e9l\u00e9ments Spring. Il est d\u00e9conseill\u00e9 de transformer (comme nous venons de le faire) un projet Eclipse en projet Maven car alors le projet n'a pas la structure attendue pour un projet Maven ce qui peut amener parfois des probl\u00e8mes inattendus.</p>"},{"location":"cours-introduction-au-framework-spring.html#535-generation-de-lartifact-maven-du-projet","title":"5.3.5. G\u00e9n\u00e9ration de l'artifact Maven du projet","text":"<p>Nous appelons artifact Maven du projet, l'\u00e9l\u00e9ment d\u00e9fini par les lignes 4-6 du fichier [pom.xml]\u00a0:</p> <pre><code>    &lt;groupId&gt;istia.st.spring.core&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core-02&lt;/artifactId&gt;\n&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n</code></pre> <p>Pour g\u00e9n\u00e9rer cet artifact, il faut que les lignes 3-7 suivantes soient pr\u00e9sentes dans le fichier [pom.xml]\u00a0:</p> <pre><code>    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <p>Elles d\u00e9finissent le plugin de Maven capable de g\u00e9n\u00e9rer l'artifact du projet. On proc\u00e9de ensuite de la fa\u00e7on suivante\u00a0:</p> <p>L'artifact ainsi g\u00e9n\u00e9r\u00e9 va dans le d\u00e9p\u00f4t Maven local. La localisation de celui-ci peut \u00eatre trouv\u00e9e dans la configuration d'Eclipse\u00a0:</p> <p>Il est alors possible de v\u00e9rifier la bonne installation de l'artifact Maven\u00a0:</p> <p>D\u00e9sormais, un autre projet Maven local pourra utiliser cette archive.</p>"},{"location":"cours-introduction-au-framework-spring.html#54-exemple-03","title":"5.4. Exemple-03","text":""},{"location":"cours-introduction-au-framework-spring.html#541-le-projet-eclipse","title":"5.4.1. Le projet Eclipse","text":"<p>Nous cr\u00e9ons cette fois un projet Maven [1-8]\u00a0:</p> <ul> <li>en [3b]\u00a0: d\u00e9signez un dossier vide o\u00f9 sera g\u00e9n\u00e9r\u00e9 le projet\u00a0;</li> </ul> <ul> <li>en [4]\u00a0: l'identifiant du groupe Maven auquel appartiendra le projet\u00a0;</li> <li>en [5]\u00a0: le nom de l'artifact Maven produit\u00a0:</li> <li>en [6]\u00a0: sa version\u00a0;</li> <li>en [7]: son mode de packaging (il existe \u00e9galement war, ear, apk, ...)\u00a0;</li> <li> <p>en [8]\u00a0: le projet ainsi cr\u00e9\u00e9\u00a0; Un projet Maven a par d\u00e9faut, une arborescence pr\u00e9cise\u00a0:</p> </li> <li> <p>[src / main / java]\u00a0: les codes source du projet. Les produits compil\u00e9s de ces sources iront dans le dossier [target/classes] du projet\u00a0;</p> </li> <li>[src / main / resources]\u00a0: les ressources qui doivent \u00eatre dans le Classpath du projet sans pour autant \u00eatre des sources Java. Elles seront recopi\u00e9es telles-quelles dans le dossier [target/classes] du projet\u00a0;</li> <li>[src / test / java]\u00a0: les codes source des tests du projet. Les produits compil\u00e9s de ces sources iront dans le dossier [target/test-classes] du projet. Ces \u00e9l\u00e9ments ne sont pas int\u00e9gr\u00e9s dans l'archive Maven du projet\u00a0;</li> <li>[src / test / resources]\u00a0: les ressources qui doivent \u00eatre dans le Classpath du projet pour les tests sans pour autant \u00eatre des sources Java. Elles seront recopi\u00e9es telles-quelles dans le dossier [target/test-classes] du projet\u00a0; Nous compl\u00e9tons le projet de la fa\u00e7on suivante\u00a0:</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#542-la-configuration-maven","title":"5.4.2. La configuration Maven","text":"<p>Un fichier [pom.xml] est g\u00e9n\u00e9r\u00e9 par d\u00e9faut. Nous le transformons de la fa\u00e7on suivante\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.spring.core&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core-03&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;spring-core-03&lt;/name&gt;\n    &lt;description&gt;Introduction \u00e0 Spring&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;!-- projet Maven parent --&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Spring Context --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- logs --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;!-- pour la g\u00e9n\u00e9ration de l'archive du projet avec ses d\u00e9pendances --&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;!-- pour l'installation de l'artifact du projet dans le d\u00e9p\u00f4t local Maven --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>ligne 11\u00a0: le projet est cod\u00e9 en UTF-8\u00a0;</li> <li>ligne 12\u00a0: on utilise un JDK 1.8 pour compiler le projet\u00a0;</li> <li>lignes 16-20\u00a0: pour les projets utilisant les biblioth\u00e8ques Spring, il est pratique d'utiliser un projet Maven parent appel\u00e9 [spring-boot-starter-parent]. Celui-ci d\u00e9finit les versions de diff\u00e9rentes biblioth\u00e8ques Spring ainsi que celles de leurs d\u00e9pendances. Ceci permet de ne plus les d\u00e9finir dans la d\u00e9finition des d\u00e9pendances. Ainsi lignes 24-27 on ne pr\u00e9cise pas la version de [spring-context] d\u00e9sir\u00e9e. Ce sera celle d\u00e9finie par le projet parent [spring-boot-starter-parent]. Cette technique permet de ne pas se soucier d'\u00e9ventuelles incompatibilit\u00e9s de versions entre d\u00e9pendances. Celles d\u00e9finies  par le projet parent sont compatibles entre-elles\u00a0;</li> <li>lignes 29-32\u00a0: Spring \u00e9crit un nombre important d'informations sur la console au travers d'une biblioth\u00e8que de logs. Celle-ci est import\u00e9e ici\u00a0;</li> <li>lignes 40-47\u00a0: un plugin Maven sur lequel nous allons revenir\u00a0;</li> <li>lignes 50-52\u00a0: le plugin de g\u00e9n\u00e9ration de l'artifact Maven du projet\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#543-la-classe-de-configuration-de-spring","title":"5.4.3. La classe de configuration de Spring","text":"<p>La classe [Config] est la suivante\u00a0:</p> <pre><code>package istia.st.spring.core.config;\n\nimport istia.st.spring.core.entities.Personne;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan({ \"spring.core.entities\" })\npublic class Config {\n\n    @Bean\n    public Personne personne_01() {\n        return new Personne(\"Paul\", \"Dubois\", 34);\n    }\n\n    @Bean\n    public Personne personne_02() {\n        return new Personne(\"Martin\", \"Micheline\", 18);\n    }\n\n    @Bean\n    public List&lt;Personne&gt; club(Personne personne_01, Personne personne_02) {\n        List&lt;Personne&gt; personnes = new ArrayList&lt;Personne&gt;();\n        personnes.add(personne_01);\n        personnes.add(personne_02);\n        return personnes;\n    }\n\n    @Bean\n    public int mySurface() {\n        return 200;\n    }\n}\n</code></pre> <ul> <li>on retrouve l\u00e0 un code d\u00e9j\u00e0 comment\u00e9 avec deux nouveaut\u00e9s\u00a0:</li> <li>ligne 13\u00a0: indique qu'il y a d'autres beans \u00e0 instancier dans le package [spring.core.entities],</li> <li>lignes 34-37\u00a0: un bean [mySurface]\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#544-la-classe-appartement","title":"5.4.4. La classe [Appartement]","text":"<pre><code>package spring.core.entities;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Appartement {\n\n    // champs inject\u00e9s par Spring\n    @Autowired\n    @Qualifier(\"personne_01\")\n    private Personne propri\u00e9taire;\n\n    @Autowired\n    @Qualifier(\"mySurface\")\n    private int surface;\n\n    // getters et setters\n    public Personne getPropri\u00e9taire() {\n        return propri\u00e9taire;\n    }\n\n    public void setPropri\u00e9taire(Personne propri\u00e9taire) {\n        this.propri\u00e9taire = propri\u00e9taire;\n    }\n\n    public int getSurface() {\n        return surface;\n    }\n\n    public void setSurface(int surface) {\n        this.surface = surface;\n    }\n\n    // toString\n    public String toString() {\n        return String.format(\"Appartement[%s, %s]\", propri\u00e9taire, surface);\n    }\n\n}\n</code></pre> <ul> <li>ligne 7\u00a0: l'annotation [@Component] indique \u00e0 Spring que la classe est un singleton que le framework doit instancier et g\u00e9rer. C'est parce que dans la classe [Config], nous avons \u00e9crit [@ComponentScan({ \"istia.st.spring.core.entities\" })] que ce singleton va \u00eatre trouv\u00e9\u00a0;</li> <li>ligne 11\u00a0: demande \u00e0 Spring d'injecter dans le champ la r\u00e9f\u00e9rence d'un des singletons. Celui-ci peut \u00eatre d\u00e9fini de deux fa\u00e7ons\u00a0:</li> <li>par son identifiant (lignes 12, 16),</li> <li>par son type s'il n'y a qu'un singleton ayant ce type\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#545-execution-du-projet","title":"5.4.5. Ex\u00e9cution du projet","text":"<p>L'ex\u00e9cution du projet donne le r\u00e9sultat suivant dans la console\u00a0:</p> <pre><code>17:32:39.797 [main] DEBUG o.s.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence\n....\n17:32:40.134 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Returning cached instance of singleton bean 'appartement'\npersonnes--------\nPersonne[Dubois, Paul,34]\nPersonne[Micheline, Martin,18]\nclub--------\nPersonne[Dubois, Paul,34]\nPersonne[Micheline, Martin,18]\nappartement--------\nAppartement[Personne[Dubois, Paul,34], 200]\n17:32:40.135 [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Returning cached instance of singleton bean 'personne_01'\nbeans [p01,p01b] identiques ? true\n</code></pre> <ul> <li>lignes 1-3\u00a0: Spring g\u00e9n\u00e8re un tr\u00e8s grand nombre de logs, plusieurs dizaines de lignes. Ces logs peuvent \u00eatre tr\u00e8s utiles pour d\u00e9boguer un projet qui ne marche pas. Lorsqu'il fonctionne, on peut r\u00e9duire les logs de la fa\u00e7on suivante\u00a0:</li> </ul> <p>Dans le dossier [src / main / resources] on cr\u00e9e le fichier [logback.xml] suivant\u00a0:</p> <pre><code>&lt;configuration&gt; \n\n  &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; \n    &lt;!-- encoders are  by default assigned the type\n         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;\n    &lt;encoder&gt;\n      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n    &lt;/encoder&gt;\n  &lt;/appender&gt;\n\n  &lt;!-- contr\u00f4le niveau des logs --&gt;\n  &lt;root level=\"info\"&gt; &lt;!-- info, debug, warn --&gt;\n    &lt;appender-ref ref=\"STDOUT\" /&gt;\n  &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <ul> <li>ligne 12, on fixe le niveau des logs. [debug] est un niveau tr\u00e8s d\u00e9taill\u00e9, [info] beaucoup moins\u00a0; Voici les r\u00e9sultats avec [level=info]\u00a0:</li> </ul> <pre><code>17:39:58.580 [main] INFO  o.s.c.a.AnnotationConfigApplicationContext - Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@7cf10a6f: startup date [Tue Apr 07 17:39:58 CEST 2015]; root of context hierarchy\npersonnes--------\nPersonne[Dubois, Paul,34]\nPersonne[Micheline, Martin,18]\nclub--------\nPersonne[Dubois, Paul,34]\nPersonne[Micheline, Martin,18]\nappartement--------\nAppartement[Personne[Dubois, Paul,34], 200]\nbeans [p01,p01b] identiques ? true\n</code></pre> <p>Il n'y a plus qu'une ligne de logs.</p>"},{"location":"cours-introduction-au-framework-spring.html#546-generation-de-larchive-du-projet-avec-ses-dependances","title":"5.4.6. G\u00e9n\u00e9ration de l'archive du projet avec ses d\u00e9pendances","text":"<p>L'archive cr\u00e9\u00e9e dans le projet pr\u00e9c\u00e9dent peut \u00eatre \u00e9galement utilis\u00e9e par un projet Eclipse non Maven. Certains projets utilisent de nombreuses biblioth\u00e8ques et il peut \u00eatre d\u00e9licat de ne pas en oublier. C'est l\u00e0 que Maven fait merveille car il suffit de nommer la d\u00e9pendance de niveau le plus haut pour que les autres de niveau plus bas soient automatiquement ajout\u00e9es au Classpath du projet.  Lorsque qu'un projet Eclipse non Maven doit utiliser les archives d'un projet Maven, il est possible de g\u00e9n\u00e9rer l'artifact de ce dernier avec toutes ses d\u00e9pendances (ce qui n'\u00e9tait pas le cas dans le projet pr\u00e9c\u00e9dent). Pour cette g\u00e9n\u00e9ration, il faut que les lignes 3-10 suivantes soient pr\u00e9sentes dans le fichier [pom.xml]\u00a0:</p> <pre><code>    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <p>Elles d\u00e9finissent le plugin de Maven capable de g\u00e9n\u00e9rer l'artifact du projet avec ses d\u00e9pendances. Ensuite on proc\u00e8de de la fa\u00e7on suivante [1-6]\u00a0:</p> <ul> <li>[4-6] repr\u00e9sentent une configuration d'ex\u00e9cution Maven\u00a0;</li> <li>en [4], mettre un nom quelconque\u00a0;</li> <li>en [5], d\u00e9signer le dossier du projet\u00a0;</li> <li>en [6], mettre les cibles Maven (goals)\u00a0:</li> <li>[clean]\u00a0: le dossier [target] du projet est supprim\u00e9\u00a0;</li> <li>[compile]\u00a0: le projet est compil\u00e9. Les produits de la compilation sont plac\u00e9s dans un dossier [target] r\u00e9g\u00e9n\u00e9r\u00e9\u00a0;</li> <li>[assembly:single]\u00a0: les classes du projet et de ses d\u00e9pendances sont plac\u00e9es dans une unique archive jar dans le dossier [target]\u00a0; Apr\u00e8s ex\u00e9cution, on obtient le r\u00e9sultat suivant\u00a0:</li> </ul> <p>Une archive jar est un fichier zipp\u00e9 qu'on peut donc ouvrir avec un d\u00e9zippeur. Une fois l'archive pr\u00e9c\u00e9dente d\u00e9zipp\u00e9e, on obtient l'arborescence suivante\u00a0:</p> <ul> <li>en [8], les classes des d\u00e9pendances du projet\u00a0;</li> <li>en [9], les classes du projet lui-m\u00eame\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#55-exemple-04","title":"5.5. Exemple-04","text":""},{"location":"cours-introduction-au-framework-spring.html#551-objectif","title":"5.5.1. Objectif","text":"<p>Cet exemple reprend l'un de ceux pr\u00e9sent\u00e9s dans le document [Introduction \u00e0 Spring IoC] dans lequel on montre l'apport de Spring pour la configuration d'architectures multi-couche. Dans le document original, l'exemple est trait\u00e9 avec une configuration Spring faite avec un fichier XML. Ici nous traitons l'exemple avec une configuration par classes Java et annotations.</p> <p>On veut ici configurer un projet Spring pour l'architecture suivante:</p> <p>Chaque couche pr\u00e9sente une interface impl\u00e9ment\u00e9e avec deux classes. On veut montrer que gr\u00e2ce \u00e0 Spring, on peut changer l'impl\u00e9mentation d'une couche avec un impact z\u00e9ro sur le code des autres couches.</p>"},{"location":"cours-introduction-au-framework-spring.html#552-le-projet-eclipse","title":"5.5.2. Le projet Eclipse","text":""},{"location":"cours-introduction-au-framework-spring.html#5521-generation","title":"5.5.2.1. G\u00e9n\u00e9ration","text":"<p>Nous cr\u00e9ons un nouveau type de projet\u00a0:</p> <ul> <li>en  [4], mettre le nom du projet Eclipse\u00a0;</li> <li>en [5], choisir un projet Maven\u00a0;</li> <li>en [6], choisir une version de Java &gt;=1.7\u00a0;</li> <li>en [7], choisir la version de Spring Boot propos\u00e9e\u00a0;</li> <li>les informations [8-11] sont des informations Maven\u00a0;</li> <li>en [12], on peut choisir une ou plusieurs des d\u00e9pendances propos\u00e9es. Cela va avoir pour effet d'int\u00e9grer dans le fichier [pom.xml] de Maven, un certain nombre de d\u00e9pendances\u00a0;</li> </ul> <ul> <li>en [13], d\u00e9signer un dossier existant et vide pour accueillir le projet\u00a0;</li> <li>en [14], le projet g\u00e9n\u00e9r\u00e9. Nous allons en diss\u00e9quer les \u00e9l\u00e9ments\u00a0; Le projet est un projet Maven configur\u00e9 par le fichier [pom.xml] suivant\u00a0:</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;istia.st.spring.core&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-core-04&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;spring-core-04&lt;/name&gt;\n    &lt;description&gt;Programmation par interfaces&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;start-class&gt;demo.SpringCore04Application&lt;/start-class&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 6-12\u00a0: reprennent les informations saisies dans l'assistant de r\u00e9ation du projet\u00a0;</li> <li>lignes 14-19\u00a0: le projet Maven parent qui d\u00e9finit un certain nombre de biblioth\u00e8ques avec leurs versions. Si l'une d'elles est une d\u00e9pendance du projet, elle est mentionn\u00e9e dans le fichier [pom.xml] sans sa version\u00a0;</li> <li>ligne 23\u00a0: cette ligne ne sert que si on a l'intention de g\u00e9n\u00e9rer une archive ex\u00e9cutable du projet. Elle est inutilis\u00e9e sinon\u00a0;</li> <li>lignes 28-31\u00a0: la d\u00e9pendance minimale d'un projet Spring Boot. On rappelle que nous n'avons s\u00e9lectionn\u00e9 aucune d\u00e9pendance dans la liste \u00e0 cocher\u00a0;</li> <li>lignes 33-37\u00a0: la d\u00e9pendance n\u00e9cessaire pour g\u00e9rer des tests unitaires JUnit [http://junit.org/] int\u00e9gr\u00e9s avec Spring. La ligne 36 indique que la d\u00e9pendance n'est n\u00e9cessaire que pour les tests. En cons\u00e9quence, elle ne sera pas int\u00e9gr\u00e9e \u00e0 l'archive du projet\u00a0;</li> <li>lignes 42-45\u00a0: le plugin qui permet de g\u00e9n\u00e9rer l'artifact Maven du projet\u00a0; La liste des d\u00e9pendances amen\u00e9e par ce fichier est la suivante [1]\u00a0:</li> </ul> <p>Nous allons voir qu'elles sont suffisantes pour ce qu'on veut faire ici.</p>"},{"location":"cours-introduction-au-framework-spring.html#5522-la-classe-executable","title":"5.5.2.2. La classe ex\u00e9cutable","text":"<p>La classe ex\u00e9cutable [SpringCore04Application] [[2] est la suivante\u00a0:</p> <pre><code>package demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringCore04Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringCore04Application.class, args);\n    }\n}\n</code></pre> <ul> <li>ligne 6, l'annotation [@SpringBootApplication] est un raccourci pour les trois annotations [@Configuration, @EnableAutoConfiguration, @ComponentScan] ce qui signifie\u00a0:</li> <li>que la classe [SpringCore04Application] est une classe de configuration Spring\u00a0;</li> <li>qu'il est demand\u00e9 \u00e0 Spring Boot d'op\u00e9rer des configurations \u00e0 partir des classes qu'il va trouver dans le Classpath du projet, donc ici dans les d\u00e9pendances Maven\u00a0;</li> <li>d'examiner le dossier courant (celui de la classe [SpringCore04Application]) pour y trouver d'\u00e9ventuels autres composants Spring\u00a0;</li> <li> <p>ligne 10\u00a0: la m\u00e9thode statique [SpringApplication.run] est ex\u00e9cut\u00e9e. Son premier param\u00e8tre est une classe de configuration Spring, ici la classe [SpringCore04Application]. Son deuxi\u00e8me param\u00e8tre est ici la liste des arguments pass\u00e9s \u00e0 la m\u00e9thode [main] (ligne 9). La m\u00e9thode statique [SpringApplication.run] a pour r\u00f4le de cr\u00e9er le contexte Spring, \u00e7-\u00e0-d cr\u00e9er les diff\u00e9rents beans trouv\u00e9s soit dans les classes de configuration soit dans les dossiers explor\u00e9s par l'annotation [@ComponentScan]. La m\u00e9thode [main] ici ne fait rien d'autre. Pour lui donner un peu plus de substance, nous allons la transformer de la fa\u00e7on suivante\u00a0: <pre><code>package demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n\n@SpringBootApplication\npublic class SpringCore04Application {\n\n    public static void main(String[] args) {\n        // instanciation du contexte Spring\n        ConfigurableApplicationContext context = SpringApplication.run(SpringCore04Application.class, args);\n        // affichage du contexte\n        System.out.println(\"---------------- Liste des beans Spring\");\n        for (String beanName : context.getBeanDefinitionNames()) {\n            System.out.println(beanName);\n        }\n        // fermeture contexte\n        context.close();\n    }\n}\n</code></pre></p> </li> <li> <p>ligne 12\u00a0: la m\u00e9thode statique [SpringApplication.run] rend le contexte Spring qu'elle a construit\u00a0;</p> </li> <li>lignes 15-17\u00a0: on affiche le nom de tous les beans de ce contexte\u00a0; On peut ex\u00e9cuter l'application de la fa\u00e7on suivante [1-3]. La m\u00e9thode habituelle [Run As Java Application] est \u00e9galement valide.</li> </ul> <p>On obtient le r\u00e9sultat suivant\u00a0:</p> <pre><code>  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.2.3.RELEASE)\n\n2015-04-08 11:18:38.254  INFO 4796 --- [           main] demo.SpringCore04Application             : Starting SpringCore04Application on Gportpers3 with PID 4796 (D:\\data\\istia-1415\\polys\\istia\\dvp-spring-database\\codes\\original\\intro-spring-core\\spring-core-04\\target\\classes started by ST in D:\\data\\istia-1415\\polys\\istia\\dvp-spring-database\\codes\\original\\intro-spring-core\\spring-core-04)\n2015-04-08 11:18:38.295  INFO 4796 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@64485a47: startup date [Wed Apr 08 11:18:38 CEST 2015]; root of context hierarchy\n2015-04-08 11:18:38.776  INFO 4796 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2015-04-08 11:18:38.788  INFO 4796 --- [           main] demo.SpringCore04Application             : Started SpringCore04Application in 0.773 seconds (JVM running for 1.335)\n---------------- Liste des beans Spring\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalRequiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\nspringCore04Application\norg.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor\norg.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor\norg.springframework.boot.autoconfigure.AutoConfigurationPackages\norg.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration\norg.springframework.boot.autoconfigure.condition.BeanTypeRegistry\npropertySourcesPlaceholderConfigurer\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration\nmbeanExporter\nobjectNamingStrategy\nmbeanServer\n2015-04-08 11:18:38.789  INFO 4796 --- [           main] s.c.a.AnnotationConfigApplicationContext : Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@64485a47: startup date [Wed Apr 08 11:18:38 CEST 2015]; root of context hierarchy\n2015-04-08 11:18:38.790  INFO 4796 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown\n</code></pre> <ul> <li>lignes 14-28\u00a0: les beans du contexte Spring. Nous ne connaissons pas leur r\u00f4le. Nous retrouvons le bean [springCore04Application] ligne 18 qui de par son annotation [@SpringBootApplication] devient automatiquement un bean Spring\u00a0;</li> <li>les autres lignes sont des logs de Spring de niveau [INFO]. Comme nous l'avons d\u00e9j\u00e0 vu, ces logs peuvent \u00eatre contr\u00f4l\u00e9s par le fichier [logback.xml] plac\u00e9 dans le Classpath du projet\u00a0:</li> </ul> <pre><code>&lt;configuration&gt; \n\n  &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; \n    &lt;!-- encoders are  by default assigned the type\n         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;\n    &lt;encoder&gt;\n      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n    &lt;/encoder&gt;\n  &lt;/appender&gt;\n\n  &lt;!-- contr\u00f4le niveau des logs --&gt;\n  &lt;root level=\"warn\"&gt; &lt;!-- info, debug, warn --&gt;\n    &lt;appender-ref ref=\"STDOUT\" /&gt;\n  &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Si ligne 12 ci-dessus, on met le niveau [warn] \u00e0 la place de [info], on obtient le r\u00e9sultat suivant\u00a0:</p> <pre><code>  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.2.3.RELEASE)\n\n---------------- Liste des beans Spring\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalRequiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\nspringCore04Application\norg.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor\norg.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor\norg.springframework.boot.autoconfigure.AutoConfigurationPackages\norg.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration\norg.springframework.boot.autoconfigure.condition.BeanTypeRegistry\npropertySourcesPlaceholderConfigurer\norg.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration\nmbeanExporter\nobjectNamingStrategy\nmbeanServer\n</code></pre> <p>Les logs ont disparu. N'apparaissent que les messages de niveau [warn] et ici il n'y en pas eu.</p>"},{"location":"cours-introduction-au-framework-spring.html#553-implementation-des-differentes-couches-de-larchitecture","title":"5.5.3. Impl\u00e9mentation des diff\u00e9rentes couches de l'architecture","text":"<p>Nous allons maintenant impl\u00e9menter les trois couches de l'architecture ci-dessus\u00a0:</p> <p>La couche [DAO] est impl\u00e9ment\u00e9e par le package [spring.core.dao]. Elle pr\u00e9sente l'interface [IDao] suivante\u00a0:</p> <pre><code>package spring.core.dao;\n\npublic interface IDao {\n\n    public int doSomethingInDaoLayer(int a, int b);\n}\n</code></pre> <p>Cette interface a deux impl\u00e9mentations\u00a0: [Dao1] et [Dao2]\u00a0:</p> <pre><code>package spring.core.dao;\n\npublic class Dao1 implements IDao {\n\n    public int doSomethingInDaoLayer(int a, int b) {\n        return a+b;\n    }\n\n}\n</code></pre> <pre><code>package spring.core.dao;\n\npublic class Dao2 implements IDao {\n\n    public int doSomethingInDaoLayer(int a, int b) {\n        return a-b;\n    }\n\n}\n</code></pre> <p>La couche [m\u00e9tier] est impl\u00e9ment\u00e9e par le package [spring.core.metier]. Elle pr\u00e9sente l'interface [IMetier] suivante\u00a0:</p> <pre><code>package spring.core.metier;\n\npublic interface IMetier {\n\n    public int doSomethingInMetierLayer(int a, int b);\n}\n</code></pre> <p>Cette interface a deux impl\u00e9mentations\u00a0: [Metier1] et [Metier2]\u00a0:</p> <pre><code>package spring.core.metier;\n\nimport spring.core.dao.IDao;\n\npublic class Metier1 implements IMetier {\n\n    private IDao dao;\n\n    public int doSomethingInMetierLayer(int a, int b) {\n        a++;\n        b++;\n        return dao.doSomethingInDaoLayer(a, b);\n    }\n\n    public void setDao(IDao dao) {\n        this.dao = dao;\n    }\n}\n</code></pre> <pre><code>package spring.core.metier;\n\nimport spring.core.dao.IDao;\n\npublic class Metier2 implements IMetier {\n\n    private IDao dao;\n\n    public int doSomethingInMetierLayer(int a, int b) {\n        a--;\n        b++;\n        return dao.doSomethingInDaoLayer(a, b);\n    }\n\n    public void setDao(IDao dao) {\n        this.dao = dao;\n    }\n\n\n}\n</code></pre> <p>La couche [UI] est impl\u00e9ment\u00e9e par le package [spring.core.ui]. Elle pr\u00e9sente l'interface [IUi] suivante\u00a0:</p> <pre><code>package spring.core.ui;\n\npublic interface IUi {\n\n    public int doSomethingInUiLayer(int a, int b);\n}\n</code></pre> <p>Cette interface a deux impl\u00e9mentations\u00a0: [Ui1] et [Ui2]\u00a0:</p> <pre><code>package spring.core.ui;\n\nimport spring.core.metier.IMetier;\n\npublic class Ui1 implements IUi {\n\n    private IMetier metier;\n\n    public int doSomethingInUiLayer(int a, int b) {\n        a++;\n        b++;\n        return metier.doSomethingInMetierLayer(a, b);\n    }\n\n    public void setMetier(IMetier metier) {\n        this.metier = metier;\n    }\n\n}\n</code></pre> <pre><code>package spring.core.ui;\n\nimport spring.core.metier.IMetier;\n\npublic class Ui2 implements IUi {\n\n    private IMetier metier;\n\n    public int doSomethingInUiLayer(int a, int b) {\n        a--;\n        b++;\n        return metier.doSomethingInMetierLayer(a, b);\n    }\n\n    public void setMetier(IMetier metier) {\n        this.metier = metier;\n    }\n\n}\n</code></pre>"},{"location":"cours-introduction-au-framework-spring.html#554-configuration-du-projet-spring","title":"5.5.4. Configuration du projet Spring","text":"<p>La classe de configuration [Config] est la suivante\u00a0:</p> <pre><code>package spring.core.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport spring.core.dao.Dao1;\nimport spring.core.dao.Dao2;\nimport spring.core.dao.IDao;\nimport spring.core.metier.IMetier;\nimport spring.core.metier.Metier1;\nimport spring.core.metier.Metier2;\nimport spring.core.ui.IUi;\nimport spring.core.ui.Ui1;\nimport spring.core.ui.Ui2;\n\n@Configuration\npublic class Config {\n\n    // -------------- impl\u00e9mentation [Ui1, Metier1, Dao1]\n    @Bean\n    public IDao dao1() {\n        return new Dao1();\n    }\n\n    @Bean\n    public IMetier metier1(IDao dao1) {\n        Metier1 metier = new Metier1();\n        metier.setDao(dao1);\n        return metier;\n    }\n\n    @Bean\n    public IUi ui1(IMetier metier1) {\n        Ui1 ui = new Ui1();\n        ui.setMetier(metier1);\n        return ui;\n    }\n\n    // -------------- impl\u00e9mentation [Ui2, Metier2, Dao2]\n    @Bean\n    public IDao dao2() {\n        return new Dao2();\n    }\n\n    @Bean\n    public IMetier metier2(IDao dao2) {\n        Metier2 metier = new Metier2();\n        metier.setDao(dao2);\n        return metier;\n    }\n\n    @Bean\n    public IUi ui2(IMetier metier2) {\n        Ui2 ui = new Ui2();\n        ui.setMetier(metier2);\n        return ui;\n    }\n}\n</code></pre> <ul> <li>lignes 20-23\u00a0: le bean nomm\u00e9 [dao1] (nom de la m\u00e9thode) est une instance de la classe [Dao1] (ligne 22) consid\u00e9r\u00e9e comme une impl\u00e9mentation de l'interface [IDao] (ligne 21). Le bean [dao1] est donc vu comme une instance d'interface (la terminologie est incorrecte mais elle peut se comprendre) et non une instance de classe. C'est un point important \u00e0 comprendre. Tous les autres beans vont \u00eatre eux aussi des instances d'interfaces\u00a0;</li> <li>lignes 25-30\u00a0: une instance de l'interface [IMetier] impl\u00e9ment\u00e9e par la classe [Metier1]\u00a0;</li> <li>lignes 32-37\u00a0: une instance de l'interface [IUi] impl\u00e9ment\u00e9e par la classe [Ui1]\u00a0;</li> <li>lignes 20-37\u00a0: impl\u00e9mentent les couches [UI, Metier, DAO] avec des instances [Ui1, Metier1, Dao1]\u00a0;</li> <li>lignes 40-57\u00a0: impl\u00e9mentent les couches [UI, Metier, DAO] avec des instances [Ui2, Metier2, Dao2]\u00a0;</li> </ul>"},{"location":"cours-introduction-au-framework-spring.html#555-test-unitaire-junittest","title":"5.5.5. Test unitaire [JUnitTest]","text":"<p>La classe [JUnitTest] est mise dans la branche [src / test / java] du projet Maven. Les \u00e9l\u00e9ments de cette branche ne sont pas plac\u00e9s dans l'archive finale du projet. Son code est le suivant\u00a0:</p> <pre><code>package spring.core.tests;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport spring.core.config.Config;\nimport spring.core.dao.IDao;\nimport spring.core.metier.IMetier;\nimport spring.core.ui.IUi;\n\n@SpringApplicationConfiguration(classes = { Config.class })\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class JUnitTest {\n...\n}\n</code></pre> <ul> <li>ligne 16\u00a0: l'annotation [@SpringApplicationConfiguration] est une annotation du projet Spring Boot Test (ligne 8). Elle est amen\u00e9e par la d\u00e9pendance suivante du fichier [pom.xml]\u00a0: <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></li> </ul> <p>Cette annotation a pour param\u00e8tre la liste des classes de configuration \u00e0 utiliser pour construire le contexte Spring n\u00e9cessaire au test. Ici nous utilisons la classe de configuration [Config] d\u00e9j\u00e0 pr\u00e9sent\u00e9e\u00a0;</p> <ul> <li>ligne 17\u00a0: l'annotation [@RunWith] est une annotation JUnit (ligne 5). Son param\u00e8tre est la classe charg\u00e9e de conduire les tests \u00e0 la place de la classe par d\u00e9faut du framework Junit. Cette classe est une classe Spring (ligne 9). Elle va utiliser les annotations Spring pr\u00e9sentes dans la classe de test\u00a0; La classe compl\u00e8te est la suivante</li> </ul> <pre><code>...\n\n@SpringApplicationConfiguration(classes = { Config.class })\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class JUnitTest {\n\n    // couche [UI]\n    @Autowired\n    @Qualifier(\"ui1\")\n    private IUi ui1;\n\n    @Autowired\n    @Qualifier(\"ui2\")\n    private IUi ui2;\n\n    // couche [m\u00e9tier]\n    @Autowired\n    @Qualifier(\"metier1\")\n    private IMetier metier1;\n\n    @Autowired\n    @Qualifier(\"metier2\")\n    private IMetier metier2;\n\n    // couche [dao]\n    @Autowired\n    @Qualifier(\"dao1\")\n    private IDao dao1;\n\n    @Autowired\n    @Qualifier(\"dao2\")\n    private IDao dao2;\n\n    @Test\n    public void testDao() {\n        Assert.assertEquals(30, dao1.doSomethingInDaoLayer(10, 20));\n        Assert.assertEquals(-10, dao2.doSomethingInDaoLayer(10, 20));\n    }\n\n    @Test\n    public void testMetier() {\n        Assert.assertEquals(32, metier1.doSomethingInMetierLayer(10, 20));\n        Assert.assertEquals(-12, metier2.doSomethingInMetierLayer(10, 20));\n    }\n\n    @Test\n    public void testUI() {\n        Assert.assertEquals(34, ui1.doSomethingInUiLayer(10, 20));\n        Assert.assertEquals(-14, ui2.doSomethingInUiLayer(10, 20));\n    }\n\n}\n</code></pre> <ul> <li>lignes 8-10\u00a0: on injecte (ligne 8) le bean nomm\u00e9 (ligne 9) [ui1]. On remarquera ligne 10 qu'on injecte une instance d'interface et non une instance de classe\u00a0;</li> <li>lignes 21-32\u00a0: on injecte de la m\u00eame fa\u00e7on les autres beans d\u00e9finis dans la classe [Config]\u00a0;</li> <li>ligne 34\u00a0: l'annotation [@Test] d\u00e9signe une m\u00e9thode \u00e0 ex\u00e9cuter au cours des tests. Les autres annotations possibles sont les suivantes\u00a0:</li> <li>[@BeforeClass]\u00a0: m\u00e9thode \u00e0 ex\u00e9cuter avant de commencer les tests\u00a0;</li> <li>[@AfterClass]\u00a0: m\u00e9thode \u00e0 ex\u00e9cuter une fois tous les tests faits\u00a0;</li> <li>[@Before]\u00a0: m\u00e9thode \u00e0 ex\u00e9cuter avant chaque test\u00a0;</li> <li>[@After]\u00a0: m\u00e9thode \u00e0 ex\u00e9cuter apr\u00e8s chaque test\u00a0;</li> <li>line 36\u00a0: on v\u00e9rifie que l'appel [dao1.doSomethingInDaoLayer(10, 20)] rend bien 30. Le premier param\u00e8tre est par convention, la valeur attendue et le second la valeur r\u00e9elle\u00a0;</li> <li>ligne 36\u00a0: teste l'instance [dao1] de l'interface [IDao]\u00a0;</li> <li>ligne 37\u00a0: teste l'instance [dao2] de l'interface [IDao]\u00a0;</li> <li>ligne 42\u00a0: teste l'instance [metier1] de l'interface [IMetier]\u00a0;</li> <li>ligne 43\u00a0: teste l'instance [metier2] de l'interface [IMetier]\u00a0;</li> <li>ligne 48\u00a0: teste l'instance [ui1] de l'interface [IUi]\u00a0;</li> <li> <p>ligne 36\u00a0: teste l'instance [ui2] de l'interface [IUi]\u00a0; Les assertions utilisables dans une m\u00e9thode de test sont les suivantes\u00a0:</p> </li> <li> <p>assertEquals(expression1, expression2) : v\u00e9rifie que les valeurs des deux expressions sont \u00e9gales. De nombreux types d'expression sont accept\u00e9s (int, String, float, double, boolean, char, short). Si les deux expressions ne sont pas \u00e9gales, alors une exception de type [AssertionFailedError ] est lanc\u00e9e,</p> </li> <li>assertEquals(r\u00e9el1, r\u00e9el2, delta) : v\u00e9rifie que deux r\u00e9els sont \u00e9gaux \u00e0 delta pr\u00e8s, c.a.d abs(r\u00e9el1-r\u00e9el2)&lt;=delta. On pourra \u00e9crire par exemple assertEquals(r\u00e9el1, r\u00e9el2, 1E-6) pour v\u00e9rifier que deux valeurs sont \u00e9gales \u00e0 10-6 pr\u00e8s,</li> <li>assertEquals(message, expression1, expression2) et assertEquals(message, r\u00e9el1, r\u00e9el2, delta) sont des variantes permettant de pr\u00e9ciser le message d'erreur \u00e0 associer \u00e0 l'exception  de type [AssertionFailedError] lanc\u00e9e lorsque la m\u00e9thode [assertEquals] \u00e9choue,</li> <li>assertNotNull(Object) et assertNotNull(message, Object) : v\u00e9rifie que la r\u00e9f\u00e9rence Object n'est pas \u00e9gale \u00e0 null,</li> <li>assertNull(Object) et assertNull(message, Object) : v\u00e9rifie que la r\u00e9f\u00e9rence Object est \u00e9gale \u00e0 null,</li> <li>assertSame(Object1, Object2) et assertSame(message, Object1, Object2) : v\u00e9rifie que les r\u00e9f\u00e9rences Object1 et Object2 pointent sur le m\u00eame objet,</li> <li>assertNotSame(Object1, Object2) et assertNotSame(message, Object1, Object2) : v\u00e9rifie que les r\u00e9f\u00e9rences Object1 et Object2 ne pointent pas sur le m\u00eame objet\u00a0; Pour ex\u00e9cuter le test, on peut proc\u00e9der de la fa\u00e7on suivante\u00a0:</li> </ul> <p>On obtient le r\u00e9sultat suivant\u00a0:</p> <p>Ici tous les test ont r\u00e9ussi. Au fait que montre cet exemple\u00a0? Il montre la souplesse apport\u00e9e par le framework Spring dans la configuration d'une architecture en couches. On peut d\u00e9cider d'utiliser l'impl\u00e9mentation [Ui1, Metier1, Dao1] ou [Ui2, Metier2, Dao2] simplement par configuration. Ainsi dans le test JUnit pr\u00e9c\u00e9dent, si on ne garde que l'injection des beans [ui1, metier1, dao1] on travaille avec la 1\u00e8re architecture. Pour changer d'architecture, il suffit de changer les beans inject\u00e9s. Cela se fait sans changement de code des couches impl\u00e9mentant les interfaces. On appelle ce type de programmation, programmation par interfaces car on n'utilise pas les instances des classes impl\u00e9mentant les couches mais les instances de leurs interfaces.</p>"},{"location":"cours-introduction-au-framework-spring.html#56-conclusion","title":"5.6. Conclusion","text":"<ul> <li>Spring g\u00e8re des objets qui sont des singletons (un seul exemplaire). Spring g\u00e8re \u00e9galement des objets qui sont instanci\u00e9s \u00e0 chaque fois qu'on en demande une instance \u00e0 Spring. Ce cas sera \u00e9galement pr\u00e9sent\u00e9 dans ce document\u00a0;</li> <li>ces objets peuvent \u00eatre d\u00e9clar\u00e9s de diverses fa\u00e7ons qui peuvent \u00eatre mix\u00e9es\u00a0:</li> <li>dans un fichier XML,</li> <li>dans une classe Java annot\u00e9e par [@Configuration],</li> <li>avec n'importe quelle classe Java annot\u00e9e par [@Component, @Service, ...]\u00a0;</li> <li>un objet Spring peut \u00eatre inject\u00e9 dans un autre objet Spring avec l'annotation [@Autowired]. On parle alors d'injection de d\u00e9pendances (DI\u00a0: Dependency Injection)\u00a0;</li> <li>Spring se montre tr\u00e8s pratique pour configurer des architectures en couches avec l'utilisation conjointe du paradigme de de la programmation par interfaces\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html","title":"16. [Cours]\u00a0: S\u00e9curiser l'acc\u00e8s \u00e0 un service web avec Spring Security","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, service web / jSON s\u00e9curis\u00e9, client / serveur</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#161-support","title":"16.1. Support","text":"<p>Les projets de ce chapitre seront trouv\u00e9s dans le dossier [support / chap-16]. Le script SQL sert \u00e0 g\u00e9n\u00e9rer la base de donn\u00e9es n\u00e9cessaire aux tests.</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#162-la-place-de-spring-security-dans-une-application-web","title":"16.2. La place de Spring Security dans une application Web","text":"<p>Situons Spring Security dans le d\u00e9veloppement d'une application Web. Le plus souvent, celle-ci sera b\u00e2tie sur une architecture multicouche telle que la suivante\u00a0:</p> <ul> <li>la couche [Spring Security] n'accorde l'acc\u00e8s \u00e0 la couche [web] qu'aux utilisateurs autoris\u00e9s.</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#163-un-tutoriel-sur-spring-security","title":"16.3. Un tutoriel sur Spring Security","text":"<p>Nous allons de nouveau importer un guide Spring en suivant les \u00e9tapes 1 \u00e0 3 ci-dessous\u00a0:</p> <p>Le projet se compose des \u00e9l\u00e9ments suivants\u00a0:</p> <ul> <li>dans le dossier [templates], on trouve les pages HTML du projet\u00a0;</li> <li>[Application]\u00a0: est la classe ex\u00e9cutable du projet\u00a0;</li> <li>[MvcConfig]\u00a0: est la classe de configuration de Spring MVC\u00a0;</li> <li>[WebSecurityConfig]\u00a0: est la classe de configuration de Spring Security\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1631-configuration-maven","title":"16.3.1. Configuration Maven","text":"<p>Le projet [3] est un projet Maven. Examinons son fichier [pom.xml] pour conna\u00eetre ses d\u00e9pendances\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;gs-securing-web&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- tag::security[] --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- end::security[] --&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;start-class&gt;hello.Application&lt;/start-class&gt;\n    &lt;/properties&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 10-14\u00a0: le projet est un projet Spring Boot\u00a0;</li> <li>lignes 17-20\u00a0: d\u00e9pendance sur le framework [Thymeleaf]\u00a0;</li> <li>lignes 22-25\u00a0: d\u00e9pendance sur le framework Spring Security\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1632-les-vues-thymeleaf","title":"16.3.2. Les vues Thymeleaf","text":"<p>La vue [home.html] est la suivante\u00a0:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n    xmlns:th=\"http://www.thymeleaf.org\"\n    xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n&lt;head&gt;\n&lt;title&gt;Spring Security Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome!&lt;/h1&gt;\n\n    &lt;p&gt;\n        Click &lt;a th:href=\"@{/hello}\"&gt;here&lt;/a&gt; to see a greeting.\n    &lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 12\u00a0: l'attribut [th:href=\"@{/hello}\"] va g\u00e9n\u00e9rer l'attribut [href] de la balise [&lt;a&gt;]. La valeur [@{/hello}] va g\u00e9n\u00e9rer le chemin [&lt;context&gt;/hello] o\u00f9 [context] est le contexte de l'application web\u00a0; Le code HTML g\u00e9n\u00e9r\u00e9 est le suivant\u00a0:</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;Spring Security Example&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Welcome!&lt;/h1&gt;\n\n        &lt;p&gt;\n            Click\n            &lt;a href=\"/hello\"&gt;here&lt;/a&gt;\n            to see a greeting.\n        &lt;/p&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>La vue [hello.html] est la suivante\u00a0:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n    xmlns:th=\"http://www.thymeleaf.org\"\n    xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n&lt;head&gt;\n&lt;title&gt;Hello World!&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1 th:inline=\"text\"&gt;Hello [[${#httpServletRequest.remoteUser}]]!&lt;/h1&gt;\n    &lt;form th:action=\"@{/logout}\" method=\"post\"&gt;\n        &lt;input type=\"submit\" value=\"Sign Out\" /&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 9\u00a0: L'attribut [th:inline=\"text\"] va g\u00e9n\u00e9rer le texte de la balise [&lt;h1&gt;]. Ce texte contient une expression $ qui doit \u00eatre \u00e9valu\u00e9e. L'\u00e9l\u00e9ment [[${#httpServletRequest.remoteUser}]] est la valeur de l'attribut [RemoteUser] de la requ\u00eate HTTP courante. C'est le nom de l'utilisateur connect\u00e9\u00a0;</li> <li>ligne 10\u00a0: un formulaire HTML. L'attribut [th:action=\"@{/logout}\"] va g\u00e9n\u00e9rer l'attribut [action] de la balise [form]. La valeur [@{/logout}] va g\u00e9n\u00e9rer le chemin [&lt;context&gt;/logout] o\u00f9 [context] est le contexte de l'application web\u00a0; Le code HTML g\u00e9n\u00e9r\u00e9 est le suivant\u00a0:</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;Hello World!&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Hello user!&lt;/h1&gt;\n        &lt;form method=\"post\" action=\"/logout\"&gt;\n            &lt;input type=\"submit\" value=\"Sign Out\" /&gt;\n            &lt;input type=\"hidden\" name=\"_csrf\" value=\"b152e5b9-d1a4-4492-b89d-b733fe521c91\" /&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 8\u00a0: la traduction de Hello [[${#httpServletRequest.remoteUser}]]!;</li> <li>ligne 9\u00a0:  la traduction de @{/logout}\u00a0;</li> <li>ligne 11\u00a0: un champ cach\u00e9 appel\u00e9 (attribut name) _csrf\u00a0; La vue [login.html] est la suivante\u00a0:</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n    xmlns:th=\"http://www.thymeleaf.org\"\n    xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n&lt;head&gt;\n&lt;title&gt;Spring Security Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div th:if=\"${param.error}\"&gt;Invalid username and password.&lt;/div&gt;\n    &lt;div th:if=\"${param.logout}\"&gt;You have been logged out.&lt;/div&gt;\n    &lt;form th:action=\"@{/login}\" method=\"post\"&gt;\n        &lt;div&gt;\n            &lt;label&gt; User Name : &lt;input type=\"text\" name=\"username\" /&gt;\n            &lt;/label&gt;\n        &lt;/div&gt;\n        &lt;div&gt;\n            &lt;label&gt; Password: &lt;input type=\"password\" name=\"password\" /&gt;\n            &lt;/label&gt;\n        &lt;/div&gt;\n        &lt;div&gt;\n            &lt;input type=\"submit\" value=\"Sign In\" /&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 9\u00a0: l'attribut [th:if=\"${param.error}\"] fait que la balise &lt;div&gt; ne sera g\u00e9n\u00e9r\u00e9e que si l'URL qui affiche la page de login contient le param\u00e8tre [error] (http://context/login?error);</li> <li>ligne 10\u00a0: l'attribut [th:if=\"${param.logout}\"] fait que la balise &lt;div&gt; ne sera g\u00e9n\u00e9r\u00e9e que si l'URL qui affiche la page de login contient le param\u00e8tre [logout] (http://context/login?logout);</li> <li>lignes 11-23\u00a0: un formulaire HTML\u00a0;</li> <li>ligne 11\u00a0: le formulaire sera post\u00e9 \u00e0 l'URL [&lt;context&gt;/login] o\u00f9 &lt;context&gt; est le contexte de l'application web\u00a0;</li> <li>ligne 13\u00a0: un champ de saisie nomm\u00e9 [username]\u00a0;</li> <li>ligne 17\u00a0: un champ de saisie nomm\u00e9 [password]\u00a0; Le code HTML g\u00e9n\u00e9r\u00e9 est le suivant\u00a0:</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n    &lt;head&gt;\n        &lt;title&gt;Spring Security Example &lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n        &lt;div&gt;\n            You have been logged out.\n        &lt;/div&gt;\n        &lt;form method=\"post\" action=\"/login\"&gt;\n            &lt;div&gt;\n                &lt;label&gt;\n                    User Name :\n                    &lt;input type=\"text\" name=\"username\" /&gt;\n                &lt;/label&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;label&gt;\n                    Password:\n                    &lt;input type=\"password\" name=\"password\" /&gt;\n                &lt;/label&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;input type=\"submit\" value=\"Sign In\" /&gt;\n            &lt;/div&gt;\n            &lt;input type=\"hidden\" name=\"_csrf\" value=\"ef809b0a-88b4-4db9-bc53-342216b77632\" /&gt;\n        &lt;/form&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>On notera ligne 28 que Thymeleaf a ajout\u00e9 un champ cach\u00e9 nomm\u00e9 [_csrf].</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1633-configuration-spring-mvc","title":"16.3.3. Configuration Spring MVC","text":"<p>La classe [MvcConfig] configure le framework Spring MVC\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.ViewControllerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\n@Configuration\npublic class MvcConfig extends WebMvcConfigurerAdapter {\n\n    @Override\n    public void addViewControllers(ViewControllerRegistry registry) {\n        registry.addViewController(\"/home\").setViewName(\"home\");\n        registry.addViewController(\"/\").setViewName(\"home\");\n        registry.addViewController(\"/hello\").setViewName(\"hello\");\n        registry.addViewController(\"/login\").setViewName(\"login\");\n    }\n\n}\n</code></pre> <ul> <li>ligne 7\u00a0:\u00a0l'annotation [@Configuration] fait de la classe [MvcConfig] une classe de configuration\u00a0;</li> <li>ligne 8\u00a0: la classe [MvcConfig] \u00e9tend la classe [WebMvcConfigurerAdapter] pour en red\u00e9finir certaines m\u00e9thodes\u00a0;</li> <li>ligne 10\u00a0: red\u00e9finition d'une m\u00e9thode de la classe parent\u00a0;</li> <li>lignes 11- 16\u00a0: la m\u00e9thode [addViewControllers] permet d'associer des URL \u00e0 des vues HTML. Les associations suivantes y sont faites\u00a0:</li> </ul> <pre><code>URL\n</code></pre> <p>vue</p> <pre><code>/, /home\n</code></pre> <p>/templates/home.html</p> <pre><code>/hello\n</code></pre> <p>/templates/hello.html</p> <pre><code>/login\n</code></pre> <p>/templates/login.html</p> <p>Le suffixe [html] et le dossier [templates] sont les valeurs par d\u00e9faut utilis\u00e9es par Thymeleaf. Elles peuvent \u00eatre chang\u00e9es par configuration. Le dossier [templates] doit \u00eatre \u00e0 la racine du Classpath du projet\u00a0:</p> <p>Ci-dessus [1], les dossiers [java] et [resources] sont tous les deux des dossier source (source folders). Cela implique que leur contenu sera \u00e0 la racine du Classpath du projet. Donc en [2], les dossiers [hello] et [templates] seront  \u00e0 la racine du Classpath.</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1634-configuration-spring-security","title":"16.3.4. Configuration Spring Security","text":"<p>La classe [WebSecurityConfig] configure le framework Spring Security\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;\n\n@Configuration\n@EnableWebMvcSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests().antMatchers(\"/\", \"/home\").permitAll().anyRequest().authenticated();\n        http.formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication().withUser(\"user\").password(\"password\").roles(\"USER\");\n    }\n}\n</code></pre> <ul> <li>ligne 9\u00a0:\u00a0l'annotation [@Configuration] fait de la classe [WebSecurityConfig] une classe de configuration\u00a0;</li> <li>ligne 10\u00a0: l'annotation [@EnableWebSecurity]  fait de la classe [WebSecurityConfig] une classe de configuration de Spring Security\u00a0;</li> <li>ligne 11\u00a0: la classe [WebSecurity] \u00e9tend la classe [WebSecurityConfigurerAdapter] pour en red\u00e9finir certaines m\u00e9thodes\u00a0;</li> <li>ligne 12\u00a0: red\u00e9finition d'une m\u00e9thode de la classe parent\u00a0;</li> <li>lignes 13- 16\u00a0: la m\u00e9thode [configure(HttpSecurity http)] est red\u00e9finie pour d\u00e9finir les droits d'acc\u00e8s aux diff\u00e9rentes URL de l'application\u00a0;</li> <li>ligne 14\u00a0: la m\u00e9thode [http.authorizeRequests()] permet d'associer des URL \u00e0 des droits d'acc\u00e8s. Les associations suivantes y sont faites\u00a0:</li> </ul> <pre><code>URL\n</code></pre> <p>r\u00e9gle</p><p>code</p> <pre><code>/, /home\n</code></pre> <p>acc\u00e8s sans \u00eatre authentifi\u00e9</p> <pre><code>http.authorizeRequests().antMatchers(\"/\", \"/home\").permitAll()\n</code></pre> <pre><code>autres URL\n</code></pre> <p>acc\u00e8s authentifi\u00e9 uniquement</p> <pre><code>http.anyRequest().authenticated();\n</code></pre> <ul> <li>ligne 15\u00a0: d\u00e9finit la m\u00e9thode d'authentification. L'authentification se fait via un formulaire d'URL [/login] accessible \u00e0 tous [http.formLogin().loginPage(\"/login\").permitAll()]. La d\u00e9connexion (logout) est \u00e9galement accessible \u00e0 tous\u00a0;</li> <li>lignes 19-21\u00a0: red\u00e9finissent la m\u00e9thode [configure(AuthenticationManagerBuilder auth)] qui g\u00e8re les utilisateurs\u00a0;</li> <li>ligne 20\u00a0: l'autentification se fait avec des utilisateurs d\u00e9finis en \"\u00a0dur\u00a0\" [auth.inMemoryAuthentication()]. Un utilisateur est ici d\u00e9fini avec le login [user], le mot de passe [password] et le r\u00f4le [USER]. On peut accorder les m\u00eames droits \u00e0 des utilisateurs ayant le m\u00eame r\u00f4le\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1635-classe-executable","title":"16.3.5. Classe ex\u00e9cutable","text":"<p>La classe [Application] est la suivante\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@EnableAutoConfiguration\n@Configuration\n@ComponentScan\npublic class Application {\n\n    public static void main(String[] args) throws Throwable {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n</code></pre> <ul> <li>ligne 8\u00a0: l'annotation [@EnableAutoConfiguration] demande \u00e0 Spring Boot (ligne 3) de faire la configuration que le d\u00e9veloppeur n'aura pas fait explicitement\u00a0;</li> <li>ligne 9\u00a0: fait de la classe [Application] une classe de configuration Spring\u00a0;</li> <li>ligne 10\u00a0: demande le scan du dossier de la classe [Application] afin de rechercher des composants Spring. Les deux classes [MvcConfig] et [WebSecurityConfig] vont \u00eatre ainsi d\u00e9couvertes car elles ont l'annotation [@Configuration]\u00a0;</li> <li>ligne 13\u00a0: la m\u00e9thode [main] de la classe ex\u00e9cutable\u00a0;</li> <li>ligne 14\u00a0: la m\u00e9thode statique [SpringApplication.run] est ex\u00e9cut\u00e9e avec comme param\u00e8tre la classe de configuration [Application]. Nous avons d\u00e9j\u00e0 rencontr\u00e9 ce processus et nous savons que le serveur Tomcat embarqu\u00e9 dans les d\u00e9pendances Maven du projet va \u00eatre lanc\u00e9 et le projet d\u00e9ploy\u00e9 dessus. Nous avons vu que quatre URL \u00e9taient g\u00e9r\u00e9es [/, /home, /login, /hello] et que certaines \u00e9taient prot\u00e9g\u00e9es par des droits d'acc\u00e8s.</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1636-tests-de-lapplication","title":"16.3.6. Tests de l'application","text":"<p>Commen\u00e7ons par demander l'URL [/] qui est l'une des quatre URL accept\u00e9es. Elle est associ\u00e9e \u00e0 la vue [/templates/home.html]\u00a0:</p> <p>L'URL demand\u00e9e [/] est accessible \u00e0 tous. C'est pourquoi nous l'avons obtenue. Le lien [here] est le suivant\u00a0:</p> <pre><code>Click &lt;a href=\"/hello\"&gt;here&lt;/a&gt; to see a greeting.\n</code></pre> <p>L'URL [/hello] va \u00eatre demand\u00e9e lorsqu'on va cliquer sur le lien. Celle-ci est prot\u00e9g\u00e9e\u00a0:</p> <pre><code>URL\n</code></pre> <p>r\u00e8gle</p><p>code</p> <pre><code>/, /home\n</code></pre> <p>acc\u00e8s sans \u00eatre authentifi\u00e9</p> <pre><code>http.authorizeRequests().antMatchers(\"/\", \"/home\").permitAll()\n</code></pre> <pre><code>autres URL\n</code></pre> <p>acc\u00e8s authentifi\u00e9 uniquement</p> <pre><code>http.anyRequest().authenticated();\n</code></pre> <p>Il faut \u00eatre authentifi\u00e9 pour l'obtenir. Spring Security va alors rediriger le navigateur client vers la page d'authentification. D'apr\u00e8s la configuration vue, c'est la page d'URL [/login]. Celle-ci est accessible \u00e0 tous\u00a0:</p> <pre><code>http.formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n</code></pre> <p>Nous l'obtenons donc [1]\u00a0:</p> <p>Le code source de la page obtenue est le suivant\u00a0:</p> <pre><code>&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt;\n...\n    &lt;form method=\"post\" action=\"/login\"&gt;\n...\n       &lt;input type=\"hidden\" name=\"_csrf\" value=\"87bea06a-a177-459d-b279-c6068a7ad3eb\" /&gt;\n   &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>ligne 7, un champ cach\u00e9 appara\u00eet qui n'est pas dans la page [login.html] d'origine. C'est Thymeleaf qui l'a ajout\u00e9. Ce code appel\u00e9 CSRF (Cross Site Request Forgery) vise \u00e0 \u00e9liminer une faille de s\u00e9curit\u00e9. Ce jeton doit \u00eatre renvoy\u00e9 \u00e0 Spring Security avec l'authentification pour que cette derni\u00e8re soit accept\u00e9e\u00a0; Nous nous souvenons que seul l'utilisateur user/password est reconnu par Spring Security. Si nous entrons autre chose en [2], nous obtenons la m\u00eame page avec un message d'erreur en [3]. Spring Security a redirig\u00e9 le navigateur vers l'URL [http://localhost:8080/login?error]. La pr\u00e9sence du param\u00e8tre [error] a d\u00e9clench\u00e9 l'affichage de la balise\u00a0:</li> </ul> <pre><code>&lt;div th:if=\"${param.error}\"&gt;Invalid username and password.&lt;/div&gt;\n</code></pre> <p>Maintenant, entrons les valeurs attendues user/password [4]\u00a0:</p> <ul> <li>en [4], nous nous identifions\u00a0;</li> <li>en [5], Spring Security nous redirige vers l'URL [/hello] car c'est l'URL que nous demandions lorsque nous avons \u00e9t\u00e9 redirig\u00e9s vers la page de login. L'identit\u00e9 de l'utilisateur a \u00e9t\u00e9 affich\u00e9e par la ligne suivante de [hello.html]\u00a0: <pre><code>    &lt;h1 th:inline=\"text\"&gt;Hello [[${#httpServletRequest.remoteUser}]]!&lt;/h1&gt;\n</code></pre></li> </ul> <p>La page [5] affiche le formulaire suivant\u00a0:</p> <pre><code>    &lt;form th:action=\"@{/logout}\" method=\"post\"&gt;\n        &lt;input type=\"submit\" value=\"Sign Out\" /&gt;\n&lt;/form&gt;\n</code></pre> <p>Lorsqu'on clique sur le bouton [Sign Out], un POST va \u00eatre fait sur l'URL [/logout]. Celle-ci comme l'URL [/login] est accessible \u00e0 tous\u00a0:</p> <pre><code>http.formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n</code></pre> <p>Dans notre association URL / vues, nous n'avons rien d\u00e9fini pour l'URL [/logout]. Que va-t-il se passer\u00a0? Essayons\u00a0:</p> <ul> <li>en [6], nous cliquons sur le bouton [Sign Out]\u00a0;</li> <li>en [7], nous voyons que nous avons \u00e9t\u00e9 redirig\u00e9s vers l'URL [http://localhost:8080/login?logout]. C'est Spring Security qui a demand\u00e9 cette redirection. La pr\u00e9sence du param\u00e8tre [logout] dans l'URL a fait afficher la ligne suivante de la vue\u00a0: <pre><code>&lt;div th:if=\"${param.logout}\"&gt;You have been logged out.&lt;/div&gt;\n</code></pre></li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1637-conclusion","title":"16.3.7. Conclusion","text":"<p>Dans l'exemple pr\u00e9c\u00e9dent, nous aurions pu \u00e9crire l'application web d'abord puis la s\u00e9curiser ensuite. Spring Security n'est pas intrusif. On peut mettre en place la s\u00e9curit\u00e9 d'une application web d\u00e9j\u00e0 \u00e9crite. Par ailleurs, nous avons d\u00e9couvert les points suivants\u00a0:</p> <ul> <li>il est possible de d\u00e9finir une page d'authentification\u00a0;</li> <li>l'authentification doit \u00eatre accompagn\u00e9e du jeton CSRF d\u00e9livr\u00e9 par Spring Security\u00a0;</li> <li>si l'authentification \u00e9choue, on est redirig\u00e9 vers la page d'authentification avec de plus un param\u00e8tre error dans l'URL\u00a0;</li> <li>si l'authentification r\u00e9ussit, on est redirig\u00e9 vers la page demand\u00e9e lorsque l'authentification a eu lieu. Si on demande directement la page d'authentification sans passer par une page interm\u00e9diaire, alors Spring Security nous redirige vers l'URL [/] (ce cas n'a pas \u00e9t\u00e9 pr\u00e9sent\u00e9)\u00a0;</li> <li>on se d\u00e9connecte en demandant l'URL [/logout] avec un POST. Spring Security nous redirige alors vers la page d'authentification avec le param\u00e8tre logout dans l'URL\u00a0; Toutes ces conclusions reposent sur des comportements par d\u00e9faut de Spring Security. Ces comportements peuvent \u00eatre chang\u00e9s par configuration en red\u00e9finissant certaines m\u00e9thodes de la classe [WebSecurityConfigurerAdapter].</li> </ul> <p>Le tutoriel pr\u00e9c\u00e9dent nous aidera peu dans la suite. Nous allons en effet utiliser\u00a0:</p> <ul> <li>une base de donn\u00e9es pour stocker les utilisateurs, leurs mots de passe et leurs r\u00f4les\u00a0;</li> <li>une authentification par ent\u00eate HTTP\u00a0; On trouve assez peu de tutoriels pour ce qu'on veut faire ici. La solution qui va \u00eatre propos\u00e9e est un assemblage de codes trouv\u00e9s ici et l\u00e0.</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#164-mise-en-place-de-la-securite-sur-le-service-web-json-des-produits","title":"16.4. Mise en place de la s\u00e9curit\u00e9 sur le service web / json des produits","text":""},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1641-la-base-de-donnees","title":"16.4.1. La base de donn\u00e9es","text":"<p>La base de donn\u00e9es [dbintrospringdata] \u00e9volue pour prendre en compte les utilisateurs, leurs mots de passe et leur r\u00f4les. Trois nouvelles tables apparaissent\u00a0:</p> <p></p> <p>Table [USERS]\u00a0: les utilisateurs</p> <ul> <li>ID\u00a0: cl\u00e9 primaire\u00a0;</li> <li>VERSION\u00a0: colonne de versioning de la ligne\u00a0;</li> <li>IDENTITY\u00a0: une identit\u00e9 descriptive de l'utilisateur\u00a0;</li> <li>LOGIN\u00a0: le login de l'utilisateur\u00a0;</li> <li>PASSWORD\u00a0: son mot de passe\u00a0; Dans la table USERS, les mots de passe ne sont pas stock\u00e9s en clair\u00a0:</li> </ul> <p>L'algorithme qui crypte les mots de passe est l'algorithme BCRYPT.</p> <p>Table [ROLES]\u00a0: les r\u00f4les</p> <ul> <li>ID\u00a0: cl\u00e9 primaire\u00a0;</li> <li>VERSION\u00a0: colonne de versioning de la ligne\u00a0;</li> <li>NAME\u00a0: nom du r\u00f4le. Par d\u00e9faut, Spring Security attend des noms de la forme ROLE_XX, par exemple ROLE_ADMIN ou ROLE_GUEST\u00a0;</li> </ul> <p>Table [USERS_ROLES]\u00a0: table de jointure USERS / ROLES</p> <p>Un utilisateur peut avoir plusieurs r\u00f4les, un r\u00f4le peut rassembler plusieurs utilisateurs. On a une relation plusieurs \u00e0 plusieurs mat\u00e9rialis\u00e9e par la table [USERS_ROLES].</p> <ul> <li>ID\u00a0: cl\u00e9 primaire\u00a0;</li> <li>VERSION\u00a0: colonne de versioning de la ligne\u00a0;</li> <li>USER_ID\u00a0: identifiant d'un utilisateur\u00a0;</li> <li>ROLE_ID\u00a0: identifiant d'un r\u00f4le\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1642-le-projet-eclipse","title":"16.4.2. Le projet Eclipse","text":"<p>Nous cr\u00e9ons le projet Eclipse suivant\u00a0:</p> <p>1</p> <ul> <li>en [1]\u00a0: le nouveau projet avec les paquetages suivants\u00a0:</li> <li>[spring.security.entities]\u00a0: contient les entit\u00e9s JPA correspondant aux trois nouvelles tables de la base de donn\u00e9es\u00a0;</li> <li>[spring.security.repositories]\u00a0: contient les [repositories] de Spring Data associ\u00e9s  aux trois nouvelles tables\u00a0;</li> <li>[spring.security.dao]\u00a0: contient un service s'appuyant sur les [repositories]\u00a0;</li> <li>[spring.security.config]\u00a0: contient la configuration du projet et notamment celle des acc\u00e8s s\u00e9curis\u00e9s au service web\u00a0;</li> <li>[spring.security.boot]\u00a0: conteint la classe de lancement du service web s\u00e9curis\u00e9\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1643-la-configuration-maven","title":"16.4.3. La configuration Maven","text":"<p>Le nouveau projet est un projet Maven configur\u00e9 par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.spring.security&lt;/groupId&gt;\n    &lt;artifactId&gt;intro-spring-security-server-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;name&gt;intro-spring-security-server-01&lt;/name&gt;\n    &lt;description&gt;d\u00e9mo spring security&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.webjson&lt;/groupId&gt;\n            &lt;artifactId&gt;intro-server-webjson-01&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring security --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring logs --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 23-27\u00a0: on reprend l'existant avec l'archive du service web / json \u00e9tudi\u00e9\u00a0;</li> <li>lignes 29-32\u00a0: la d\u00e9pendance qui am\u00e8ne les classes de Spring Security\u00a0;</li> <li>lignes 34-37\u00a0: la biblioth\u00e8que de logs\u00a0;</li> <li>lignes 39-42\u00a0: la biblioth\u00e8que permettant d'utiliser les annotations Spring Boot\u00a0;</li> <li>lignes 44-48\u00a0: la biblioth\u00e8que n\u00e9cessaire aux tests\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1644-les-nouvelles-entites-jpa","title":"16.4.4. Les nouvelles entit\u00e9s [JPA]","text":"<p>La couche JPA d\u00e9finit trois nouvelles entit\u00e9s\u00a0:</p> <p>La classe [User] est l'image de la table [USERS]\u00a0:</p> <pre><code>package spring.security.entities;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Table;\n\nimport spring.data.entities.AbstractEntity;\n\n@Entity\n@Table(name = \"USERS\")\npublic class User extends AbstractEntity {\n\n    // propri\u00e9t\u00e9s\n    @Column(name = \"NAME\")\n    private String name;\n    @Column(name = \"LOGIN\")\n    private String login;\n    @Column(name = \"PASSWORD\")\n    private String password;\n\n    // constructeur\n    public User() {\n    }\n\n    public User(String name, String login, String password) {\n        this.name = name;\n        this.login = login;\n        this.password = password;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>ligne 11\u00a0: la classe \u00e9tend la classe [AbstractEntity] d\u00e9j\u00e0 utilis\u00e9e pour les autres entit\u00e9s\u00a0; La classe [Role] est l'image de la table [ROLES]\u00a0:</li> </ul> <pre><code>package spring.security.entities;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Table;\n\nimport spring.data.entities.AbstractEntity;\n\n@Entity\n@Table(name = \"ROLES\")\npublic class Role extends AbstractEntity {\n\n    // propri\u00e9t\u00e9s\n    @Column(name=\"NAME\")\n    private String name;\n\n    // constructeurs\n    public Role() {\n    }\n\n    public Role(String name) {\n        this.name = name;\n    }\n\n    // getters et setters\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n}\n</code></pre> <p>La classe [UserRole] est l'image de la table [USERS_ROLES]\u00a0:</p> <pre><code>package spring.security.entities;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\n\nimport spring.data.entities.AbstractEntity;\n\n@Entity\n@Table(name = \"USERS_ROLES\")\npublic class UserRole extends AbstractEntity {\n\n    // les cl\u00e9s \u00e9trang\u00e8res\n    @Column(name = \"USER_ID\", insertable = false, updatable = false)\n    private Long userId;\n    @Column(name = \"ROLE_ID\", insertable = false, updatable = false)\n    private Long roleId;\n\n    // un UserRole r\u00e9f\u00e9rence un User\n    @ManyToOne\n    @JoinColumn(name = \"USER_ID\")\n    private User user;\n\n    // un UserRole r\u00e9f\u00e9rence un Role\n    @ManyToOne\n    @JoinColumn(name = \"ROLE_ID\")\n    private Role role;\n\n    // constructeurs\n    public UserRole() {\n\n    }\n\n    public UserRole(User user, Role role) {\n        this.user = user;\n        this.role = role;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>lignes 22-24\u00a0: mat\u00e9rialisent la cl\u00e9 \u00e9trang\u00e8re de la table [USERS_ROLES] vers la table [USERS]\u00a0;</li> <li>lignes 27-29\u00a0: mat\u00e9rialisent la cl\u00e9 \u00e9trang\u00e8re de la table [USERS_ROLES] vers la table [ROLES]\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1645-les-repositories","title":"16.4.5. Les [repositories]","text":"<p>Chacune des entit\u00e9s JPA pr\u00e9c\u00e9dentes est g\u00e9r\u00e9e par un [repository] Spring Data\u00a0:</p> <p>L'interface [UserRepository] g\u00e8re les acc\u00e8s aux entit\u00e9s [User]\u00a0:</p> <pre><code>package spring.security.repositories;\n\nimport org.springframework.data.jpa.repository.Query;\nimport org.springframework.data.repository.CrudRepository;\n\nimport spring.security.entities.Role;\nimport spring.security.entities.User;\n\npublic interface UserRepository extends CrudRepository&lt;User, Long&gt; {\n\n    // liste des r\u00f4les d'un utilisateur identifi\u00e9 par son id\n    @Query(\"select ur.role from UserRole ur where ur.user.id=?1\")\n    Iterable&lt;Role&gt; getRoles(long id);\n\n    // liste des r\u00f4les d'un utilisateur identifi\u00e9 par son login unique\n    @Query(\"select ur.role from UserRole ur where ur.user.login=?1 and ur.user.password=?2\")\n    Iterable&lt;Role&gt; getRoles(String login, String password);\n\n    // recherche d'un utilisateur via son login\n    User findUserByLogin(String login);\n}\n</code></pre> <ul> <li>ligne 9\u00a0: l'interface [UserRepository] \u00e9tend l'interface [CrudRepository] de Spring Data (ligne 4)\u00a0;</li> <li>lignes 12-13\u00a0: la m\u00e9thode [getRoles(User user)] permet d'avoir tous les r\u00f4les d'un utilisateur identifi\u00e9 par son [id]</li> <li>lignes 16-17\u00a0: idem mais pour un utilisateur identifi\u00e9 pas ses login / mot de passe\u00a0;</li> <li>ligne 20\u00a0: pour trouver un utilisateur via son login\u00a0; L'interface [RoleRepository] g\u00e8re les acc\u00e8s aux entit\u00e9s [Role]\u00a0:</li> </ul> <pre><code>package spring.security.repositories;\n\nimport org.springframework.data.repository.CrudRepository;\n\nimport spring.security.entities.Role;\n\npublic interface RoleRepository extends CrudRepository&lt;Role, Long&gt; {\n\n    // recherche d'un r\u00f4le via son nom\n    Role findRoleByName(String name);\n\n}\n</code></pre> <ul> <li>ligne 7\u00a0: l'interface [RoleRepository] \u00e9tend l'interface [CrudRepository]\u00a0;</li> <li>ligne 10\u00a0: on peut chercher un r\u00f4le via son nom\u00a0; L'interface [UserRoleRepository] g\u00e8re les acc\u00e8s aux entit\u00e9s [UserRole]\u00a0:</li> </ul> <pre><code>package spring.security.repositories;\n\nimport org.springframework.data.repository.CrudRepository;\n\nimport spring.security.entities.UserRole;\n\npublic interface UserRoleRepository extends CrudRepository&lt;UserRole, Long&gt; {\n\n}\n</code></pre> <ul> <li>ligne 5\u00a0: l'interface [UserRoleRepository] se contente d'\u00e9tendre l'interface [CrudRepository] sans lui ajouter de nouvelles m\u00e9thodes\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1646-les-classes-de-gestion-des-utilisateurs-et-des-roles","title":"16.4.6. Les classes de gestion des utilisateurs et des r\u00f4les","text":"<p>Couche[repositories]Pilote[JDBC]Couche[JPA]Couche[DAO]7Spring 4SGBD</p> <p>Spring Security impose la cr\u00e9ation d'une classe impl\u00e9mentant l'interface [UsersDetail] suivante\u00a0:</p> <p>Cette interface est ici impl\u00e9ment\u00e9e par la classe [AppUserDetails]\u00a0:</p> <pre><code>package spring.security.dao;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport spring.security.entities.Role;\nimport spring.security.entities.User;\nimport spring.security.repositories.UserRepository;\n\npublic class AppUserDetails implements UserDetails {\n\n    private static final long serialVersionUID = 1L;\n\n    // propri\u00e9t\u00e9s\n    private User user;\n    private UserRepository userRepository;\n\n    // constructeurs\n    public AppUserDetails() {\n    }\n\n    public AppUserDetails(User user, UserRepository userRepository) {\n        this.user = user;\n        this.userRepository = userRepository;\n    }\n\n    // -------------------------interface\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n        Collection&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n        for (Role role : userRepository.getRoles(user.getId())) {\n            authorities.add(new SimpleGrantedAuthority(role.getName()));\n        }\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getLogin();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre> <ul> <li>ligne 14\u00a0: la classe [AppUserDetails] impl\u00e9mente l'interface [UserDetails]\u00a0;</li> <li>lignes 19-20\u00a0: la classe encapsule un utilisateur (ligne 19) et le repository qui permet d'avoir les d\u00e9tails de cet utilisateur (ligne 20)\u00a0;</li> <li>lignes 26-29\u00a0: le constructeur qui instancie la classe avec un utilisateur et son repository\u00a0;</li> <li>lignes 32-36\u00a0: impl\u00e9mentation de la m\u00e9thode [getAuthorities] de l'interface [UserDetails]. Elle doit construire une collection d'\u00e9l\u00e9ments de type [GrantedAuthority] ou d\u00e9riv\u00e9. Ici, nous utilisons le type d\u00e9riv\u00e9 [SimpleGrantedAuthority] (ligne 36) qui encapsule le nom d'un des r\u00f4les de l'utilisateur de la ligne 19\u00a0;</li> <li>lignes 35-37\u00a0: on parcourt la liste des r\u00f4les de l'utilisateur de la ligne 19 pour construire une liste d'\u00e9l\u00e9ments de type [SimpleGrantedAuthority]\u00a0;</li> <li>lignes 42-44\u00a0: impl\u00e9mentent la m\u00e9thode [getPassword] de l'interface [UserDetails]. On rend le mot de passe  de l'utilisateur de la ligne 19\u00a0;</li> <li>lignes 42-44\u00a0: impl\u00e9mentent la m\u00e9thode [getUserName] de l'interface [UserDetails]. On rend le login  de l'utilisateur de la ligne 19\u00a0;</li> <li>lignes 51-54\u00a0: le compte de l'utilisateur n'expire jamais\u00a0;</li> <li>lignes 56-59\u00a0: le compte de l'utilisateur n'est jamais bloqu\u00e9\u00a0;</li> <li>lignes 61-64\u00a0: les identifiants de l'utilisateur n'expirent jamais\u00a0;</li> <li>lignes 66-69\u00a0:  le compte de l'utilisateur est toujours actif\u00a0; Spring Security impose \u00e9galement l'existence d'une classe impl\u00e9mentant l'interface [AppUserDetailsService]\u00a0:</li> </ul> <p>Cette interface est impl\u00e9ment\u00e9e par la classe [AppUserDetailsService] suivante\u00a0:</p> <pre><code>package spring.security.dao;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport spring.security.entities.User;\nimport spring.security.repositories.UserRepository;\n\n@Service\npublic class AppUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    public UserDetails loadUserByUsername(String login) throws UsernameNotFoundException {\n        // on cherche l'utilisateur via son login\n        User user = userRepository.findUserByLogin(login);\n        // trouv\u00e9 ?\n        if (user == null) {\n            throw new UsernameNotFoundException(String.format(\"login [%s] inexistant\", login));\n        }\n        // on rend les d\u00e9tails de l'utilsateur\n        return new AppUserDetails(user, userRepository);\n    }\n\n}\n</code></pre> <ul> <li>ligne 12\u00a0: la classe sera un composant Spring, donc disponible dans son contexte\u00a0;</li> <li>lignes 15-16\u00a0: le composant [UserRepository] sera inject\u00e9 ici\u00a0;</li> <li>lignes 19-28\u00a0: impl\u00e9mentation de la m\u00e9thode [loadUserByUsername] de l'interface [UserDetailsService] (ligne 10). Le param\u00e8tre est le login de l'utilisateur\u00a0;</li> <li>ligne 21\u00a0: l'utilisateur est recherch\u00e9 via son login\u00a0;</li> <li>lignes 23-25\u00a0: s'il n'est pas trouv\u00e9, une exception est lanc\u00e9e\u00a0;</li> <li>ligne 27\u00a0: un objet [AppUserDetails] est construit et rendu. Il est bien de type [UserDetails] (ligne 19)\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1647-la-configuration-du-projet","title":"16.4.7. La configuration du projet","text":"<p>Le projet est configur\u00e9 par deux classes\u00a0:</p> <p>1</p> <p>La classe [DaoConfig] configure la couche [DAO] amen\u00e9e par le nouveau projet\u00a0:</p> <pre><code>package spring.security.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n\n@EnableJpaRepositories(basePackages = { \"spring.security.repositories\" })\n@ComponentScan(basePackages = { \"spring.security.dao\" })\n@Import({ spring.data.config.DaoConfig.class })\npublic class DaoConfig {\n\n    // constantes\n    final static private String[] ENTITIES_PACKAGES = { \"spring.data.entities\", \"spring.security.entities\" };\n\n    @Bean\n    public String[] packagesToScan() {\n        return ENTITIES_PACKAGES;\n    }\n\n}\n</code></pre> <ul> <li>ligne 10\u00a0: on importe la classe de configuration [spring.data.config.DaoConfig] du projet [intro-spring-data-01] qui impl\u00e9mente la couche [DAO] des produits et cat\u00e9gories\u00a0;</li> <li>ligne 8\u00a0: on d\u00e9signe les dossiers du projet courant contenant des [repositories] Spring Data\u00a0;</li> <li>ligne 9\u00a0: on d\u00e9signe les dossiers du projet courant contenant des composants Spring concernant la couche [DAO]\u00a0;</li> <li>ligne 14\u00a0: on d\u00e9signe les dossiers contenant des entit\u00e9s JPA. Il y a celles du projet [intro-spring-data-01] et celles du projet du serveur s\u00e9curis\u00e9. Cette information fait l'objet du bean des lignes 16-19. Ce bean red\u00e9finit le bean de m\u00eame nom du projet [intro-spring-data-01]\u00a0: <pre><code>    final static private String[] ENTITIES_PACKAGES = { \"spring.data.entities\" };\n\n    // EntityManagerFactory\n    @Bean\n    public EntityManagerFactory entityManagerFactory(JpaVendorAdapter jpaVendorAdapter, DataSource dataSource) {\n        LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();\n        factory.setJpaVendorAdapter(jpaVendorAdapter);\n        factory.setPackagesToScan(packagesToScan());\n        factory.setDataSource(dataSource);\n        factory.afterPropertiesSet();\n        return factory.getObject();\n    }\n\n    @Bean\n    public String[] packagesToScan() {\n        return ENTITIES_PACKAGES;\n}\n</code></pre></li> </ul> <p>Dans la couche [DAO], la ligne 8 scanne les dossiers indiqu\u00e9s ligne 1. A cause de la red\u00e9finition du bean des lignes 14-17 dans le projet s\u00e9curis\u00e9 (lignes 16-19), la ligne 8 ci-dessus va d\u00e9sormais scanner les dossiers [\"spring.data.entities\", \"spring.security.entities\"]. Il est \u00e0 noter que la classe import\u00e9e ligne 10 de la classe [spring.security.config.DaoConfig] doit comporter l'annotation [@Configuration], sinon le ph\u00e9nom\u00e8ne qui vient d'\u00eatre expliqu\u00e9 ne fonctionne pas.</p> <p>La classe [SecurityConfig] configure l'aspect s\u00e9curit\u00e9 du projet. Nous avons d\u00e9j\u00e0 rencontr\u00e9 une classe de configuration de Spring Security\u00a0:</p> <pre><code>package hello;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.annotation.web.servlet.configuration.EnableWebMvcSecurity;\n\n@Configuration\n@EnableWebMvcSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests().antMatchers(\"/\", \"/home\").permitAll().anyRequest().authenticated();\n        http.formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll();\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.inMemoryAuthentication().withUser(\"user\").password(\"password\").roles(\"USER\");\n    }\n}\n</code></pre> <p>Nous allons suivre la m\u00eame d\u00e9marche\u00a0:</p> <ul> <li>ligne 11\u00a0: d\u00e9finir une classe qui \u00e9tend la classe [WebSecurityConfigurerAdapter]\u00a0;</li> <li>ligne 13\u00a0: d\u00e9finir une m\u00e9thode [configure(HttpSecurity http)] qui d\u00e9finit les droits d'acc\u00e8s aux diff\u00e9rentes URL du service web\u00a0;</li> <li>ligne 19\u00a0: d\u00e9finir une m\u00e9thode [configure(AuthenticationManagerBuilder auth)] qui d\u00e9finit les utilisateurs et leurs r\u00f4les\u00a0; La classe [SecurityConfig] sera la suivante\u00a0:</li> </ul> <pre><code>package spring.security.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\nimport spring.security.dao.AppUserDetailsService;\n\n@EnableWebSecurity\n@ComponentScan(basePackages = { \"spring.security.service\" })\n@Import({ spring.webjson.config.AppConfig.class, DaoConfig.class })\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private AppUserDetailsService appUserDetailsService;\n\n    // s\u00e9curisation\n    private boolean activateSecurity = true;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder registry) throws Exception {\n        // l'authentification est faite par le bean [appUserDetailsService]\n        // le mot de passe est crypt\u00e9 par l'algorithme de hachage BCrypt\n        registry.userDetailsService(appUserDetailsService).passwordEncoder(new BCryptPasswordEncoder());\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // CSRF\n        http.csrf().disable();\n        // application s\u00e9curis\u00e9e ?\n        if (activateSecurity) {\n            // le mot de passe est transmis par le header Authorization: Basic xxxx\n            http.httpBasic();\n            // la m\u00e9thode HTTP OPTIONS doit \u00eatre autoris\u00e9e pour tous\n            http.authorizeRequests() //\n                    .antMatchers(HttpMethod.OPTIONS, \"/\", \"/**\").permitAll();\n            // seul le r\u00f4le ADMIN peut utiliser l'application\n            http.authorizeRequests() //\n                    .antMatchers(\"/\", \"/**\") // toutes les URL\n                    .hasRole(\"ADMIN\");\n            // pas de session\n            http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        }\n    }\n}\n</code></pre> <ul> <li>ligne 16\u00a0: pour activer les \u00e9l\u00e9ments de Spring Security\u00a0;</li> <li>ligne 17\u00a0: on rajoute les composants Spring du package [spring.security.service]\u00a0;</li> <li>ligne 18\u00a0: on importe les beans de la couche [DAO] que l'on vient de pr\u00e9senter ainsi que ceux du serveur web / jSON non s\u00e9curis\u00e9\u00a0;</li> <li>lignes 21-22\u00a0: la classe [AppUserDetails] qui donne acc\u00e8s aux utilisateurs de l'application est inject\u00e9e\u00a0;</li> <li>ligne 25\u00a0: un bool\u00e9en qui s\u00e9curise (true) ou non (false) l'application web\u00a0;</li> <li>lignes 27-32\u00a0: la m\u00e9thode [configure(HttpSecurity http)] d\u00e9finit les utilisateurs et leurs r\u00f4les. Elle re\u00e7oit en param\u00e8tre un type [AuthenticationManagerBuilder]. Ce param\u00e8tre est enrichi de deux informations (ligne 38)\u00a0:</li> <li>une r\u00e9f\u00e9rence sur le service [appUserDetailsService] de la ligne 22 qui donne acc\u00e8s aux utilisateurs enregistr\u00e9s. On notera ici que le fait qu'ils soient enregistr\u00e9s dans une base de donn\u00e9es n'appara\u00eet pas. Ils pourraient donc \u00eatre dans un cache, d\u00e9livr\u00e9s par un service web, ...</li> <li>le type de cryptage utilis\u00e9 pour le mot de passe. On rappelle ici que nous avons utilis\u00e9 l'algorithme BCrypt\u00a0;</li> <li>lignes 34-52\u00a0: la m\u00e9thode [configure(HttpSecurity http)] d\u00e9finit les droits d'acc\u00e8s aux URL du service web\u00a0;</li> <li>ligne 37\u00a0: nous avons vu dans le projet d'introduction que par d\u00e9faut Spring Security g\u00e9rait un jeton CSRF (Cross Site Request Forgery) que l'utilisateur qui voulait s'authentifier devait renvoyer au serveur. Ici ce m\u00e9canisme est d\u00e9sactiv\u00e9. Ceci alli\u00e9 au bool\u00e9en (isSecured=false) permet d'utiliser l'application web sans s\u00e9curit\u00e9\u00a0;</li> <li>ligne 41\u00a0: on active le mode d'authentification par ent\u00eate HTTP. Le client devra envoyer l'ent\u00eate HTTP suivant\u00a0: <pre><code>Authorization:Basic code\n</code></pre></li> </ul> <p>o\u00f9 code est le codage de la cha\u00eene login:password par l'algorithme Base64. Par exemple, le codage Base64 de la cha\u00eene admin:admin est YWRtaW46YWRtaW4=. Donc l'utilisateur de login [admin] et de mot de passe [admin] enverra l'ent\u00eate HTTP suivant pour s'authentifier\u00a0:</p> <pre><code>Authorization:Basic YWRtaW46YWRtaW4=\n</code></pre> <ul> <li>lignes 46-48\u00a0: indiquent que toutes les URL du service web sont accessibles aux utilisateurs ayant le r\u00f4le [ROLE_ADMIN]. Cela veut dire qu'un utilisateur n'ayant pas ce r\u00f4le ne peut acc\u00e9der au service web\u00a0;</li> <li>ligne 50\u00a0: en mode [session], un utilisateur qui s'est authentifi\u00e9 une fois n'a pas besoin de le faire pour ses acc\u00e8s suivants. Ici on d\u00e9sactive ce mode, aussi l'utilisateur devra-t-il s'authentifier \u00e0 chaque acc\u00e8s\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1648-tests-de-la-couche-dao","title":"16.4.8. Tests de la couche [DAO]","text":"<p>Tout d'abord, nous cr\u00e9ons une classe ex\u00e9cutable [CreateUser] capable de cr\u00e9er un utilisateur avec un r\u00f4le\u00a0:</p> <pre><code>package sprin.security.tests;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.security.crypto.bcrypt.BCrypt;\n\nimport spring.security.config.DaoConfig;\nimport spring.security.entities.Role;\nimport spring.security.entities.User;\nimport spring.security.entities.UserRole;\nimport spring.security.repositories.RoleRepository;\nimport spring.security.repositories.UserRepository;\nimport spring.security.repositories.UserRoleRepository;\n\npublic class CreateUser {\n\n    public static void main(String[] args) {\n        // syntaxe : login password roleName\n\n        // il faut trois param\u00e8tres\n        if (args.length != 3) {\n            System.out.println(\"Syntaxe : [pg] user password role\");\n            System.exit(0);\n        }\n        // on r\u00e9cup\u00e8re les param\u00e8tres\n        String login = args[0];\n        String password = args[1];\n        String roleName = String.format(\"ROLE_%s\", args[2].toUpperCase());\n        // contexte Spring\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoConfig.class);\n        UserRepository userRepository = context.getBean(UserRepository.class);\n        RoleRepository roleRepository = context.getBean(RoleRepository.class);\n        UserRoleRepository userRoleRepository = context.getBean(UserRoleRepository.class);\n        // le r\u00f4le existe-t-il d\u00e9j\u00e0 ?\n        Role role = roleRepository.findRoleByName(roleName);\n        // s'il n'existe pas on le cr\u00e9e\n        if (role == null) {\n            role = roleRepository.save(new Role(roleName));\n        }\n        // l'utilisateur existe-t-il d\u00e9j\u00e0 ?\n        User user = userRepository.findUserByLogin(login);\n        // s'il n'existe pas on le cr\u00e9e\n        if (user == null) {\n            // on hashe le mot de passe avec bcrypt\n            String crypt = BCrypt.hashpw(password, BCrypt.gensalt());\n            // on sauvegarde l'utilisateur\n            user = userRepository.save(new User(login, login, crypt));\n            // on cr\u00e9e la relation avec le r\u00f4le\n            userRoleRepository.save(new UserRole(user, role));\n        } else {\n            // l'utilisateur existe d\u00e9j\u00e0- a-t-il le r\u00f4le demand\u00e9 ?\n            boolean trouv\u00e9 = false;\n            for (Role r : userRepository.getRoles(user.getId())) {\n                if (r.getName().equals(roleName)) {\n                    trouv\u00e9 = true;\n                    break;\n                }\n            }\n            // si pas trouv\u00e9, on cr\u00e9e la relation avec le r\u00f4le\n            if (!trouv\u00e9) {\n                userRoleRepository.save(new UserRole(user, role));\n            }\n        }\n\n        // fermeture contexte Spring\n        context.close();\n        // fin\n        System.out.println(\"Travail termin\u00e9...\");\n    }\n\n}\n</code></pre> <ul> <li>ligne 17\u00a0: la classe attend trois arguments d\u00e9finissant un utilisateur\u00a0: son login, son mot de passe, son r\u00f4le\u00a0;</li> <li>lignes 25-27\u00a0: les trois param\u00e8tres sont r\u00e9cup\u00e9r\u00e9s\u00a0;</li> <li>ligne 29\u00a0: le contexte Spring est construit \u00e0 partir de la classe de configuration [AppConfig]\u00a0;</li> <li>lignes 30-32\u00a0: on r\u00e9cup\u00e8re les r\u00e9f\u00e9rences des trois [Repository] qui peuvent nous \u00eatre utiles pour cr\u00e9er l'utilisateur\u00a0;</li> <li>ligne 34\u00a0: on regarde si le r\u00f4le existe d\u00e9j\u00e0\u00a0;</li> <li>lignes 36-38\u00a0: si ce n'est pas le cas, on le cr\u00e9e en base. Il aura un nom du type [ROLE_XX]\u00a0;</li> <li>ligne 40\u00a0: on regarde si le login existe d\u00e9j\u00e0\u00a0;</li> <li>lignes 42-49\u00a0: si le login n'existe pas, on le cr\u00e9e en base\u00a0;</li> <li> <p>ligne 44\u00a0: on crypte le mot de passe. On utilise ici, la classe [BCrypt] de Spring Security (ligne 4). On a donc besoin des archives de ce framework. Le fichier [pom.xml] inclut cette d\u00e9pendance\u00a0: <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> <li> <p>ligne 46\u00a0: l'utilisateur est persist\u00e9 en base\u00a0;</p> </li> <li>ligne 48\u00a0: ainsi que la relation qui le lie \u00e0 son r\u00f4le\u00a0;</li> <li>lignes 51-57\u00a0: cas o\u00f9 le login existe d\u00e9j\u00e0 \u2013 on regarde alors si parmi ses r\u00f4les se trouve d\u00e9j\u00e0 le r\u00f4le qu'on veut lui attribuer\u00a0;</li> <li>ligne 59-61 : si le r\u00f4le cherch\u00e9 n'a pas \u00e9t\u00e9 trouv\u00e9, on cr\u00e9e une ligne dans la table [USERS_ROLES] pour relier l'utilisateur \u00e0 son r\u00f4le\u00a0;</li> <li>on ne s'est pas prot\u00e9g\u00e9 des exceptions \u00e9ventuelles. C'est une classe de soutien pour cr\u00e9er rapidement un utilisateur avec un r\u00f4le. Lorsqu'on ex\u00e9cute la classe avec les arguments [x x guest], on obtient en base les r\u00e9sultats suivants\u00a0:</li> </ul> <p>Table [USERS]</p> <p>Table [ROLES]</p> <p>Table [USERS_ROLES]</p> <p>Consid\u00e9rons maintenant la seconde classe [UsersTest] qui est un test JUnit\u00a0:</p> <pre><code>package spring.security.tests;\n\nimport java.util.List;\n\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.crypto.bcrypt.BCrypt;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.collect.Lists;\n\nimport spring.security.config.DaoConfig;\nimport spring.security.dao.AppUserDetails;\nimport spring.security.dao.AppUserDetailsService;\nimport spring.security.entities.Role;\nimport spring.security.entities.User;\nimport spring.security.repositories.UserRepository;\n\n@SpringApplicationConfiguration(classes = DaoConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class UsersTest {\n\n    @Autowired\n    private UserRepository userRepository;\n    @Autowired\n    private AppUserDetailsService appUserDetailsService;\n\n    // mappeur jSON\n    private ObjectMapper mapper = new ObjectMapper();\n\n    @Test\n    public void findAllUsersWithTheirRoles() throws JsonProcessingException {\n        Iterable&lt;User&gt; users = userRepository.findAll();\n        for (User user : users) {\n            System.out.println(String.format(\"\\n----------Utilisateur [%s]\",mapper.writeValueAsString(user)));\n            display(\"Roles :\", userRepository.getRoles(user.getId()));\n        }\n    }\n\n    @Test\n    public void findUserByLogin() {\n        // on r\u00e9cup\u00e8re l'utilisateur [admin]\n        User user = userRepository.findUserByLogin(\"admin\");\n        // on v\u00e9rifie que son mot de passe est [admin]\n        Assert.assertTrue(BCrypt.checkpw(\"admin\", user.getPassword()));\n        // on v\u00e9rifie le r\u00f4le de admin / admin\n        List&lt;Role&gt; roles = Lists.newArrayList(userRepository.getRoles(\"admin\", user.getPassword()));\n        Assert.assertEquals(1L, roles.size());\n        Assert.assertEquals(\"ROLE_ADMIN\", roles.get(0).getName());\n    }\n\n    @Test\n    public void loadUserByUsername() {\n        // on r\u00e9cup\u00e8re l'utilisateur [admin]\n        AppUserDetails userDetails = (AppUserDetails) appUserDetailsService.loadUserByUsername(\"admin\");\n        // on v\u00e9rifie que son mot de passe est [admin]\n        Assert.assertTrue(BCrypt.checkpw(\"admin\", userDetails.getPassword()));\n        // on v\u00e9rifie le r\u00f4le de admin / admin\n        @SuppressWarnings(\"unchecked\")\n        List&lt;SimpleGrantedAuthority&gt; authorities = (List&lt;SimpleGrantedAuthority&gt;) userDetails.getAuthorities();\n        Assert.assertEquals(1L, authorities.size());\n        Assert.assertEquals(\"ROLE_ADMIN\", authorities.get(0).getAuthority());\n    }\n\n    // m\u00e9thode utilitaire - affiche les \u00e9l\u00e9ments d'une collection\n    private void display(String message, Iterable&lt;?&gt; elements) throws JsonProcessingException {\n        System.out.println(message);\n        for (Object element : elements) {\n            System.out.println(mapper.writeValueAsString(element));\n        }\n    }\n}\n</code></pre> <ul> <li>lignes 37-44\u00a0: test visuel. On affiche tous les utilisateurs avec leurs r\u00f4les\u00a0;</li> <li>lignes 46-56\u00a0: on v\u00e9rifie que l'utilisateur [admin] a le mot de passe [admin] et le  r\u00f4le [ROLE_ADMIN] en utilisant le repository [UserRepository]\u00a0;</li> <li>ligne 51\u00a0: [admin] est le mot de passe en clair. En base, il est crypt\u00e9 selon l'algorithme BCrypt. La m\u00e9thode [BCrypt.checkpw] permet de v\u00e9rifier que le mot de passe en clair une fois crypt\u00e9 est bien \u00e9gal \u00e0 celui qui est en base\u00a0;</li> <li>lignes 58-69\u00a0: on v\u00e9rifie que l'utilisateur [admin] a le mot de passe [admin] et le  r\u00f4le [ROLE_ADMIN] en utilisant le service [appUserDetailsService]\u00a0; L'ex\u00e9cution des tests r\u00e9ussit avec les logs suivants\u00a0:</li> </ul> <pre><code>----------Utilisateur [{\"id\":14,\"version\":0,\"identity\":\"admin\",\"login\":\"admin\",\"password\":\"$2a$10$FN1LMKjPU46aPffh9Zaw4exJOLo51JJPWrxqzak/eJrbt3CO9WzVG\"}]\nRoles :\n{\"id\":6,\"version\":0,\"name\":\"ROLE_ADMIN\"}\n\n----------Utilisateur [{\"id\":15,\"version\":0,\"identity\":\"user\",\"login\":\"user\",\"password\":\"$2a$10$SJehR9Mv2VdyRZo9F0rXa.hKAoGLhJg6kSdyfExi40mEJrNOj0BTq\"}]\nRoles :\n{\"id\":7,\"version\":0,\"name\":\"ROLE_USER\"}\n\n----------Utilisateur [{\"id\":16,\"version\":0,\"identity\":\"guest\",\"login\":\"guest\",\"password\":\"$2a$10$ubyWJb/vg2XZnUOAUjspZuz9jpHP3fIbPTbwQU115EtLdeSZ2PB7q\"}]\nRoles :\n{\"id\":5,\"version\":0,\"name\":\"ROLE_GUEST\"}\n\n----------Utilisateur [{\"id\":17,\"version\":0,\"identity\":\"x\",\"login\":\"x\",\"password\":\"$2a$10$kEXA56wpKHFReVqwQTyWguKguK8I4uhA2zb6t3wGxag8Dyv7AhLom\"}]\nRoles :\n{\"id\":5,\"version\":0,\"name\":\"ROLE_GUEST\"}\n</code></pre>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#1649-tests-du-service-web","title":"16.4.9. Tests du service web","text":"<p>Nous allons tester le service web avec le client Chrome [Advanced Rest Client]. Nous allons avoir besoin de pr\u00e9ciser l'ent\u00eate HTTP d'authentification\u00a0:</p> <pre><code>Authorization:Basic code\n</code></pre> <p>o\u00f9 [code] est le code Base64 de la cha\u00eene [login:password]. Pour g\u00e9n\u00e9rer ce code, on peut utiliser le programme suivant\u00a0:</p> <pre><code>package spring.security.helpers;\n\nimport org.springframework.security.crypto.codec.Base64;\n\npublic class Base64Encoder {\n\n    public static void main(String[] args) {\n        // on attend deux arguments : login password\n        if (args.length != 2) {\n            System.out.println(\"Syntaxe : login password\");\n            System.exit(0);\n        }\n        // on r\u00e9cup\u00e8re les deux arguments\n        String cha\u00eene = String.format(\"%s:%s\", args[0], args[1]);\n        // on encode la cha\u00eene\n        byte[] data = Base64.encode(cha\u00eene.getBytes());\n        // on affiche son encodage Base64\n        System.out.println(new String(data));\n    }\n\n}\n</code></pre> <p>Si nous ex\u00e9cutons ce programme avec les deux arguments [admin admin]\u00a0:</p> <p>nous obtenons le r\u00e9sultat suivant\u00a0:</p> <pre><code>YWRtaW46YWRtaW4=\n</code></pre> <p>Maintenant que nous savons g\u00e9n\u00e9rer l'ent\u00eate HTTP d'authentification, nous lan\u00e7ons le service web s\u00e9curis\u00e9, puis avec le client Chrome [Advanced Rest Client], nous demandons la liste des tous les produits\u00a0:</p> <ul> <li>en [1], nous demandons l'URL des cat\u00e9gories\u00a0;</li> <li>en [2], avec une m\u00e9thode GET\u00a0;</li> <li>en [3], nous donnons l'ent\u00eate HTTP de l'authentification. Le code [YWRtaW46YWRtaW4=] est le codage Base64 de la cha\u00eene [admin:admin]\u00a0;</li> <li>en [4], nous envoyons la commande HTTP\u00a0; La r\u00e9ponse du serveur est la suivante\u00a0:</li> </ul> <ul> <li>en [1], l'ent\u00eate HTTP d'authentification\u00a0;</li> <li>en [2], le serveur renvoie une r\u00e9ponse jSON\u00a0; On obtient bien la liste des cat\u00e9gories :</li> </ul> <p>Tentons maintenant une requ\u00eate HTTP avec un ent\u00eate d'authentification incorrect. La r\u00e9ponse est alors la suivante\u00a0:</p> <ul> <li>en [1]\u00a0: l'ent\u00eate HTTP d'authentification\u00a0; Nous obtenons la r\u00e9ponse suivante\u00a0:</li> </ul> <ul> <li>en [2]\u00a0: la r\u00e9ponse du service web\u00a0; Maintenant, essayons l'utilisateur user / user. Il existe mais n'a pas acc\u00e8s au service web. Si nous ex\u00e9cutons le programme d'encodage Base64 avec les deux arguments [user user]\u00a0:</li> </ul> <p>nous obtenons le r\u00e9sultat suivant\u00a0:</p> <pre><code>dXNlcjp1c2Vy\n</code></pre> <ul> <li>en [1] \u00a0: l'ent\u00eate HTTP d'authentification erron\u00e9\u00a0;</li> </ul> <ul> <li>en [2]\u00a0: la r\u00e9ponse du service web. Elle est diff\u00e9rente de la pr\u00e9c\u00e9dente qui \u00e9tait [401 Unauthorized]. Cette fois-ci, l'utilisateur s'est authentifi\u00e9 correctement mais n'a pas les droits suffisants pour acc\u00e9der \u00e0 l'URL\u00a0; Notre service web s\u00e9curis\u00e9 est d\u00e9sormais op\u00e9rationnel.</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#16410-une-url-dauthentification","title":"16.4.10. Une URL d'authentification","text":"<p>Nous allons cr\u00e9er une URL qui nous permettra de savoir si un utilisateur est autoris\u00e9 ou non \u00e0 acc\u00e9der au service web. pour cela nous cr\u00e9ons le nouveau contr\u00f4leur MVC [AuthenticateController] suivant\u00a0:</p> <pre><code>package spring.security.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport spring.webjson.models.Response;\n\n@Controller\npublic class AuthenticateController {\n\n    // d\u00e9pendances Spring\n    @Autowired\n    private ApplicationContext context;\n\n    @RequestMapping(value = \"/authenticate\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String authenticate() throws JsonProcessingException {\n        // r\u00e9ponse jSON\n        ObjectMapper mapperResponse = context.getBean(ObjectMapper.class);\n        return mapperResponse.writeValueAsString(new Response&lt;Void&gt;(0, null, null));\n    }\n\n}\n</code></pre> <ul> <li>ligne 15\u00a0: la classe [AuthenticateController] est un contr\u00f4leur Spring. A ce titre elle expose des URL\u00a0;</li> <li>ligne 22\u00a0: expose l'URL [/authenticate]\u00a0;</li> <li>ligne 23\u00a0: le r\u00e9sultat de la m\u00e9thode sera envoy\u00e9 directement au client\u00a0;</li> <li>lignes 26-27\u00a0: la m\u00e9thode se contente de renvoyer un objet [Response] vide mais avec un [status] \u00e9gal \u00e0 0, montrant qu'il n'y a pas eu d'erreur\u00a0; A quoi sert cette URL\u00a0? Lorsque nous voudrons simplement authentifier un utilisateur, nous la demanderons. Nous avons vu que si la couche de s\u00e9curit\u00e9 n'accepte pas cet utilisateur, elle renvoie une exception. Voici un exemple\u00a0;</li> </ul> <p>Avec l'utilisateur [admin:admin]\u00a0:</p> <p>On a une r\u00e9ponse vide mais pas d'exception.</p> <p>Avec l'utilisateur [user:user]\u00a0:</p> <p>On a eu une exception.</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#16411-conclusion","title":"16.4.11. Conclusion","text":"<p>L'ajout des classes n\u00e9cessaires \u00e0 Spring Security a pu se faire sans modifications du projet web / json originel. Ce cas tr\u00e8s favorable d\u00e9coule du fait que les trois tables ajout\u00e9es dans la base de donn\u00e9es sont ind\u00e9pendantes des tables existantes. On aurait m\u00eame pu les mettre dans une base de donn\u00e9es s\u00e9par\u00e9e. Dans d'autres cas, les tables ajout\u00e9es peuvent avoir des relations avec les tables existantes. Il faut alors modifier les entit\u00e9s JPA ce qui en g\u00e9n\u00e9ral impacte toutes les couches du projet.</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#165-un-client-programme-pour-le-service-web-json-securise","title":"16.5. Un client programm\u00e9 pour le service web / jSON s\u00e9curis\u00e9","text":"<p>Nous avons d\u00e9j\u00e0 \u00e9crit un client pour le service web / jSON non s\u00e9curis\u00e9\u00a0:</p> <p>Nous allons maintenant cr\u00e9er un client programm\u00e9 pour le service web s\u00e9curis\u00e9\u00a0:</p> <p>Nous dupliquons le projet d\u00e9j\u00e0 \u00e9crit [intro-webjson-client] dans un nouveau projet [intro-spring-security-client-01]\u00a0:</p>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#16501-la-classe-abstractdao","title":"16.5.0.1. La classe [AbstractDao]","text":"<p>La classe [AbstractDao] assure la communication HTTP avec le serveur web / jSON s\u00e9curis\u00e9. Comme nous venons de le voir, dans cette communication HTTP, le client doit d\u00e9sormais envoyer un ent\u00eate d'authentification, par exemple\u00a0:</p> <pre><code>Authorization:Basic YWRtaW46YWRtaW4=\n</code></pre> <p>Cela se fait de la fa\u00e7on suivante\u00a0:</p> <pre><code>package spring.security.client.dao;\n\nimport java.net.URI;\n...\n\npublic abstract class AbstractDao {\n\n    // data\n    @Autowired\n    protected RestTemplate restTemplate;\n    @Autowired\n    protected String urlServiceWebJson;\n\n    // requ\u00eate g\u00e9n\u00e9rique\n    protected String getResponse(User user, String url, String jsonPost) {\n\n// url : URL \u00e0 contacter\n</code></pre> <ul> <li>ligne 15\u00a0: la m\u00e9thode g\u00e9n\u00e9rique [getResponse] en charge de la communication HTTP avec le service web s\u00e9curis\u00e9, admet d\u00e9sormais comme premier param\u00e8tre l'utilisateur qui demande une URL. La classe [User] est la suivante\u00a0: Cette classe est la suivante\u00a0:</li> </ul> <pre><code>package spring.security.client.entities;\n\npublic class User {\n\n    // propri\u00e9t\u00e9s\n    private String login;\n    private String password;\n\n    // constructeur\n    public User() {\n    }\n\n    public User(String login, String password) {\n        this.login = login;\n        this.password = password;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>La m\u00e9thode [getResponse] devient alors la suivante\u00a0:</p> <pre><code>package spring.security.client.dao;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.Base64;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.http.RequestEntity.BodyBuilder;\nimport org.springframework.http.RequestEntity.HeadersBuilder;\nimport org.springframework.web.client.RestTemplate;\n\nimport spring.security.client.entities.User;\n\npublic abstract class AbstractDao {\n\n    // data\n    @Autowired\n    protected RestTemplate restTemplate;\n    @Autowired\n    protected String urlServiceWebJson;\n\n    private String getBase64(User user) {\n        // on encode en base 64 l'utilisateur et son mot de passe - n\u00e9cessite java 8\n        String cha\u00eene = String.format(\"%s:%s\", user.getLogin(), user.getPassword());\n        return String.format(\"Basic %s\", new String(Base64.getEncoder().encode(cha\u00eene.getBytes())));\n    }\n\n    // requ\u00eate g\u00e9n\u00e9rique\n    protected String getResponse(User user, String url, String jsonPost) {\n\n        // url : URL \u00e0 contacter\n        // jsonPost : la valeur jSON \u00e0 poster\n        try {\n            // ex\u00e9cution requ\u00eate\n            RequestEntity&lt;?&gt; request;\n            if (jsonPost == null) {\n                HeadersBuilder&lt;?&gt; headersBuilder = RequestEntity.get(new URI(String.format(\"%s%s\", urlServiceWebJson, url)))\n                        .accept(MediaType.APPLICATION_JSON);\n                if (user != null) {\n                    headersBuilder = headersBuilder.header(\"Authorization\", getBase64(user));\n                }\n                request = headersBuilder.build();\n            } else {\n                BodyBuilder bodyBuilder = RequestEntity.post(new URI(String.format(\"%s%s\", urlServiceWebJson, url)))\n                        .header(\"Content-Type\", \"application/json\").accept(MediaType.APPLICATION_JSON);\n                if (user != null) {\n                    bodyBuilder = bodyBuilder.header(\"Authorization\", getBase64(user));\n                }\n                request = bodyBuilder.body(jsonPost);\n            }\n\n            // on ex\u00e9cute la requ\u00eate\n            return restTemplate.exchange(request, new ParameterizedTypeReference&lt;String&gt;() {\n            }).getBody();\n        } catch (URISyntaxException e1) {\n            throw new DaoException(20, e1);\n        } catch (RuntimeException e2) {\n            throw new DaoException(21, e2);\n        }\n    }\n\n}\n</code></pre> <ul> <li>lignes 42-44, 49-51\u00a0: si l'utilisateur [user] n'est pas null, alors on ajoute l'ent\u00eate d'authentification. L'encodage Base64 de l'utilisateur et de son mot de passe est assur\u00e9 par la m\u00e9thode [getBase64] des lignes 25-29. On fera attention au fait que cette m\u00e9thode utilise une classe [Base64] appartenant au JDK 1.8.</li> <li>en-dehors des lignes pr\u00e9c\u00e9dentes, le code reste inchang\u00e9\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#16502-linterface-idao","title":"16.5.0.2. L'interface [IDao]","text":"<p>Toutes les m\u00e9thodes de l'interface [IDao] re\u00e7oivent un param\u00e8tre suppl\u00e9mentaire [User user]\u00a0:</p> <pre><code>package spring.security.client.dao;\n\nimport java.util.List;\n\nimport spring.security.client.entities.Categorie;\nimport spring.security.client.entities.Produit;\nimport spring.security.client.entities.User;\n\npublic interface IDaoClient {\n\n    // authentification\n    public void authenticate(User user);\n\n    // insertion d'une liste de produits\n    public List&lt;Produit&gt; addProduits(User user, List&lt;Produit&gt; produits);\n\n    // suppression de tous les produits\n    public void deleteAllProduits(User user);\n\n    // mise \u00e0 jour d'une liste de produits\n    public List&lt;Produit&gt; updateProduits(User user, List&lt;Produit&gt; produits);\n\n    // obtention de tous les produits\n    public List&lt;Produit&gt; getAllProduits(User user);\n\n    // insertion d'une liste de categories\n    public List&lt;Categorie&gt; addCategories(User user, List&lt;Categorie&gt; categories);\n\n    // suppression de tous les categories\n    public void deleteAllCategories(User user);\n\n    // mise \u00e0 jour d'une liste de categories\n    public List&lt;Categorie&gt; updateCategories(User user, List&lt;Categorie&gt; categories);\n\n    // obtention de tous les categories\n    public List&lt;Categorie&gt; getAllCategories(User user);\n\n    // un produit particulier\n    public Produit getProduitByIdWithCategorie(User user, Long idProduit);\n\n    public Produit getProduitByIdWithoutCategorie(User user, Long idProduit);\n\n    public Produit getProduitByNameWithCategorie(User user, String nom);\n\n    public Produit getProduitByNameWithoutCategorie(User user, String nom);\n\n    // une cat\u00e9gorie particuli\u00e8re\n    public Categorie getCategorieByIdWithProduits(User user, Long idCategorie);\n\n    public Categorie getCategorieByIdWithoutProduits(User user, Long idCategorie);\n\n    public Categorie getCategorieByNameWithProduits(User user, String nom);\n\n    public Categorie getCategorieByNameWithoutProduits(User user, String nom);\n\n}\n</code></pre> <ul> <li>ligne 12\u00a0: nous avons ajout\u00e9 la m\u00e9thode [authenticate(User user)] pour authentifier un utilisateur. Elle lance une exception si l'utilsateur n'a pas le droit d'acc\u00e9der \u00e0 l'URL [/authenticate] du service web\u00a0;</li> </ul>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#16503-la-classe-dao","title":"16.5.0.3. La classe [Dao]","text":"<p>Toutes les m\u00e9thodes de la classe [Dao] re\u00e7oivent un param\u00e8tre suppl\u00e9mentaire [User user] qu'elles passent \u00e0 la m\u00e9thode g\u00e9n\u00e9rique [getResponse] de la classe [AbstractDao]. Voici deux exemples\u00a0:</p> <pre><code>// authentification\n    @Override\n    public void authenticate(User user) {\n        getResponse(user, \"/authenticate\", null);\n    }\n\n    @Override\n    public List&lt;Produit&gt; addProduits(User user, List&lt;Produit&gt; produits) {\n        // ----------- ajouter des produits (sans leur cat\u00e9gorie)\n        try {\n            // mappeurs jSON\n            ObjectMapper mapperPost = context.getBean(ObjectMapper.class);\n            mapperPost.setFilters(jsonFilterProduitWithoutCategorie);\n            ObjectMapper mapperResponse = mapperPost;\n            // requ\u00eate\n            Response&lt;List&lt;Produit&gt;&gt; response = mapperResponse.readValue(\n                    getResponse(user, \"/addProduits\", mapperPost.writeValueAsString(produits)),\n                    new TypeReference&lt;Response&lt;List&lt;Produit&gt;&gt;&gt;() {\n                    });\n            // erreur ?\n            if (response.getStatus() != 0) {\n                // on lance 1 exception\n                throw new DaoException(response.getStatus(), response.getMessages());\n            } else {\n                // on rend le coeur de la r\u00e9ponse du serveur\n                return response.getBody();\n            }\n        } catch (DaoException e1) {\n            throw e1;\n        } catch (IOException | RuntimeException e2) {\n            throw new DaoException(100, e2);\n        }\n    }\n</code></pre>"},{"location":"cours-securiser-lx27acces-a-un-service-web-avec-spring-security.html#16504-tests-unitaires-de-la-classe-dao","title":"16.5.0.4. Tests unitaires de la classe [Dao]","text":"<p>La classe [Test01] de tests unitaires de la classe [Dao] est modifi\u00e9e de la fa\u00e7on suivante\u00a0:</p> <pre><code>package client.tests.junit;\n\n...\n\n@SpringApplicationConfiguration(classes = DaoConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // contexte Spring\n    @Autowired\n    private ApplicationContext context;\n    // couche [DAO]\n    @Autowired\n    private IDaoClient dao;\n\n    // utilisateurs\n    static private User admin;\n    static private User user;\n    static private User unknown;\n\n    @BeforeClass\n    public static void init() {\n        admin = new User(\"admin\", \"admin\");\n        user = new User(\"user\", \"user\");\n        unknown = new User(\"x\", \"y\");\n    }\n\n    @Before\n    public void cleanAndFill() {\n        // on nettoie la base avant chaque test\n        log(\"Vidage de la base de donn\u00e9es\", 1);\n        // on vide la table [CATEGORIES] - par cascade la table [PRODUITS] va \u00eatre vid\u00e9e\n        dao.deleteAllCategories(admin);\n        // --------------------------------------------------------------------------------------\n        log(\"Remplissage de la base\", 1);\n        // on remplit les tables\n        List&lt;Categorie&gt; categories = new ArrayList&lt;Categorie&gt;();\n        for (int i = 0; i &lt; 2; i++) {\n            Categorie categorie = new Categorie(String.format(\"categorie%d\", i));\n            for (int j = 0; j &lt; 5; j++) {\n                categorie.addProduit(new Produit(String.format(\"produit%d%d\", i, j), 100 * (1 + (double) (i * 10 + j) / 100),\n                        String.format(\"desc%d%d\", i, j)));\n            }\n            categories.add(categorie);\n        }\n        // ajout de la cat\u00e9gorie - par cascade les produits vont eux aussi \u00eatre ins\u00e9r\u00e9s\n        dao.addCategories(admin, categories);\n    }\n\n    @Test\n    public void showDataBase() throws BeansException, JsonProcessingException {\n        // liste des cat\u00e9gories\n        log(\"Liste des cat\u00e9gories\", 2);\n        List&lt;Categorie&gt; categories = dao.getAllCategories(admin);\n        affiche(categories, context.getBean(\"jsonMapperCategorieWithoutProduits\", ObjectMapper.class));\n        // liste des produits\n        log(\"Liste des produits\", 2);\n        List&lt;Produit&gt; produits = dao.getAllProduits(admin);\n        affiche(produits, context.getBean(\"jsonMapperProduitWithoutCategorie\", ObjectMapper.class));\n        // quelques v\u00e9rifications\n        Assert.assertEquals(2, categories.size());\n        Assert.assertEquals(10, produits.size());\n        Categorie categorie = findCategorieByName(\"categorie0\", categories);\n        Assert.assertNotNull(categorie);\n        Produit produit = findProduitByName(\"produit03\", produits);\n        Assert.assertNotNull(produit);\n        Long idCategorie = produit.getIdCategorie();\n        Assert.assertEquals(categorie.getId(), idCategorie);\n    }\n...\n    @Test()\n    public void checkUserUser() {\n        ServiceException se = null;\n        try {\n            dao.authenticate(user);\n        } catch (ServiceException e) {\n            se = e;\n        }\n        Assert.assertNotNull(se);\n        Assert.assertEquals(\"403 Forbidden\", se.getMessages().get(0));\n    }\n\n    @Test()\n    public void checkUserUnknown() {\n        ServiceException se = null;\n        try {\n            dao.authenticate(unknown);\n        } catch (ServiceException e) {\n            se = e;\n        }\n        Assert.assertNotNull(se);\n        Assert.assertEquals(\"401 Unauthorized\", se.getMessages().get(0));\n    }\n\n    @Test()\n    public void checkUserAdmin() {\n        ServiceException se = null;\n        try {\n            dao.authenticate(admin);\n        } catch (ServiceException e) {\n            se = e;\n        }\n        Assert.assertNull(se);\n    }\n...\n}\n</code></pre> <ul> <li>lors de l'initialisation de la classe de test, lignes 21-26, trois utilisateurs sont cr\u00e9\u00e9s\u00a0:</li> <li>l'utilisateur [admin] a acc\u00e8s aux URL du service web, test lignes 96-104\u00a0;</li> <li>l'utilisateur [user] existe mais n'est pas autoris\u00e9 \u00e0 utiliser les URL du service web, test lignes 71-81\u00a0;</li> <li>l'utilisateur [unknown] n'existe pas, test lignes 83-93\u00a0;</li> <li>les m\u00e9thodes de tests sont celles d\u00e9j\u00e0 vues pour le service web non s\u00e9curis\u00e9, si ce n'est que les m\u00e9thodes de l'interface [IDaoClient] sont appel\u00e9es avec comme premier param\u00e8tre, l'utilisateur [admin] qui a le droit d'utiliser les URL\u00a0; Le test passe mais on peut constater qu'il est plus lent qu'avec le service web non s\u00e9curis\u00e9. La s\u00e9curisation d'une application augmente sensiblement ses temps de r\u00e9ponse. On peut noter un facteur important dans les performances du service web s\u00e9curis\u00e9\u00a0: dans la classe [AppConfig] qui le configure, nous avons \u00e9crit\u00a0:</li> </ul> <pre><code>    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // CSRF\n        http.csrf().disable();\n        // application s\u00e9curis\u00e9e ?\n        if (activateSecurity) {\n            // le mot de passe est transmis par le header Authorization: Basic xxxx\n            http.httpBasic();\n            // la m\u00e9thode HTTP OPTIONS doit \u00eatre autoris\u00e9e pour tous\n            http.authorizeRequests() //\n                    .antMatchers(HttpMethod.OPTIONS, \"/\", \"/**\").permitAll();\n            // seul le r\u00f4le ADMIN peut utiliser l'application\n            http.authorizeRequests() //\n                    .antMatchers(\"/\", \"/**\") // toutes les URL\n                    .hasRole(\"ADMIN\");\n            // pas de session\n            http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);\n        }\n}\n</code></pre> <p>La ligne 17 a un co\u00fbt. Elle force l'utilisateur \u00e0 s'authentifier \u00e0 chaque acc\u00e8s. Si on la met en commentaires, la dur\u00e9e du test JUnit pr\u00e9c\u00e9dent passe de 10,57 secondes \u00e0 4,21 secondes, ceci parce que l'utilisateur [admin] ne s'authentifie que pour le premier test et pas pour les suivants (m\u00eame si l'ent\u00eate HTTP d'authentification est envoy\u00e9 par le client, le serveur lui ne rev\u00e9rifie pas le mot de passe de l'utilisateur). Avec un service web non s\u00e9curis\u00e9, la dur\u00e9e du test JUnit tombe \u00e0 2,33 secondes.</p>"},{"location":"introduction.html","title":"1. Introduction","text":""},{"location":"introduction.html#11-contexte","title":"1.1. Contexte","text":"<p>Ce document est \u00e0 la fois un cours et un TD (Travail Dirig\u00e9) d'universit\u00e9. Il est destin\u00e9 \u00e0 des d\u00e9butants. Il utilise les sources suivantes\u00a0:</p> <p>R\u00e9f\u00e9rences : </p> <ul> <li>Introduction au langage Java\u00a0;</li> <li>Exploiter une base relationnelle avec l'\u00e9cosyst\u00e8me Spring\u00a0; Nous noterons ces r\u00e9f\u00e9rences respectivement [ref1] et [ref2]. La source [ref1] est ancienne (2002) mais suffisante pour ce document o\u00f9 elle n'est utilis\u00e9e que pour sa pr\u00e9sentation de la syntaxe du langage Java et de ses actions \u00e9l\u00e9mentaires. Le reste n\u00e9cessaire \u00e0 la r\u00e9alisation du TD est pr\u00e9sent\u00e9 dans ce document dans des chapitres intitul\u00e9s [Cours]. Ces chapitres proviennent directement de [ref2] (2015) et ont \u00e9t\u00e9 parfois simplifi\u00e9s.</li> </ul> <p>L'objectif du document est d'enseigner le langage Java dans une optique professionnelle. Pour cette raison, nous nous appuyons fortement sur le framework Spring [http://spring.io/] tr\u00e8s utilis\u00e9 dans le d\u00e9veloppement JEE (Java Enterprise Edition). Logiquement, ce cours devrait \u00eatre suivi par un cours JEE. C'est le cas \u00e0 l'Istia (universit\u00e9 d'Angers). JEE est la principale source d'emplois actuellement (novembre 2015) pour les jeunes d\u00e9veloppeurs Bac+5. Il y a beaucoup d'autres technologies que Spring dans le monde JEE. Spring a l'avantage d'\u00eatre compr\u00e9hensible et surtout d'apporter de bonnes pratiques de codage r\u00e9utilisables en dehors de l'\u00e9cosyst\u00e8me Spring. C'est ce qui explique son choix ici.</p> <p>Ce TD est utilis\u00e9 depuis plus de 10 ans et a \u00e9volu\u00e9 avec les technologies. Il est suivi (\u00e0 l'IstiA) d'un TD JEE [Introduction \u00e0 Java EE]. Ce dernier TD date de 2012 (on est ici en 2015) et m\u00e9riterait d'\u00eatre rafra\u00eechi. Il pr\u00e9sente l'orthodoxie JEE au travers du framework web JSF2 (Java Server Faces) et les EJB3 (Enterprise Java Bean). Mis bout \u00e0 bout, ces deux TD ont permis \u00e0 de nombreux \u00e9tudiants de d\u00e9crocher des stages JEE en ESN (Entreprises de Services Num\u00e9riques) et de s'y faire embaucher dans la foul\u00e9e.</p> <p>On ne trouvera pas dans ce document, une pr\u00e9sentation formelle de toutes les facettes de Java. Au fil des ans, le comportement des d\u00e9veloppeurs juniors face \u00e0 un probl\u00e8me a beaucoup \u00e9volu\u00e9. D\u00e9sormais, ils utilisent quasi syst\u00e9matiquement Internet pour trouver des bouts de code qui mis bout \u00e0 bout font un programme. Si on leur fournit un cours, ils l'utilisent assez peu et pr\u00e9f\u00e8rent de nouveau aller sur Internet. Dubitatif au d\u00e9part sur cette fa\u00e7on de travailler, j'ai quand m\u00eame \u00e9t\u00e9 \u00e9tonn\u00e9 des r\u00e9sultats obtenus. Ainsi des \u00e9tudiants faibles r\u00e9ussissaient \u00e0 produire des programmes qui marchaient alors que sans l'aide d'Internet ils n'y seraient probablement pas arriv\u00e9s.  Je m'appuie d\u00e9sormais sur cette fa\u00e7on de travailler.</p> <p>Des bouts de code ne donnent pas une vue d'ensemble de l'architecture d'une solution et c'est l'un des objectifs de ce document que de donner celle-ci. Les \u00e9tudiants font ce TD comme un TP, en autonomie. Il n'y a pas de cours magistral. Il y a un planning qui leur donne l'\u00e9tat d'avancement attendu d'eux au fil des s\u00e9ances. Ils peuvent \u00eatre en retard ou en avance sur ce planning. Leur avancement est v\u00e9rifi\u00e9 par un certain nombre de validations qu'ils doivent pr\u00e9senter \u00e0 l'enseignant. Celui-ci est pr\u00e9sent \u00e0 la fois pour leur fournir des explications lorsqu'ils en demandent et valider leur travail. Chacun va \u00e0 son rythme. A la fin des 36 h allou\u00e9s \u00e0 ce TD, certains auront fait 50% de validations en plus que d'autres mais chacun, c'est en tout cas l'objectif, aura compris ce qu'il a fait en autonomie. Ce TD peut \u00eatre fait sans l'accompagnement d'un enseignant. C'est pourquoi, il est disponible sur [https://tahe.developpez.com].</p> <p>Ce document ne conviendra pas \u00e0 ceux qui chercheraient un cours acad\u00e9mique sur Java, quelque chose o\u00f9 on explique Java de fa\u00e7on progressive et structur\u00e9e et o\u00f9 chaque d\u00e9tail de syntaxe est expliqu\u00e9 et justifi\u00e9. C'est plut\u00f4t une d\u00e9marche exp\u00e9rimentale qui est propos\u00e9e ici. Il est probable que l'\u00e9tudiant ne comprendra pas tout ce qui lui est propos\u00e9 dans le document mais il saura probablement r\u00e9utiliser son contenu \u00e0 bon escient et la compr\u00e9hension des d\u00e9tails viendra avec l'exp\u00e9rience.</p> <p>Ce document n'est pas non plus un cours d'algorithmique. L'algorithme du TD est basique et peut \u00eatre r\u00e9solu par tout d\u00e9butant suivant ses premiers cours d'algorithmique. Le document est centr\u00e9 sur l'environnement de d\u00e9veloppement professionnel en Java avec ses nombreuses biblioth\u00e8ques ou frameworks et sur l'architecture du code. La plupart des \u00e9tudiants que je vois passer pr\u00e9sentent des faiblesses en algorithmique qui sont confirm\u00e9es ensuite par les ma\u00eetres de stage. Donc oui, la ma\u00eetrise des algorithmes est importante mais ce n'est pas l'objet de ce cours-TD.</p> <p>Enfin, ce document (d\u00e9cembre 2015) ne pr\u00e9sente pas les derni\u00e8res nouveaut\u00e9s de Java, notamment les streams et les fonctions lambda. N\u00e9anmoins, on y utilise quelques \u00e9l\u00e9ments du dernier JDK, le JDK 1.8 et les codes qui suivent doivent \u00eatre compil\u00e9s par ce JDK.</p>"},{"location":"introduction.html#12-contenu","title":"1.2. Contenu","text":"<p>Le chapitre 2 pr\u00e9sente le sujet du TD, un calcul de r\u00e9sultats d'\u00e9lections. Le probl\u00e8me est basique. Le chapitre 2 demande d'impl\u00e9menter la solution avec deux langages C# et Java qui sont tr\u00e8s proches. L'impl\u00e9mentation se fait sans classes. L'objectif est la pr\u00e9sentation de la syntaxe de Java, de ses instructions \u00e9l\u00e9mentaires, de l'IDE (Integrated Development Environment) Eclipse qui sert \u00e0 construire les projets Java.</p> <p>Le chapitre 3 demande d'impl\u00e9menter la solution du TD en Java avec des classes. L'objectif est de pr\u00e9senter les notions de classes, d'h\u00e9ritage, d'interfaces et de classes g\u00e9n\u00e9riques. La notion de test unitaire JUnit est introduite.</p> <p>Le chapitre 4 introduit les concepts qui sous-tendent les chapitres suivants\u00a0:</p> <ul> <li>les architectures en couches\u00a0;</li> <li>la programmation par interfaces\u00a0;</li> <li>l'utilisation de Spring pour impl\u00e9menter les deux pr\u00e9c\u00e9dents concepts\u00a0;</li> </ul> <p></p> <p>Le chapitre 5 pr\u00e9sente le framework Spring avec quatre projets.</p> <p>Le chapitre 6 pr\u00e9sente l'API JDBC qui est une interface d'acc\u00e8s aux bases de donn\u00e9es.</p> <p>Le chapitre 7 impl\u00e9mente la couche [DAO] (Data Access Object) du TD avec l'API JDBC et Spring.</p> <p></p> <p>Le chapitre 8 impl\u00e9mente la couche [m\u00e9tier] du TD\u00a0:</p> <p></p> <p>Le chapitre 9 impl\u00e9mente la couche [ui] du TD avec une application console\u00a0:</p> <p></p> <p>Le chapitre 10 impl\u00e9mente la couche [ui] du TD avec une application graphique utilisant la biblioth\u00e8que de composants Swing\u00a0:</p> <p></p> <p></p> <p>Le chapitre 11 pr\u00e9sente la gestion des bases de donn\u00e9es avec le framework [Spring Data], une branche de l'\u00e9cosyst\u00e8me Spring. Elle introduit la sp\u00e9cification JPA (Java Persistence API) qui permet \u00e0 la couche [DAO] de manipuler des objets au lieu de manipuler du SQL (Structured Query Language). L'architecture en couches \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <p></p> <p>Le chapitre 12 applique le chapitre 11 en impl\u00e9mentant l'acc\u00e8s \u00e0 la base de donn\u00e9es du TD avec [Spring Data].</p> <p>Le chapitre 13 montre comment exposer une base de donn\u00e9es sur le web avec [Spring MVC] qui est une autre branche de l'\u00e9cosyst\u00e8me Spring. L'architecture \u00e9volue en architecture client / serveur\u00a0:</p> <p></p> <p>Les chapitres 14 et 15 transforment l'application du TD en application client / serveur\u00a0:</p> <p></p> <p>Le chapitre 16 montre comment s\u00e9curiser l'acc\u00e8s \u00e0 une application web avec [Spring Security] une autre branche de l'\u00e9cosyst\u00e8me Spring.</p> <p></p> <p>Le chapitre 17 reprend le TD et s\u00e9curise le service web des \u00e9lections.</p> <p>Le chapitre 18 aborde le probl\u00e8me des requ\u00eates inter-domaines\u00a0:</p> <ul> <li>en [1], une application web d\u00e9livre des pages HTML / Javascript\u00a0;</li> <li>en [2], le navigateur ex\u00e9cute le Javascript embarqu\u00e9 dans les pages HTML pour interroger le service web s\u00e9curis\u00e9 [3-4]\u00a0; Soit D1=http://machine1:port1 le domaine du serveur [1] et D4=http://machine4:port4 le domaine du serveur [4]. Si les serveurs [1] et [4] ne sont pas dans le m\u00eame domaine [D1!=D4], alors les requ\u00eates de [3] vers [4] sont appel\u00e9es des requ\u00eates inter-domaines. A cause de restrictions de s\u00e9curit\u00e9 mises en oeuvre par les navigateurs, leur mise en place peut \u00eatre probl\u00e9matique. Nous examinerons une solution.</li> </ul> <p>Le chapitre 19 met en oeuvre les requ\u00eates inter-domaines avec l'application des \u00e9lections.</p>"},{"location":"introduction.html#13-les-outils-utilises","title":"1.3. Les outils utilis\u00e9s","text":"<p>Les exemples qui suivent ont \u00e9t\u00e9 test\u00e9s dans l'environnement suivant\u00a0:</p> <ul> <li>machine Windows 10 pro 64 bits\u00a0;</li> <li>JDK 1.8 (page 409)\u00a0;</li> <li>IDE Spring Tool Suite 3.6.3 (page 410)\u00a0;</li> <li>Netbeans 8.1 (page 421)\u00a0;</li> <li>navigateur Chrome (les autres navigateurs n'ont pas \u00e9t\u00e9 utilis\u00e9s)\u00a0;</li> <li>extension Chrome [Advanced Rest Client] (page 422)\u00a0;</li> <li>WampServer qui am\u00e8ne le SGBD MySQL et l'outil [PhpMyAdmin] pour le g\u00e9rer (page 424)\u00a0; Il est important d'utiliser un JDK 1.8. Certains exemples utilisent des \u00e9l\u00e9ments de ce JDK. La plupart des exemples sont des projets Maven qui peuvent \u00eatre ouverts indiff\u00e9remment par les IDE Eclipse [https://www.eclipse.org/], IntellijIDEA Community Edition [https://www.jetbrains.com/idea/download/] et Netbeans [https://netbeans.org/]. Dans la suite, les copies d'\u00e9cran proviennent de l'IDE Spring Tool Suite, une variante d'Eclipse.</li> </ul>"},{"location":"introduction.html#14-le-support","title":"1.4. Le support","text":"<p>Les projets Eclipse de ce document sont disponibles sur le site [https://tahe.developpez.com/tutoriels-cours/intro-java-spring/serge-tahe-introduction-au-langage-java-et-a-l-ecosysteme-spring/].</p> <p>Pour importer les projets d'un chapitre, proc\u00e9dez avec Eclipse comme indiqu\u00e9 en [1-8]\u00a0:</p> <p>La plupart des projets sont des projets Maven. Si apr\u00e8s chargement, ceux-ci pr\u00e9sentent des erreurs, faites [Alt-F5] et suivez la proc\u00e9dure [9-10]. Les projets Maven s\u00e9lectionn\u00e9s vont \u00eatre reconstruits.</p>"},{"location":"programmation-asynchrone-avec-rxjava.html","title":"20. Programmation asynchrone avec RxJava","text":"<p>Document \u00e0 lire\u00a0: [Introduction \u00e0 RxJava. Application aux environnements Swing et Android.]</p> <p>Dans ce chapitre, nous revenons sur le chapitre 17.6, page 343 o\u00f9 nous avions construit une application client / serveur avec l'architecture suivante\u00a0:</p> <p>Certaines actions de l'utilisateur sur l'interface Swing en [1] d\u00e9clenchent des actions jusque dans la base de donn\u00e9es en [3] au-travers d'un r\u00e9seau HTTP [2]. A cause de celui-ci, la r\u00e9ponse \u00e0 l'action de l'utilisateur peut \u00eatre plus ou moins longue \u00e0 venir. Ce serait bien de pouvoir mettre un indicateur d'attente sur l'interface utilisateur avec une option d'annulation de l'op\u00e9ration lanc\u00e9e si celle-ci venait \u00e0 \u00eatre trop longue. Dans le chapitre 17.6, page 343, chaque action de l'utilisateur n\u00e9cessitant d'\u00e9changer des informations avec le serveur est synchrone. Le gestionnaire d'\u00e9v\u00e9nement ex\u00e9cut\u00e9 par le code n'est termin\u00e9 que lorsque la r\u00e9ponse est re\u00e7ue. Pendant tout ce temps, l'interface graphique est gel\u00e9e\u00a0: elle ne r\u00e9pond pas aux nouvelles actions de l'utilisateur. Celles-ci sont simplement mises en file d'attente pour \u00eatre trait\u00e9es lorsque le gestionnaire d'\u00e9v\u00e9nement qui s'ex\u00e9cute actuellement soit termin\u00e9. Ainsi, si on faisait appara\u00eetre un bouton d'annulation, l'utilisateur pourrait cliquer dessus mais il ne se passerait rien tant que l'op\u00e9ration en cours ne serait pas termin\u00e9e. Le bouton d'annulation n'aurait alors aucun int\u00e9r\u00eat.</p> <p>Pour que le clic sur le bouton d'annulation soit suivi d'effet, il faut que l'op\u00e9ration en cours soit termin\u00e9e. Pour cela, elle doit lancer l'op\u00e9ration potentiellement longue de fa\u00e7on asynchrone\u00a0: </p> <ul> <li>le gestionnaire d'\u00e9v\u00e9nement lance l'op\u00e9ration longue mais n'attend pas son r\u00e9sultat et rend la main au thread de l'UI qui g\u00e8re les \u00e9v\u00e9nements de l'interface graphique. L'op\u00e9ration longue est lanc\u00e9e sur un thread diff\u00e9rent de celui de l'UI ce qui ne bloque pas ce dernier\u00a0;</li> <li>si l'utilisateur clique sur le bouton d'annulation avant la fin de l'op\u00e9ration longue, le thread de l'UI qui est inoccup\u00e9 peut traiter cet \u00e9v\u00e9nement. On peut alors abandonner l'op\u00e9ration longue en ignorant son r\u00e9sultat\u00a0;</li> <li>si l'op\u00e9ration longue n'a pas \u00e9t\u00e9 annul\u00e9e, l'arriv\u00e9e de la r\u00e9ponse va provoquer un \u00e9v\u00e9nement dans le thread de l'UI. Celui-ci, s'il est inoccup\u00e9, va alors ex\u00e9cuter le code li\u00e9 \u00e0 cet \u00e9v\u00e9nement qui va exploiter la r\u00e9ponse\u00a0; L'interface utilisateur va fonctionner comme pr\u00e9c\u00e9demment. Si les temps de r\u00e9ponse du serveur sont rapides, l'utilisateur ne verra pas la diff\u00e9rence. S'ils sont perceptibles, l'utilisateur verra un bouton d'annulation appara\u00eetre et aura la possibilt\u00e9 d'interrompre l'op\u00e9ration en cours.</li> </ul> <p>La biblioth\u00e8que [Rx] permet de faire de la programmation asynchrone. Son grand int\u00e9r\u00eat r\u00e9side dans le fait qu'elle a \u00e9t\u00e9 port\u00e9e dans de nombreux environnements (Java, .NET, JS, ...) et que sa ma\u00eetrise dans un environnement peut \u00eatre transpos\u00e9e facilement dans un autre environnement. Nous allons nous appuyer ici sur le chapitre 2 du document [Introduction \u00e0 RxJava. Application aux environnements Swing et Android]. Le lecteur est invit\u00e9 \u00e0 le lire. Dans la suite, nous reprenons du code issu des exemples de ce chapitre.</p> <p>Nous allons faire \u00e9voluer l'architecture de l'application de la fa\u00e7on suivante\u00a0:</p> <ul> <li> <p>en [1], nous intercalons une couche [RxJava] entre la couche [swing] et la couche [m\u00e9tier]. Les m\u00e9thodes de celle-ci vont d\u00e9sormais \u00eatre appel\u00e9es de fa\u00e7on asynchrone\u00a0; Nous allons proc\u00e9der en plusieurs \u00e9tapes\u00a0:</p> </li> <li> <p>\u00e9tape 1\u00a0: la couche [metier, DAO] pr\u00e9sente pour l'instant une interface synchrone \u00e0 la couche [ui]. Nous allons la transformer en une couche asynchrone [RxJava, metier, DAO]\u00a0;</p> </li> <li>\u00e9tape 2\u00a0: nous porterons l'application console synchrone en une application toujours synchrone mais utilisant l'interface asynchrone [RxJava, metier, DAO]\u00a0;</li> <li>\u00e9tape 3\u00a0: nous porterons l'application swing synchrone en une application swing asynchrone\u00a0;</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#201-etape-1","title":"20.1. \u00e9tape 1","text":"<p>Nous transformons la couche synchrone actuelle [metier, DAO] en une couche asynchrone [RxJava, metier, DAO].</p>"},{"location":"programmation-asynchrone-avec-rxjava.html#2011-creation","title":"20.1.1. Cr\u00e9ation","text":"<p>Nous partons du projet Maven du chapitre 17.4, page 333 que nous ouvrons avec Netbeans\u00a0:</p> <p>Nous dupliquons ce projet [1] (copy / paste) dans un nouveau projet [elections-rxjava-metier-dao-security-webjson] [2].</p>"},{"location":"programmation-asynchrone-avec-rxjava.html#2012-configuration-maven","title":"20.1.2. Configuration Maven","text":"<p>Nous faisons \u00e9voluer le fichier [pom.xml] du nouveau projet pour ajouter la d\u00e9pendance sur la biblioth\u00e8que [RxJava]\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n  &lt;artifactId&gt;elections-metier-dao-security-rxjava-webjson&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n  &lt;description&gt;Client jUnit du serveur web / jSON&lt;/description&gt;\n  &lt;name&gt;elections-metier-dao-security-rxjava-webjson&lt;/name&gt;\n\n  &lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;java.version&gt;1.8&lt;/java.version&gt;\n  &lt;/properties&gt;\n\n  &lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n    &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n  &lt;/parent&gt;\n\n  &lt;dependencies&gt;\n    &lt;!-- Spring --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- librairie jSON utilis\u00e9e par Spring --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- composant utilis\u00e9 par Spring RestTemplate --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n      &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Google Guava --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n      &lt;artifactId&gt;guava&lt;/artifactId&gt;\n      &lt;version&gt;16.0.1&lt;/version&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;!-- biblioth\u00e8que de logs --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Spring Boot Test --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;!-- Spring Boot --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n      &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/io.reactivex/rxjava --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.reactivex&lt;/groupId&gt;\n      &lt;artifactId&gt;rxjava&lt;/artifactId&gt;\n      &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;/dependency&gt;\n\n  &lt;/dependencies&gt;\n\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n        &lt;version&gt;2.18.1&lt;/version&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 65-70\u00a0: nous avons ajout\u00e9 la d\u00e9pendance sur la biblioth\u00e8que RxJava\u00a0;</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#2013-implementation-asynchrone-de-la-couche-metier","title":"20.1.3. Impl\u00e9mentation asynchrone de la couche [m\u00e9tier]","text":"<p>Pour impl\u00e9menter la couche [RxJava, m\u00e9tier], nous ajoutons une interface asynchrone [IRxElectionsMetier] [1] et son impl\u00e9mentation [RxElectionsMetier] [2] au projet\u00a0:</p> <p>L'interface [IRxElectionsMetier] est l'interface asynchrone de la couche [RxJava, m\u00e9tier]. Son code est le suivant\u00a0:</p> <pre><code>package elections.security.client.metier;\n\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport rx.Observable;\n\npublic interface IRxElectionsMetier {\n\n  // authentification\n  Observable&lt;Void&gt; authenticate(User user);\n\n  // obtenir les listes en comp\u00e9tition\n  Observable&lt;ListeElectorale[]&gt; getListesElectorales(User user);\n\n  // le nombre de si\u00e8ges \u00e0 pourvoir\n  Observable&lt;Integer&gt; getNbSiegesAPourvoir(User user);\n\n  // le seuil \u00e9lectoral\n  Observable&lt;Double&gt; getSeuilElectoral(User user);\n\n  // l'enregistrement des r\u00e9sultats\n  Observable&lt;Void&gt; recordResultats(User user, ListeElectorale[] listesElectorales);\n\n  // le calcul des si\u00e8ges\n  Observable&lt;ListeElectorale[]&gt; calculerSieges(User user, ListeElectorale[] listesElectorales);\n\n}\n</code></pre> <p>L'interface [IRxElectionsMetier] reprend les m\u00e9thodes de l'interface [IElectionsMetier] mais l\u00e0 o\u00f9 une m\u00e9thode M de l'interface [IElectionsMetier] rendait un r\u00e9sultat de type T, la m\u00e9thode M de l'interface [IRxElectionsMetier] rend un r\u00e9sultat de type Observable&lt;T&gt;. Le type [Observable] est fourni par la biblioth\u00e8que RxJava. Un type Observable&lt;T&gt; fournit la m\u00e9thode [subscribe] qui va obtenir le type T de fa\u00e7on asynchrone. Sont associ\u00e9s \u00e0 cette m\u00e9thode trois \u00e9v\u00e9nements\u00a0:</p> <ul> <li>onSuccess(T result) qui avertit qu'un r\u00e9sultat de type T est disponible. L'op\u00e9ration asynchrone peut fournir plusieurs r\u00e9sultats\u00a0;</li> <li>onError(Throwable th) qui avertit que l'op\u00e9ration asynchrone a rencontr\u00e9 une erreur\u00a0;</li> <li>onCompleted() qui avertit que l'op\u00e9ration asynchrone est termin\u00e9e\u00a0; Tant que la m\u00e9thode [Observable.subscribe] n'est pas appel\u00e9e, l'op\u00e9ration asynchrone li\u00e9e \u00e0 l'observable n'est pas lanc\u00e9e. Le code qui appelle une m\u00e9thode M de l'interface [IRxElectionsMetier] n'obtient pas le r\u00e9sultat T attendu, mais un type Observable&lt;T&gt; qui lui permettra ult\u00e9rieurement d'obtenir le r\u00e9sultat T en appelant la m\u00e9thode [Observable.subscribe].</li> </ul> <p>L'impl\u00e9mentation [RxElectionsMetier] de l'interface [IRxElectionsMetier] est la suivante\u00a0:</p> <pre><code>package elections.security.client.metier;\n\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport rx.Observable;\n\n@Component\npublic class RxElectionsMetier implements IRxElectionsMetier {\n\n  @Autowired\n  private IElectionsMetier metier;\n\n  @Override\n  public Observable&lt;Void&gt; authenticate(User user) {\n    ...\n  }\n\n  @Override\n  public Observable&lt;ListeElectorale[]&gt; getListesElectorales(User user) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone puis r\u00e9ponse au souscripteur\n        subscriber.onNext(metier.getListesElectorales(user));\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n  }\n\n  @Override\n  public Observable&lt;Integer&gt; getNbSiegesAPourvoir(User user) {\n    ...\n  }\n\n  @Override\n  public Observable&lt;Double&gt; getSeuilElectoral(User user) {\n    ...\n  }\n\n  @Override\n  public Observable&lt;Void&gt; recordResultats(User user, ListeElectorale[] listesElectorales) {\n    ...\n  }\n\n  @Override\n  public Observable&lt;ListeElectorale[]&gt; calculerSieges(User user, ListeElectorale[] listesElectorales) {\n    ...\n  }\n}\n</code></pre> <ul> <li>lignes 12-13\u00a0: injection Spring de la couche m\u00e9tier synchrone\u00a0;</li> <li>lignes 20-34\u00a0: nous allons commenter la m\u00e9thode [getListesElectorales] qui au lieu de rendre un type [ListeElectorale[]] rend un type [Observable&lt;ListeElectorale[]&gt;]\u00a0;</li> <li>lignes 22-32\u00a0: la m\u00e9thode statique [Observable.create] permet de cr\u00e9er un Observable \u00e0 partir d'un type [Subscriber]. Le type [Subscriber] repr\u00e9sente un abonn\u00e9 aux flux de r\u00e9sultats produits par le processus observ\u00e9 (l'Observable). Il fournit trois m\u00e9thodes\u00a0:</li> <li>[Subscriber.onNext] (ligne 25) pour recevoir un r\u00e9sultat du processus observ\u00e9\u00a0;</li> <li>[Subscriber.onError] (ligne 30) pour recevoir une exception du processus observ\u00e9. Apr\u00e8s une exception, le type [Observable] n'\u00e9met plus de r\u00e9sultats\u00a0;</li> <li>[Subscriber.onCompleted] (ligne 27) pour recevoir le signal de fin d'\u00e9mission du processus observ\u00e9. Ici, le processus observ\u00e9 n'\u00e9met qu'un \u00e9l\u00e9ment. On remarquera ici que ce signal n'est pas \u00e9mis s'il se produit une exception. C'est le comportement par d\u00e9faut des Observables\u00a0: l'\u00e9mission d'une exception signale \u00e9galement la fin des \u00e9missions. Les souscripteurs le savent\u00a0;</li> <li>lignes 22-34\u00a0: la m\u00e9thode [Observable.create] admet pour param\u00e8tre un type [Observable.OnSubscribe]. Ce type est une interface fonctionnelle. Cette notion a \u00e9t\u00e9 introduite avec Java 8 et d\u00e9signe une interface ayant une unique m\u00e9thode. Ici, la m\u00e9thode unique de l'interface [Observable.OnSubscribe] est la suivante\u00a0: <pre><code>T call(Subscriber&lt;T&gt; subscriber)\n</code></pre></li> </ul> <p>Pour impl\u00e9menter une interface fonctionnelle de m\u00e9thode unique m(param1, param2, ..., paramn), on peut utiliser la syntaxe simplifi\u00e9e suivante\u00a0:</p> <pre><code>(param1, param2, ..., paramn) -&gt; { code de la m\u00e9thode m}\n</code></pre> <p>C'est ce qui est fait aux lignes 22-34\u00a0:</p> <ul> <li>[subscriber] est le param\u00e8tre de la m\u00e9thode [Observable.OnSubscribe.call]\u00a0;</li> <li>lignes 23-32\u00a0: le code qu'on veut donner \u00e0 la m\u00e9thode [call]\u00a0;</li> <li>ligne 25\u00a0: on demande les listes \u00e9lectorales de fa\u00e7on synchrone \u00e0 la couche [m\u00e9tier] inject\u00e9e en ligne 13. Il va donc y avoir attente du r\u00e9sultat. Lorsque celui-ci va \u00eatre re\u00e7u, il est pass\u00e9 \u00e0 la m\u00e9thode [onNext] du souscripteur\u00a0;</li> <li>ligne 28\u00a0: en cas d'erreur, l'exception est pass\u00e9e \u00e0 la m\u00e9thode [onError] du souscripteur\u00a0;</li> <li>ligne 31\u00a0: on n'attend qu'un r\u00e9sultat. Lorsque celui-ci a \u00e9t\u00e9 obtenu (les listes \u00e9lectorales ou une exception), on indique au souscripteur que le processus observ\u00e9 a termin\u00e9 d'\u00e9mettre des r\u00e9sultats\u00a0; On se rappellera bien que la m\u00e9thode [RxElectionsMetier] rend un type Observable&lt;ListeElectorale[]&gt; et non le type ListeElectorale[] lui-m\u00eame. Il faudra que le code appelant appelle la m\u00e9thode Observable&lt;ListeElectorale[]&gt;.subscribe pour que le code des lignes 23-33 soit ex\u00e9cut\u00e9 et rende les listes \u00e9lectorales au moyen de la ligne 25.</li> </ul> <p>Le code des autres m\u00e9thodes est analogue\u00a0:</p> <pre><code>package elections.security.client.metier;\n\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport rx.Observable;\n\n@Component\npublic class RxElectionsMetier implements IRxElectionsMetier {\n\n  @Autowired\n  private IElectionsMetier metier;\n\n  @Override\n  public Observable&lt;Void&gt; authenticate(User user) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone\n        metier.authenticate(user);\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n\n  }\n\n  @Override\n  public Observable&lt;ListeElectorale[]&gt; getListesElectorales(User user) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone puis r\u00e9ponse au souscripteur\n        subscriber.onNext(metier.getListesElectorales(user));\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n  }\n\n  @Override\n  public Observable&lt;Integer&gt; getNbSiegesAPourvoir(User user) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone puis r\u00e9ponse au souscripteur\n        subscriber.onNext(metier.getNbSiegesAPourvoir(user));\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n  }\n\n  @Override\n  public Observable&lt;Double&gt; getSeuilElectoral(User user) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone puis r\u00e9ponse au souscripteur\n        subscriber.onNext(metier.getSeuilElectoral(user));\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n  }\n\n  @Override\n  public Observable&lt;Void&gt; recordResultats(User user, ListeElectorale[] listesElectorales) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone\n        metier.recordResultats(user, listesElectorales);\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n  }\n\n  @Override\n  public Observable&lt;ListeElectorale[]&gt; calculerSieges(User user, ListeElectorale[] listesElectorales) {\n    return Observable.create(subscriber -&gt; {\n      try {\n        // appel m\u00e9thode synchrone puis r\u00e9ponse au souscripteur\n        subscriber.onNext(metier.calculerSieges(user, listesElectorales));\n        // on signale la fin de l'observable\n        subscriber.onCompleted();\n      } catch (Exception e) {\n        // on fait suivre l'exception\n        subscriber.onError(e);\n      }\n    });\n  }\n}\n</code></pre> <ul> <li>lignes 20 et 81\u00a0: la m\u00e9thode [onNext] du souscripteur n'est pas appel\u00e9e parce que celui-ci n'attend pas de r\u00e9sultats\u00a0;</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#2014-les-tests-junit-de-la-couche-metier","title":"20.1.4. Les tests JUnit de la couche [m\u00e9tier]","text":""},{"location":"programmation-asynchrone-avec-rxjava.html#20141-test01","title":"20.1.4.1. Test01","text":"<p>Nous reprenons le test unitaire [Test01] \u00e9tudi\u00e9 au paragraphe 17.4.4, page 337. Il a \u00e9t\u00e9 pr\u00e9vu pour faire des appels synchrones \u00e0 l'interface [IElectionsMetier]. Nous le modifions pour qu'il fasse des appels synchrones \u00e0 la nouvelle interface [IRxElectionsMetier]. Il est en effet possible de faire des appels synchrones \u00e0 une interface asynchrone RxJava. Le code devient le suivant\u00a0:</p> <pre><code>package elections.security.client.metier.junit;\n\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport elections.security.client.config.MetierConfig;\nimport elections.security.client.entities.ElectionsException;\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport elections.security.client.metier.IRxElectionsMetier;\nimport rx.observables.BlockingObservable;\n\n@SpringApplicationConfiguration(classes = MetierConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n  // couche [electionsMetier]\n  @Autowired\n  private IRxElectionsMetier electionsMetier;\n\n  // mappeur jSON\n  private final ObjectMapper mapper = new ObjectMapper();\n\n  // utilisateurs\n  static private User admin;\n  static private User user;\n  static private User unknown;\n\n  @BeforeClass\n  public static void initTest() {\n    admin = new User(\"admin\", \"admin\");\n    user = new User(\"user\", \"user\");\n    unknown = new User(\"x\", \"y\");\n  }\n\n  @Test()\n  public void checkUserUser() {\n    ElectionsException se = null;\n    try {\n      BlockingObservable.from(electionsMetier.authenticate(user)).firstOrDefault(null);\n    } catch (ElectionsException e) {\n      se = e;\n    }\n    Assert.assertNotNull(se);\n    Assert.assertEquals(\"403 Forbidden\", se.getErreurs().get(0));\n  }\n\n  @Test()\n  public void checkUserUnknown() {\n    ElectionsException se = null;\n    try {\n      BlockingObservable.from(electionsMetier.authenticate(unknown)).firstOrDefault(null);\n    } catch (ElectionsException e) {\n      se = e;\n    }\n    Assert.assertNotNull(se);\n    Assert.assertEquals(\"401 Unauthorized\", se.getErreurs().get(0));\n  }\n\n  @Test()\n  public void checkUserAdmin() {\n    ElectionsException se = null;\n    try {\n      BlockingObservable.from(electionsMetier.authenticate(admin)).firstOrDefault(null);\n    } catch (ElectionsException e) {\n      se = e;\n    }\n    Assert.assertNull(se);\n  }\n\n  /**\n   * v\u00e9rification 1 : m\u00e9thode de calcul des si\u00e8ges on fixe en dur les listes\n   */\n  @Test\n  public void calculSieges1() {\n    // on cr\u00e9e le tableau des 7 listes candidates\n    ListeElectorale[] listes = new ListeElectorale[7];\n    listes[0] = new ListeElectorale(\"A\", 32000, 0, false);\n    listes[1] = new ListeElectorale(\"B\", 25000, 0, false);\n    listes[2] = new ListeElectorale(\"C\", 16000, 0, false);\n    listes[3] = new ListeElectorale(\"D\", 12000, 0, false);\n    listes[4] = new ListeElectorale(\"E\", 8000, 0, false);\n    listes[5] = new ListeElectorale(\"F\", 4500, 0, false);\n    listes[6] = new ListeElectorale(\"G\", 2500, 0, false);\n    // on calcule les si\u00e8ges de chacune des listes\n    listes = BlockingObservable.from(electionsMetier.calculerSieges(admin, listes)).first();\n    // on v\u00e9rifie les r\u00e9sultats\n    Assert.assertEquals(2, listes[0].getSieges());\n    Assert.assertFalse(listes[0].isElimine());\n    Assert.assertEquals(2, listes[1].getSieges());\n    Assert.assertFalse(listes[1].isElimine());\n    Assert.assertEquals(1, listes[2].getSieges());\n    Assert.assertFalse(listes[2].isElimine());\n    Assert.assertEquals(1, listes[3].getSieges());\n    Assert.assertFalse(listes[3].isElimine());\n    Assert.assertEquals(0, listes[4].getSieges());\n    Assert.assertFalse(listes[4].isElimine());\n    Assert.assertEquals(0, listes[5].getSieges());\n    Assert.assertTrue(listes[5].isElimine());\n    Assert.assertEquals(0, listes[6].getSieges());\n    Assert.assertTrue(listes[6].isElimine());\n  }\n\n  /**\n   * v\u00e9rification 2 : m\u00e9thode de calcul des si\u00e8ges on demande les listes \u00e0 la couche [metier] puis on fixe en dur les\n   * voix\n   */\n  @Test\n  public void calculSieges2() {\n    // on cr\u00e9e le tableau des 7 listes candidates\n    ListeElectorale[] listes = BlockingObservable.from(electionsMetier.getListesElectorales(admin)).first();\n    // on fixe en dur les voix\n    listes[0].setVoix(32000);\n    listes[1].setVoix(25000);\n    listes[2].setVoix(16000);\n    listes[3].setVoix(12000);\n    listes[4].setVoix(8000);\n    listes[5].setVoix(4500);\n    listes[6].setVoix(2500);\n    // on calcule les si\u00e8ges obtenus par chacune des listes\n    listes = BlockingObservable.from(electionsMetier.calculerSieges(admin, listes)).first();\n    // on v\u00e9rifie les r\u00e9sultats\n    Assert.assertEquals(2, listes[0].getSieges());\n    Assert.assertFalse(listes[0].isElimine());\n    Assert.assertEquals(2, listes[1].getSieges());\n    Assert.assertFalse(listes[1].isElimine());\n    Assert.assertEquals(1, listes[2].getSieges());\n    Assert.assertFalse(listes[2].isElimine());\n    Assert.assertEquals(1, listes[3].getSieges());\n    Assert.assertFalse(listes[3].isElimine());\n    Assert.assertEquals(0, listes[4].getSieges());\n    Assert.assertFalse(listes[4].isElimine());\n    Assert.assertEquals(0, listes[5].getSieges());\n    Assert.assertTrue(listes[5].isElimine());\n    Assert.assertEquals(0, listes[6].getSieges());\n    Assert.assertTrue(listes[6].isElimine());\n  }\n\n  /**\n   * v\u00e9rification 3 m\u00e9thode de calcul des si\u00e8ges on provoque une exception\n   */\n  @Test(expected = ElectionsException.class)\n  public void calculSieges3() {\n    // on cr\u00e9e un tableau de 24 listes candidates avec chacune 1 voix\n    ListeElectorale[] listes = new ListeElectorale[25];\n    // les 25 listes auront le m\u00eame nombre de voix (4%)\n    for (int i = 0; i &lt; listes.length; i++) {\n      listes[i] = new ListeElectorale(\"Liste\" + (i + 1), 1, 0, false);\n    }\n    // calcul des si\u00e8ges - normalement on doit avoir une ElectionsException\n    // avec un seuil \u00e8lectoral de 5%\n    BlockingObservable.from(electionsMetier.calculerSieges(admin, listes)).first();\n  }\n\n  /**\n   * enregistrement des r\u00e9sultats de l'\u00e9lection\n   *\n   * @throws JsonProcessingException\n   */\n  @Test\n  public void ecritureResultatsElections() throws JsonProcessingException {\n    // on cr\u00e9e le tableau des 7 listes candidates\n    ListeElectorale[] listes = BlockingObservable.from(electionsMetier.getListesElectorales(admin)).first();\n    // on fixe en dur les voix\n    listes[0].setVoix(32000);\n    listes[1].setVoix(25000);\n    listes[2].setVoix(16000);\n    listes[3].setVoix(12000);\n    listes[4].setVoix(8000);\n    listes[5].setVoix(4500);\n    listes[6].setVoix(2500);\n    // on calcule les si\u00e8ges obtenus par chacune des listes\n    listes = BlockingObservable.from(electionsMetier.calculerSieges(admin, listes)).first();\n    // on affiche les r\u00e9sultats\n    for (int i = 0; i &lt; listes.length; i++) {\n      System.out.println(mapper.writeValueAsString(listes[i]));\n    }\n    // on enregistre les r\u00e9sultats dans la base de donn\u00e9es\n    BlockingObservable.from(electionsMetier.recordResultats(admin, listes)).firstOrDefault(null);\n    // on v\u00e9rifie les r\u00e9sultats\n    listes = BlockingObservable.from(electionsMetier.getListesElectorales(admin)).first();\n    // on affiche les r\u00e9sultats\n    for (int i = 0; i &lt; listes.length; i++) {\n      System.out.println(mapper.writeValueAsString(listes[i]));\n    }\n    Assert.assertEquals(2, listes[0].getSieges());\n    Assert.assertFalse(listes[0].isElimine());\n    Assert.assertEquals(2, listes[1].getSieges());\n    Assert.assertFalse(listes[1].isElimine());\n    Assert.assertEquals(1, listes[2].getSieges());\n    Assert.assertFalse(listes[2].isElimine());\n    Assert.assertEquals(1, listes[3].getSieges());\n    Assert.assertFalse(listes[3].isElimine());\n    Assert.assertEquals(0, listes[4].getSieges());\n    Assert.assertFalse(listes[4].isElimine());\n    Assert.assertEquals(0, listes[5].getSieges());\n    Assert.assertTrue(listes[5].isElimine());\n    Assert.assertEquals(0, listes[6].getSieges());\n    Assert.assertTrue(listes[6].isElimine());\n  }\n}\n</code></pre> <p>Etudions les modifications\u00a0:</p> <ul> <li>ligne 48\u00a0: la m\u00e9thode statique [BlockingObservable.from(Observable).first]\u00a0:</li> <li>s'abonne \u00e0 l'observable param\u00e8tre de [from]\u00a0;</li> <li>lance l'ex\u00e9cution du code associ\u00e9 \u00e0 l'observable\u00a0;</li> <li>attend de recevoir le 1er r\u00e9sultat. C'est donc une op\u00e9ration synchrone\u00a0; Nous utilisons ici la m\u00e9thode [firstOrDefault(null)] parce que l'observable [metier.authenticate] ne rend pas de r\u00e9sultat lorsqu'il est ex\u00e9cut\u00e9. Le r\u00e9sultat de la m\u00e9thode [firstOrDefault(null)] sera donc null, valeur inexploit\u00e9e ici\u00a0;</li> </ul> <p>Nous reprenons ce sch\u00e9ma dans le reste du code \u00e0 chaque fois que nous voulons faire appel \u00e0 la couche [m\u00e9tier].</p> <p>Le test unitaire [Test01] doit passer\u00a0:</p> <p>Travail \u00e0 faire\u00a0: v\u00e9rifier que le test [Test01] passe.</p>"},{"location":"programmation-asynchrone-avec-rxjava.html#20142-test02","title":"20.1.4.2. Test02","text":"<p>Nous transformons le test [Test01] afin de tester d\u00e9sormais l'interface asynchrone [IRxElectionsMetier] en faisant des appels asynchrones \u00e0 ses m\u00e9thodes.</p> <p>Etudions un premier test\u00a0:</p> <pre><code>  // s\u00e9maphore de synchronisation de threads\n  private CountDownLatch latch;\n\n  // -----------------------------------\n  private ElectionsException checkUserUserException;\n\n  @Test()\n  public void checkUserUser() throws InterruptedException {\n    // s\u00e9maphore \u00e0 1\n    latch = new CountDownLatch((1));\n    // op\u00e9ration asynchrone\n    electionsMetier.authenticate(user).subscribeOn(Schedulers.io())\n            .subscribe((result) -&gt; {\n            },\n                    (th) -&gt; {\n                      checkUserUserException = (ElectionsException) th;\n                      latch.countDown();\n                    },\n                    () -&gt; {\n                      latch.countDown();\n                    });\n    // attente s\u00e9maphore\n    latch.await();\n    // v\u00e9rification r\u00e9sultats\n    Assert.assertNotNull(checkUserUserException);\n    Assert.assertEquals(\"403 Forbidden\", checkUserUserException.getErreurs().get(0));\n}\n</code></pre> <ul> <li>ligne 2\u00a0: un s\u00e9maphore est un outil utilis\u00e9 pour synchroniser des threads entre eux. Des threads sont des flux d'ex\u00e9cution s'ex\u00e9cutant en parall\u00e8le. Pour ex\u00e9cuter une t\u00e2che T1, le thread [Thread1] peut avoir besoin qu'une t\u00e2che T2 ex\u00e9cut\u00e9e par un thread [Thread2] soit termin\u00e9e. Il attend alors que le thread [Thread2] lui envoie un signal indiquant que la t\u00e2che T2 est termin\u00e9e. Il y a diverses fa\u00e7ons de g\u00e9rer cette synchronisation entre deux threads. La m\u00e9thode utilis\u00e9e ici est la suivante\u00a0;</li> <li>ligne 10\u00a0: le thread [Thread1] cr\u00e9e un s\u00e9maphore avec la valeur 1\u00a0;</li> <li>ligne 12\u00a0: le thread [Thread1] cr\u00e9e et lance un thread [Thread2]. Ceci est obtenu par la syntaxe\u00a0: <pre><code>electionsMetier.authenticate(user).subscribeOn(Schedulers.io())\n</code></pre></li> </ul> <p>La m\u00e9thode [Observable.subscribeOn] fixe le thread sur lequel s'ex\u00e9cutera le processus observ\u00e9. Le param\u00e8tre de [subscribeOn] est un pool de threads. La biblioth\u00e8que RxJava en fournit plusieurs adapt\u00e9s \u00e0 diff\u00e9rentes situations. Le pool [Schedulers.io()] est celui qui est conseill\u00e9 pour les op\u00e9rations r\u00e9seau\u00a0;</p> <ul> <li>lignes 12-13\u00a0: l'op\u00e9ration  <pre><code>electionsMetier.authenticate(user).subscribeOn(Schedulers.io()).subscribe(...)\n</code></pre></li> </ul> <p>ex\u00e9cute l'op\u00e9ration synchrone encapsul\u00e9e dans l'observable [authenticate(user)]. Mais parce que cette op\u00e9ration synchrone est lanc\u00e9e sur un autre thread que le thread [Thread1], ce dernier n'attend pas la r\u00e9ponse de la m\u00e9thode [subscribe] et passe \u00e0 l'instruction suivante\u00a0;</p> <ul> <li>ligne 23\u00a0: le thread [Thread1] s'arr\u00eate et attend que le s\u00e9maphore passe \u00e0 0 (il est \u00e0 1 pour l'instant)\u00a0;</li> <li>lignes 13-21\u00a0: la m\u00e9thode [subscribe] admet comme param\u00e8tres trois fonctions lambda\u00a0:</li> <li>la premi\u00e8re [(result)-&gt;{...}] est appel\u00e9e \u00e0 chaque fois que l'observable [authenticate(user)] \u00e9met un r\u00e9sultat [result]. Ici nous avons un observable [authenticate(user)] qui fait quelque chose mais n'\u00e9met aucun r\u00e9sultat. Le lambda [(result)-&gt;{}] ne sera donc jamais appel\u00e9. C'est pourquoi son code est ici vide [{}]\u00a0;</li> <li>la seconde [(th)-&gt;{...}] re\u00e7oit comme param\u00e8tre un type [Throwable]. Elle est appel\u00e9e lorsque l'ex\u00e9cution de l'observable rencontre une exception. Ici, nous traitons le param\u00e8tre [Throwable th] de la fa\u00e7on suivante\u00a0:</li> <li>ligne 16\u00a0: nous le m\u00e9morisons dans un champ de la classe de test de type [ElectionsException] car l'observable ex\u00e9cut\u00e9 n'\u00e9met que ce type d'exception\u00a0;</li> <li>ligne 17\u00a0: nous passons le s\u00e9maphore \u00e0 0 pour indiquer que le thread [Thread2] a termin\u00e9 son travail\u00a0;</li> <li>la troisi\u00e8me [()-&gt;{...}] est appel\u00e9e lorsque l'observable n'a plus d'\u00e9l\u00e9ments \u00e0 \u00e9mettre. Nous traitons cet \u00e9v\u00e9nement de la fa\u00e7on suivante\u00a0:</li> <li> <p>ligne 20\u00a0: nous passons le s\u00e9maphore \u00e0 0 pour indiquer que le thread [Thread2] a termin\u00e9 son travail\u00a0; Il faut noter que le troisi\u00e8me lambda n'est pas appel\u00e9 si une exception se produit. C'est pourquoi, on a \u00e9t\u00e9 oblig\u00e9 de mettre le s\u00e9maphore \u00e0 0 \u00e9galement ligne 17\u00a0;</p> </li> <li> <p>ligne 25\u00a0: lorsqu'on arrive \u00e0 cette ligne, l'observable a termin\u00e9 son travail. On peut alors faire les m\u00eames v\u00e9rifications que dans le test [Test01]\u00a0; Examinons un autre test\u00a0:</p> </li> </ul> <pre><code>// -----------------------------------\n  private ElectionsException calculSieges1Exception;\n  private ListeElectorale[] listesCalculSieges1;\n\n  @Test\n  public void calculSieges1() throws InterruptedException {\n    // on cr\u00e9e le tableau des 7 listes candidates\n    ListeElectorale[] listes = new ListeElectorale[7];\n    listes[0] = new ListeElectorale(\"A\", 32000, 0, false);\n    listes[1] = new ListeElectorale(\"B\", 25000, 0, false);\n    listes[2] = new ListeElectorale(\"C\", 16000, 0, false);\n    listes[3] = new ListeElectorale(\"D\", 12000, 0, false);\n    listes[4] = new ListeElectorale(\"E\", 8000, 0, false);\n    listes[5] = new ListeElectorale(\"F\", 4500, 0, false);\n    listes[6] = new ListeElectorale(\"G\", 2500, 0, false);\n    // s\u00e9maphore \u00e0 1\n    latch = new CountDownLatch((1));\n    // op\u00e9ration asynchrone    \n    // on calcule les si\u00e8ges de chacune des listes\n    electionsMetier.calculerSieges(admin, listes).subscribeOn(Schedulers.io())\n            .subscribe((result) -&gt; {\n              listesCalculSieges1 = result;\n            },\n                    (th) -&gt; {\n                      calculSieges1Exception = (ElectionsException) th;\n                      latch.countDown();\n                    },\n                    () -&gt; {\n                      latch.countDown();\n                    });\n    // attente s\u00e9maphore\n    latch.await();\n    // on v\u00e9rifie les r\u00e9sultats\n    Assert.assertNull(calculSieges1Exception);\n    Assert.assertEquals(2, listesCalculSieges1[0].getSieges());\n    Assert.assertFalse(listesCalculSieges1[0].isElimine());\n    Assert.assertEquals(2, listesCalculSieges1[1].getSieges());\n    Assert.assertFalse(listesCalculSieges1[1].isElimine());\n    Assert.assertEquals(1, listesCalculSieges1[2].getSieges());\n    Assert.assertFalse(listesCalculSieges1[2].isElimine());\n    Assert.assertEquals(1, listesCalculSieges1[3].getSieges());\n    Assert.assertFalse(listesCalculSieges1[3].isElimine());\n    Assert.assertEquals(0, listesCalculSieges1[4].getSieges());\n    Assert.assertFalse(listesCalculSieges1[4].isElimine());\n    Assert.assertEquals(0, listesCalculSieges1[5].getSieges());\n    Assert.assertTrue(listesCalculSieges1[5].isElimine());\n    Assert.assertEquals(0, listesCalculSieges1[6].getSieges());\n    Assert.assertTrue(listesCalculSieges1[6].isElimine());\n  }\n</code></pre> <ul> <li>lignes 20-30\u00a0: ex\u00e9cution asynchrone de l'observable [electionsMetier.calculerSieges(admin, listes)]\u00a0;</li> <li>lignes 21-23\u00a0: l'ex\u00e9cution de l'observable rend un type [ListeElectorale[]] qu'on m\u00e9morise dans un champ de la classe de test, ligne 3\u00a0;</li> <li>lignes 34-48\u00a0: ces v\u00e9rifications sont celles du test [Test01] auxquelles on a ajout\u00e9 la v\u00e9rification de la ligne 34 qui s'assure qu'il n'y a pas eu d'exception\u00a0; L'ensemble du test [Test02] est disponible dans le support de cours.</li> </ul> <p>Travail \u00e0 faire\u00a0: passer le test [Test02] et v\u00e9rifier qu'il passe.</p>"},{"location":"programmation-asynchrone-avec-rxjava.html#20143-test03","title":"20.1.4.3. Test03","text":"<p>Le test [Test03] fait la m\u00eame chose que le test [Test01]\u00a0: il teste l'interface [IRxElectionsMetier] par des appels synchrones \u00e0 cette interface. C'est une copie du test [Test02] \u00e0 deux d\u00e9tails pr\u00e8s\u00a0:</p> <ul> <li>les observables ne sont plus ex\u00e9cut\u00e9s dans un thread diff\u00e9rent de celui qui ex\u00e9cute les tests. Lorsque le thread [Thread1] ex\u00e9cute la m\u00e9thode [subscribe] d'un observable, celle-ci d\u00e9marre une op\u00e9ration HTTP vers le serveur \u00e9galement sur le thread [Thread1]. Toute la m\u00e9thode [subscribe] devient alors synchrone\u00a0;</li> <li>puisqu'il n'y a plus qu'un thread, la synchronisation de threads devient inutile et le s\u00e9maphore dispara\u00eet\u00a0; Voici deux exemples de tests\u00a0:</li> </ul> <pre><code>  // -----------------------------------\n  private ElectionsException checkUserUserException;\n\n  @Test()\n  public void checkUserUser() throws InterruptedException {\n    // op\u00e9ration synchrone\n    electionsMetier.authenticate(user)\n            .subscribe((result) -&gt; {\n            },\n                    (th) -&gt; {\n                      checkUserUserException = (ElectionsException) th;\n                    },\n                    () -&gt; {\n                    });\n    // v\u00e9rification r\u00e9sultats\n    Assert.assertNotNull(checkUserUserException);\n    Assert.assertEquals(\"403 Forbidden\", checkUserUserException.getErreurs().get(0));\n}\n</code></pre> <ul> <li>ligne 7\u00a0: par d\u00e9faut, la m\u00e9thode [electionsMetier.authenticate(user).subscribe] s'ex\u00e9cute dans le thread du code appelant. On a donc une op\u00e9ration synchrone\u00a0; <pre><code>  // -----------------------------------\n  private ElectionsException calculSieges1Exception;\n  private ListeElectorale[] listesCalculSieges1;\n\n  @Test\n  public void calculSieges1() throws InterruptedException {\n    // on cr\u00e9e le tableau des 7 listes candidates\n    ListeElectorale[] listes = new ListeElectorale[7];\n    listes[0] = new ListeElectorale(\"A\", 32000, 0, false);\n    listes[1] = new ListeElectorale(\"B\", 25000, 0, false);\n    listes[2] = new ListeElectorale(\"C\", 16000, 0, false);\n    listes[3] = new ListeElectorale(\"D\", 12000, 0, false);\n    listes[4] = new ListeElectorale(\"E\", 8000, 0, false);\n    listes[5] = new ListeElectorale(\"F\", 4500, 0, false);\n    listes[6] = new ListeElectorale(\"G\", 2500, 0, false);\n    // op\u00e9ration synchrone    \n    // on calcule les si\u00e8ges de chacune des listes\n    electionsMetier.calculerSieges(admin, listes)\n            .subscribe((result) -&gt; {\n              listesCalculSieges1 = result;\n            },\n                    (th) -&gt; {\n                      calculSieges1Exception = (ElectionsException) th;\n                    },\n                    () -&gt; {\n                    });\n    // on v\u00e9rifie les r\u00e9sultats\n    Assert.assertNull(calculSieges1Exception);\n    Assert.assertEquals(2, listesCalculSieges1[0].getSieges());\n    Assert.assertFalse(listesCalculSieges1[0].isElimine());\n    Assert.assertEquals(2, listesCalculSieges1[1].getSieges());\n    Assert.assertFalse(listesCalculSieges1[1].isElimine());\n    Assert.assertEquals(1, listesCalculSieges1[2].getSieges());\n    Assert.assertFalse(listesCalculSieges1[2].isElimine());\n    Assert.assertEquals(1, listesCalculSieges1[3].getSieges());\n    Assert.assertFalse(listesCalculSieges1[3].isElimine());\n    Assert.assertEquals(0, listesCalculSieges1[4].getSieges());\n    Assert.assertFalse(listesCalculSieges1[4].isElimine());\n    Assert.assertEquals(0, listesCalculSieges1[5].getSieges());\n    Assert.assertTrue(listesCalculSieges1[5].isElimine());\n    Assert.assertEquals(0, listesCalculSieges1[6].getSieges());\n    Assert.assertTrue(listesCalculSieges1[6].isElimine());\n  }\n</code></pre></li> </ul> <p>Travail \u00e0 faire\u00a0: passer le test [Test03] et v\u00e9rifier qu'il passe.</p>"},{"location":"programmation-asynchrone-avec-rxjava.html#202-etape-2","title":"20.2. \u00e9tape 2","text":"<p>Nous portons maintenant l'application console synchrone du chapitre 17.5, page 339, en une application toujours synchrone mais utilisant l'interface asynchrone [RxJava, metier, DAO]\u00a0;</p> <p>Nous partons du projet [elections-console-metier-dao-security-webjson] [1] du chapitre 17.5, page 339 que nous dupliquons dans un nouveau projet [elections-console-rxjava- metier-dao-security-webjson] [2]\u00a0:</p> <ul> <li>en [3-4], dans le nouveau projet on supprime la d\u00e9pendance sur l'ancienne couche [m\u00e9tier] synchrone\u00a0;</li> </ul> <ul> <li>en [5-9], on ajoute une d\u00e9pendance sur la nouvelle couche [m\u00e9tier] asynchrone\u00a0;</li> </ul> <ul> <li>en [10-14], on renomme la classe [ElectionsConsole] en [ElectionsConsole01]\u00a0; De m\u00eame, on renomme la classe [BootElectionsConsole] en [BootElectionsConsole01]\u00a0:</li> </ul> <p>Le code actuel de la classe [BootElectionsConsole01] est le suivant\u00a0:</p> <pre><code>package elections.security.client.boot;\n\nimport elections.security.client.console.IElectionsUI;\n\n\npublic class BootElectionsConsole01 extends AbstractBootElections{\n    public static void main(String[] arguments) {\n        new BootElectionsConsole01().run();\n    }\n\n    @Override\n    protected IElectionsUI getUI() {\n        return ctx.getBean(\"electionsConsole\",IElectionsUI.class);\n    }\n}\n</code></pre> <ul> <li>ligne 13\u00a0: parce qu'on a chang\u00e9 le nom de la classe [ElectionsConsole] en [ElectionsConsole01], il faut d\u00e9sormais \u00e9crire\u00a0: <pre><code>        return ctx.getBean(\"electionsConsole01\",IElectionsUI.class);\n</code></pre></li> </ul> <p>Revenons au code de la classe [ElectionsConsole01]\u00a0:</p> <pre><code>@Component\npublic class ElectionsConsole01 implements IElectionsUI {\n\n    @Autowired\n    private IElectionsMetier electionsMetier;\n\n  @Autowired\n  private User admin;\n\n    @Override\n    public void run() {\n        // les listes en comp\u00e9tition\n        ListeElectorale[] listes;\n        // saisie des donn\u00e9es\n        try (Scanner clavier = new Scanner(System.in)) {\n         // on demande les listes en comp\u00e9tition \u00e0 la couche [metier]\n         listes = electionsMetier.getListesElectorales(admin);\n            ...\n        // on fait le calcul des si\u00e8ges\n        listes=electionsMetier.calculerSieges(admin,listes);\n        // on enregistre les r\u00e9sultats\n        electionsMetier.recordResultats(admin,listes);\n        ...\n}\n</code></pre> <p>Si on suit l'exemple du test [Test01] du paragraphe 20.1.4.1, page 391, les lignes 5, 17, 20 et 22 vont \u00e9voluer de la fa\u00e7on suivante\u00a0:</p> <pre><code>@Component\npublic class ElectionsConsole01 implements IElectionsUI {\n\n  @Autowired\n  private IRxElectionsMetier electionsMetier;\n\n  @Autowired\n  private User admin;\n\n  @Override\n  public void run() {\n    // les listes en comp\u00e9tition\n    ListeElectorale[] listes;\n    // saisie des donn\u00e9es\n    try (Scanner clavier = new Scanner(System.in)) {\n      // on demande les listes en comp\u00e9tition \u00e0 la couche [metier]\n      listes = BlockingObservable.from(electionsMetier.getListesElectorales(admin)).first();\n      ...\n    // on fait le calcul des si\u00e8ges\n    listes = BlockingObservable.from(electionsMetier.calculerSieges(admin, listes)).first();\n    // on enregistre les r\u00e9sultats\n    BlockingObservable.from(electionsMetier.recordResultats(admin, listes));\n    ...\n  }\n</code></pre> <p>Travail \u00e0 faire\u00a0: configurez le projet pour ex\u00e9cuter la classe [BootElectionsConsole01] avec les trois param\u00e8tres [SS, Heures travaill\u00e9es, Jours travaill\u00e9s] et v\u00e9rifiez que l'ex\u00e9cution du projet ainsi configur\u00e9 donne les r\u00e9sultats attendus.</p> <p>Travail \u00e0 faire\u00a0: configurez le projet pour ex\u00e9cuter le couple [BootElectionsConsole02, ElectionsConsole02] o\u00f9 la classe [ElectionsConsole02] aura \u00e9t\u00e9 \u00e9crite en suivant le mod\u00e8le du test [Test02] du paragraphe 20.1.4.2, page 394.</p> <p>Travail \u00e0 faire\u00a0: configurez le projet pour ex\u00e9cuter le couple [BootElectionsConsole03, ElectionsConsole03] o\u00f9 la classe [ElectionsConsole03] aura \u00e9t\u00e9 \u00e9crite en suivant le mod\u00e8le du test [Test03] du paragraphe 20.1.4.3, page 395.</p>"},{"location":"programmation-asynchrone-avec-rxjava.html#203-etape-3","title":"20.3. \u00e9tape 3","text":"<p>Nous passons maintenant au portage de l'application swing dans un environnement asynchrone.</p> <p>Nous commen\u00e7ons par dupliquer le projet [elections-swing-metier-dao-security-webjson] [1] du chapitre 17.6, page 343, dans un nouveau projet [elections-swing-rxjava-metier-dao-security-webjson] [2]\u00a0:</p> <ul> <li>en [3, 4], nous supprimons la d\u00e9pendance sur la couche [console] synchrone\u00a0;</li> </ul> <ul> <li> <p>en [5-9], nous ajoutons une d\u00e9pendance sur la couche console asynchrone\u00a0; La couche [swing] va faire de vrais appels asynchrones \u00e0 la couche [m\u00e9tier]. Lors de l'appel \u00e0 une m\u00e9thode de celle-ci, il y aura deux threads\u00a0:</p> </li> <li> <p>le thread de l'UI, celui qui g\u00e8re les \u00e9v\u00e9nements\u00a0;</p> </li> <li>un thread d'E/S qui ex\u00e9cutera l'appel HTTP au serveur\u00a0; Pendant toute la dur\u00e9e de l'appel asynchrone, nous devrions afficher une image d'attente ainsi qu'un bouton d'annulation. Nous ne le ferons pas ici et cela vous sera propos\u00e9 comme am\u00e9lioration de l'application. Les modifications ont lieu dans les deux classes qui font des appels \u00e0 la couche [m\u00e9tier]\u00a0:</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#2031-configuration-maven","title":"20.3.1. Configuration Maven","text":"<p>Nous allons utiliser ici la biblioth\u00e8que [RxSwing] qui ajoute \u00e0 la biblioth\u00e8que [RxJava] des fonctionnalit\u00e9s disponibles seulement dans un environnement Swing. Pour cela, nous modifions le fichier [pom.xml] de la fa\u00e7on suivante\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n  &lt;artifactId&gt;elections-swing-rxjava-metier-dao-security-webjson&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;elections-swing-rxjava-metier-dao-security-webjson&lt;/name&gt;\n  &lt;description&gt;couche swing asynchrone du client web / jSON&lt;/description&gt;\n\n  &lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;\n    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;\n  &lt;/properties&gt;\n\n  &lt;dependencies&gt;\n    &lt;!-- RxSwing --&gt;\n    &lt;!-- https://mvnrepository.com/artifact/io.reactivex/rxswing --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;io.reactivex&lt;/groupId&gt;\n      &lt;artifactId&gt;rxswing&lt;/artifactId&gt;\n      &lt;version&gt;0.27.0&lt;/version&gt;\n    &lt;/dependency&gt;\n    &lt;!-- couches basses --&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n      &lt;artifactId&gt;elections-console-rxjava-metier-dao-security-webjson&lt;/artifactId&gt;\n      &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>"},{"location":"programmation-asynchrone-avec-rxjava.html#2032-la-classe-electionsconnectform","title":"20.3.2. La classe [ElectionsConnectForm]","text":"<p>Dans un fonctionnement asynchrone, la classe [ElectionsConnectForm] devient la suivante\u00a0:</p> <pre><code>package elections.security.client.swing;\n\nimport elections.security.client.console.IElectionsUI;\nimport elections.security.client.entities.User;\n\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport javax.swing.SwingUtilities;\n\nimport elections.security.client.metier.IRxElectionsMetier;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport rx.schedulers.Schedulers;\nimport rx.schedulers.SwingScheduler;\n\n@Component\npublic class ElectionsConnectForm extends AbstractElectionsConnectForm implements IElectionsUI {\n\n  private static final long serialVersionUID = 1L;\n\n  // r\u00e9f\u00e9rence sur la couche [m\u00e9tier] asynchrone\n  @Autowired\n  private IRxElectionsMetier metier;\n\n  // utilisateur connect\u00e9\n  private User user;\n\n  // formulaire principal\n  @Autowired\n  private ElectionsMainForm electionsMainForm;\n\n  // session UI\n  @Autowired\n  private UiSession uiSession;\n\n  @Override\n  protected void doConnect() {\n    if (isPageValid()) {\n      // authentification de l'utilisateur\n      metier.authenticate(user).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance()).subscribe(\n        // il n'y a pas de r\u00e9ponse\n        (result) -&gt; {\n        },\n        // gestion de l'exception\n        (th) -&gt; {\n          // on note l'erreur\n          String info = getInfoForException(\"Les erreurs suivantes se sont produites :\", th);\n          // on affiche l'info\n          jTextPaneErreurs.setText(info);\n          jTextPaneErreurs.setCaretPosition(0);\n\n        },\n        // l'authentification est termin\u00e9e\n        () -&gt; {\n          // on m\u00e9morise l'utilisateur dans la session\n          uiSession.setUser(user);\n          // la vue de connexion est cach\u00e9e\n          setVisible(false);\n          // la vue principale est affich\u00e9e\n          electionsMainForm.run();\n        });\n    }\n  }\n\n  // initialisations\n  @Override\n  protected void init() {\n    ...\n  }\n\n  @Override\n  public void run() {\n    // on affiche l'interface graphique\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        init();\n        setVisible(true);\n      }\n    });\n  }\n\n  private boolean isPageValid() {\n    ...\n  }\n\n  private String getInfoForException(String message, Throwable ex) {\n    ...\n  }\n\n}\n</code></pre> <ul> <li>lignes 36-63\u00a0: la m\u00e9thode [doConnect] est ex\u00e9cut\u00e9e lorsque l'utilisateur appuie sur l'option de menu [Connexion]\u00a0:</li> </ul> <p>Tout est dans la ligne 40\u00a0:</p> <pre><code>      metier.authenticate(user).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance()).subscribe(...)\n</code></pre> <ul> <li>le processus observ\u00e9 est [metier.authenticate(user)]\u00a0;</li> <li>il sera ex\u00e9cut\u00e9 sur un thread d'E/S pris dans le pool [Schedulers.io()]\u00a0;</li> <li> <p>il sera observ\u00e9 dans le thread de l'UI, celui qui g\u00e8re les \u00e9v\u00e9nements de l'interface Swing [observeOn(SwingScheduler.getInstance())]. Ce thread est obtenu par la m\u00e9thode [SwingScheduler.getInstance()] o\u00f9 [SwingScheduler] est une classe fournie par la biblioth\u00e8que [RxSwing]. Ceci est obligatoire. A l'obtention du r\u00e9sultat de l'opration asynchrone, celui-ci est souvent utilis\u00e9 pour modifier des \u00e9l\u00e9ments de l'interface Swing. Or celle-ci ne peut \u00eatre modifi\u00e9e que dans le thread de l'UI, sinon on a une exception. Il faut donc que les lignes 41-61 s'ex\u00e9cutent dans le thread de l'UI. C'est assur\u00e9 ici par la m\u00e9thode [observeOn(SwingScheduler.getInstance())]\u00a0; Commentons le reste du code\u00a0:</p> </li> <li> <p>lignes 42-43\u00a0: ces lignes sont l\u00e0 pour respecter la syntaxe de la m\u00e9thode [subscribe]. Elles ne seront jamais ex\u00e9cut\u00e9es car le processus [metier.authenticate(user)] ne rend aucun r\u00e9sultat\u00a0;</p> </li> <li>lignes 35-52\u00a0: \u00e0 r\u00e9ception d'une exception, celle-ci est affich\u00e9e\u00a0;</li> <li>lignes 54-61\u00a0: ex\u00e9cut\u00e9es lorsque le processus [metier.authenticate(user)] signale la fin de ses \u00e9missions\u00a0;</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#2033-la-classe-electionsmainform","title":"20.3.3. La classe [ElectionsMainForm]","text":""},{"location":"programmation-asynchrone-avec-rxjava.html#20331-initialisation-de-linterface-graphique","title":"20.3.3.1. Initialisation de l'interface graphique","text":"<pre><code>package elections.security.client.swing;\n\nimport elections.security.client.console.IElectionsUI;\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport elections.security.client.metier.IRxElectionsMetier;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport rx.schedulers.Schedulers;\nimport rx.schedulers.SwingScheduler;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Component\npublic class ElectionsMainForm extends AbstractElectionsMainForm implements IElectionsUI {\n\n  private static final long serialVersionUID = 1L;\n\n  // r\u00e9f\u00e9rence sur la couche [m\u00e9tier] asynchrone\n  @Autowired\n  private IRxElectionsMetier metier;\n\n  // session UI\n  @Autowired\n  private UiSession uiSession;\n\n  // utilisateur connect\u00e9\n  private User user;\n\n  // mod\u00e8les des listes JList\n  private DefaultListModel&lt;String&gt; mod\u00e8leNomsVoix = null;\n  private DefaultListModel&lt;String&gt; mod\u00e8leR\u00e9sultats = null;\n\n  // les listes en comp\u00e9tition\n  private ListeElectorale[] listes;\n\n  // listes saisies par l'utilisateur\n  private final List&lt;ListeElectorale&gt; listesSaisies = new ArrayList&lt;&gt;();\n  private ListeElectorale[] tListesSaisies;\n\n  // initialisations\n  @Override\n  protected void init() {\n    // g\u00e9n\u00e9ration des composants par la classe parent\n    super.init();\n    // \u00e9tat formulaire\n    Utilitaires.setEnabled(new JLabel[]{jLabelAjouter, jLabelCalculer, jLabelEnregistrer, jLabelSupprimer}, false);\n    Utilitaires.setEnabled(\n            new JMenuItem[]{jMenuItemAjouter, jMenuItemCalculer, jMenuItemEnregistrer, jMenuItemSupprimer}, false);\n    // centrer la fen\u00eatre\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    Dimension frameSize = getSize();\n    if (frameSize.height &gt; screenSize.height) {\n      frameSize.height = screenSize.height;\n    }\n    if (frameSize.width &gt; screenSize.width) {\n      frameSize.width = screenSize.width;\n    }\n    setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n    // utilisateur connect\u00e9\n    user = uiSession.getUser();\n    // initialisations locales\n    mod\u00e8leNomsVoix = new DefaultListModel&lt;&gt;();\n    jListNomsVoix.setModel(mod\u00e8leNomsVoix);\n    mod\u00e8leR\u00e9sultats = new DefaultListModel&lt;&gt;();\n    jListResultats.setModel(mod\u00e8leR\u00e9sultats);\n    // on demande les listes \u00e0 la couche [m\u00e9tier]\n    metier.getListesElectorales(user).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance())\n            .subscribe(\n                    // r\u00e9ponse\n                    listesElectorales -&gt; {\n                      // on m\u00e9morise les listes\n                      listes = listesElectorales;\n                    },\n                    // exception\n                    (th) -&gt; showException(th),\n                    // fin observable\n                    () -&gt; {\n                      // \u00e9tape suivante\n                      doInitStep2();\n                    });\n  }\n...\n</code></pre> <ul> <li>ligne 46\u00a0: la m\u00e9thode [init] est ex\u00e9cut\u00e9e lorsque la fen\u00eatre associ\u00e9e va s'afficher. Elle a pour but d'initialiser les composants [1-3] ci-dessous\u00a0:</li> </ul> <ul> <li>lignes 71-85\u00a0: on demande de fa\u00e7on asynchrone les listes candidates (composant [1])\u00a0;</li> <li>ligne 71\u00a0: le processus observ\u00e9 est [metier.getListesElectorales(user)]. Il est ex\u00e9cut\u00e9 sur un thread d'E/S [subscribeOn(Schedulers.io())] et observ\u00e9 sur le thread de l'UI [observeOn(SwingScheduler.getInstance()]\u00a0;</li> <li>lignes 74-77\u00a0: le r\u00e9sultat renvoy\u00e9 par le processus observ\u00e9 est m\u00e9moris\u00e9 dans le champ [listes] de la ligne 38\u00a0;</li> <li> <p>ligne 79\u00a0: l'\u00e9ventuelle exception est trait\u00e9e par la m\u00e9thode suivante\u00a0: <pre><code>  private void showException(Throwable th) {\n    // on affiche l'exception\n    jTextPaneMessages.setText(getInfoForException(\"Les erreurs suivantes se sont produites : \", th));\n    jTextPaneMessages.setCaretPosition(0);\n}\n</code></pre></p> </li> <li> <p>lignes 81-84\u00a0: \u00e0 la fin du processus observ\u00e9, on ex\u00e9cute les lignes 81-84. Ces lignes ne sont pas ex\u00e9cut\u00e9es s'il y a eu exception. La m\u00e9thode [doInitStep2] assure l'\u00e9tape 2 de l'initialisation de la fa\u00e7on suivante\u00a0: <pre><code>  private void doInitStep2() {\n    // on associe les noms des listes au combo jComboBoxNomsListes\n    for (int i = 0; i &lt; listes.length; i++) {\n      jComboBoxNomsListes.addItem(String.format(\"%s - %s\", listes[i].getId(), listes[i].getNom()));\n    }\n    // nombre de si\u00e8ges \u00e0 pourvoir\n    metier.getNbSiegesAPourvoir(user).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance())\n            .subscribe(\n                    // r\u00e9ponse\n                    nbSiegesAPourvoir -&gt; {\n                      // on initialise le label li\u00e9 \u00e0 cette information\n                      jLabelSAP.setText(jLabelSAP.getText() + nbSiegesAPourvoir);\n                    },\n                    // exception\n                    (th) -&gt; showException(th),\n                    // fin observable\n                    () -&gt; {\n                      // \u00e9tape suivante\n                      doInitStep3();\n                    });\n}\n</code></pre></p> </li> <li> <p>lignes 3-5\u00a0: on utilise le r\u00e9sultat de l'\u00e9tape pr\u00e9c\u00e9dente pour remplir la liste d\u00e9roulante avec les noms des listes candidates\u00a0;</p> </li> <li>lignes 7-20\u00a0: on demande le nombre de si\u00e8ges \u00e0 pourvoir de fa\u00e7on asynchrone\u00a0;</li> <li>ligne 7\u00a0: le processus observ\u00e9 est [metier.getNbSiegesAPourvoir(user)]. Il est ex\u00e9cut\u00e9 sur un thread d'E/S [subscribeOn(Schedulers.io())] et observ\u00e9 sur le thread de l'UI [observeOn(SwingScheduler.getInstance()]\u00a0;</li> <li>lignes 10-13\u00a0: le r\u00e9sultat renvoy\u00e9 par le processus est utilis\u00e9 pour mettre \u00e0 jour l'interface graphique\u00a0;</li> <li>ligne 15\u00a0: on affiche l'\u00e9ventuelle exception\u00a0;</li> <li>lignes 17-20\u00a0: \u00e0 r\u00e9ception du signal de fin de l'observable, on passe \u00e0 l'\u00e9tape 3 du processus d'initialisation\u00a0; L'\u00e9tape 3 de l'initialisation est assur\u00e9e par le code suivant\u00a0:</li> </ul> <pre><code>  private void doInitStep3() {\n    // seuil \u00e9lectoral\n    metier.getSeuilElectoral(user).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance())\n            .subscribe(\n                    // r\u00e9ponse\n                    seuilElectoral -&gt; {\n                      // on initialise le label li\u00e9 \u00e0 cette information\n                      jLabelSE.setText(jLabelSE.getText() + seuilElectoral);\n                    },\n                    // exception\n                    (th) -&gt; showException(th),\n                    // fin observable\n                    () -&gt; {\n                    });\n}\n</code></pre> <ul> <li>lignes 3-4\u00a0: on demande le seuil \u00e9lectoral de fa\u00e7on asynchrone\u00a0;</li> <li>ligne 3\u00a0: le processus observ\u00e9 est [metier.getSeuilElectoral(user)]. Il est ex\u00e9cut\u00e9 sur un thread d'E/S [subscribeOn(Schedulers.io())] et observ\u00e9 sur le thread de l'UI [observeOn(SwingScheduler.getInstance()]\u00a0;</li> <li>lignes 6-9\u00a0: le r\u00e9sultat renvoy\u00e9 par le processus est utilis\u00e9 pour mettre \u00e0 jour l'interface graphique\u00a0;</li> <li>ligne 11\u00a0: on affiche l'\u00e9ventuelle exception\u00a0;</li> <li>lignes 13-14\u00a0: \u00e0 r\u00e9ception du signal de fin de l'observable, rien n'est fait\u00a0: le processus d'initialisation de l'interface graphique est termin\u00e9\u00a0;</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#20332-calcul-des-sieges-obtenus-par-les-differentes-listes","title":"20.3.3.2. Calcul des si\u00e8ges obtenus par les diff\u00e9rentes listes","text":"<p>La m\u00e9thode [doCalculer] a pour fonction de calculer le nombre de si\u00e8ges obtenus par les diff\u00e9rentes listes\u00a0:</p> <pre><code>  @Override\n  protected void doCalculer() {\n    tListesSaisies = listesSaisies.toArray(new ListeElectorale[0]);\n    // calcul des si\u00e8ges\n    String info = null;\n    metier.calculerSieges(user, tListesSaisies).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance())\n            .subscribe(\n                    // traitement r\u00e9sultat\n                    result -&gt; consumeResultSieges(result),\n                    // traitement exception\n                    th -&gt; showException(th),\n                    // fin observable\n                    () -&gt; {\n                    }\n            );\n}\n</code></pre> <ul> <li>lignes 6-15\u00a0: on calcule de fa\u00e7on asynchrone les si\u00e8ges obtenus par les diff\u00e9rentes listes\u00a0;</li> <li>ligne 6\u00a0: le processus observ\u00e9 est [metier.calculerSieges(user, tListesSaisies)]. Il est ex\u00e9cut\u00e9 sur un thread d'E/S [subscribeOn(Schedulers.io())] et observ\u00e9 sur le thread de l'UI [observeOn(SwingScheduler.getInstance()]\u00a0;</li> <li>ligne 9\u00a0: le r\u00e9sultat renvoy\u00e9 par le processus est utilis\u00e9 par la m\u00e9thode [consumeResultSieges]\u00a0;</li> <li>ligne 11\u00a0: on affiche l'\u00e9ventuelle exception\u00a0;</li> <li>lignes 13-14\u00a0: \u00e0 r\u00e9ception du signal de fin de l'observable, rien n'est fait\u00a0; Ligne 9, la m\u00e9thode [consumeResultSieges] exploite le r\u00e9sultat renvoy\u00e9 par le processus observ\u00e9, les listes candidates avec leurs champs [sieges, elimine] mis \u00e0 jour\u00a0:</li> </ul> <pre><code>  private void consumeResultSieges(ListeElectorale[] tListesSaisies) {\n    // on m\u00e9morise le r\u00e9sultat\n    this.tListesSaisies = tListesSaisies;\n    // affichage des r\u00e9sultats\n    mod\u00e8leR\u00e9sultats.clear();\n    for (int i = 0; i &lt; tListesSaisies.length; i++) {\n      mod\u00e8leR\u00e9sultats.addElement(tListesSaisies[i].toString());\n    }\n    // maj \u00e9tat formulaire\n    Utilitaires.setEnabled(new JLabel[]{jLabelEnregistrer}, true);\n    Utilitaires.setEnabled(new JLabel[]{jLabelCalculer}, false);\n    Utilitaires.setEnabled(new JMenuItem[]{jMenuItemEnregistrer}, true);\n    Utilitaires.setEnabled(new JMenuItem[]{jMenuItemCalculer}, false);\n    jTextPaneMessages.setText(\"Calcul termin\u00e9\");\n}\n</code></pre> <ul> <li>lignes 4-14\u00a0: le r\u00e9sultat obtenu est utilis\u00e9 pour mettre \u00e0 jour l'interface graphique\u00a0;</li> </ul>"},{"location":"programmation-asynchrone-avec-rxjava.html#20333-enregistrement-des-resultats-de-lelection","title":"20.3.3.3. Enregistrement des r\u00e9sultats de l'\u00e9lection","text":"<p>L'enregistrement des r\u00e9sultats de l'\u00e9lection est fait par la m\u00e9thode [doEnregistrer] suivante\u00a0:</p> <pre><code>  @Override\n  protected void doEnregistrer() {\n    // on demande l'enregistrement \u00e0 la couche [m\u00e9tier]\n    metier.recordResultats(user, tListesSaisies).subscribeOn(Schedulers.io()).observeOn(SwingScheduler.getInstance())\n            .subscribe(\n                    // traitement du r\u00e9sultat - il n'y en a pas ici\n                    (param) -&gt; {\n                    },\n                    // traitement de l'exception\n                    (th) -&gt; showException(th),\n                    // fin observable\n                    () -&gt; {\n                      // maj du formulaire\n                      Utilitaires.setEnabled(new JLabel[]{jLabelEnregistrer}, false);\n                      Utilitaires.setEnabled(new JMenuItem[]{jMenuItemEnregistrer}, false);\n                      jTextPaneMessages.setText(\"Enregistrement des r\u00e9sultats r\u00e9alis\u00e9\");\n                    }\n            );\n}\n</code></pre> <ul> <li>lignes 4-17\u00a0: on enregistre les r\u00e9sultats de l'\u00e9lection de fa\u00e7on asynchrone\u00a0;</li> <li>ligne 4\u00a0: le processus observ\u00e9 est [metier.recordResultats(user, tListesSaisies)]. Il est ex\u00e9cut\u00e9 sur un thread d'E/S [subscribeOn(Schedulers.io())] et observ\u00e9 sur le thread de l'UI [observeOn(SwingScheduler.getInstance()]\u00a0;</li> <li>lignes 7-8\u00a0: ces lignes ne seront jamais ex\u00e9cut\u00e9es car le processus observ\u00e9 ne rend pas de r\u00e9sultat\u00a0;</li> <li>ligne 10\u00a0: on affiche l'\u00e9ventuelle exception\u00a0;</li> <li>lignes 14-16\u00a0: \u00e0 r\u00e9ception du signal de fin de l'observable, on met \u00e0 jour l'interface graphique\u00a0; Travail \u00e0 faire\u00a0: v\u00e9rifier que l'application Swing fonctionne. Puis faites \u00e9voluer l'interface graphique et le code pour que lors d'une op\u00e9ration asynchrone avec le serveur web / jSON, une image d'attente apparaisse ainsi qu'une option d'annulation de l'op\u00e9ration en cours.</li> </ul>"},{"location":"td-architectures-en-couches.html","title":"4. [TD]\u00a0: Architectures en couches","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances.</p>"},{"location":"td-architectures-en-couches.html#41-introduction","title":"4.1. Introduction","text":"<p>Rappelons ce qui a \u00e9t\u00e9 fait :</p> <ul> <li>dans la partie 1 de l'exercice ELECTIONS aucune classe n'a \u00e9t\u00e9 utilis\u00e9e. On a construit une solution comme on l'aurait construite en langage C.</li> <li>dans la partie 2 de l'exercice, deux classes ont \u00e9t\u00e9 introduites :</li> <li>[ListeElectorale] qui repr\u00e9sente les attributs (id, nom, voix, si\u00e8ges, \u00e9limine) d'une liste candidate</li> <li>[ElectionsException] une classe d'exceptions non contr\u00f4l\u00e9es. Ce type d'exception est utilis\u00e9 \u00e0 chaque fois que se produit une erreur fatale dans l'application des \u00e9lections. Elle est non contr\u00f4l\u00e9e, c.a.d. que le d\u00e9veloppeur n'est pas oblig\u00e9 de la g\u00e9rer avec un try-catch. Le calcul du r\u00e9sultat des \u00e9lections a \u00e9t\u00e9 confi\u00e9 jusqu'\u00e0 maintenant \u00e0 une m\u00e9thode [main] d'une classe [MainElections]</li> </ul> <pre><code>package istia.st.elections;\n\nimport java.io.*;\n\npublic class MainElections {\n\n  // qqs donn\u00e9es\n  private static final double barre = 0.05;\n\n  // ----------------------------------------------------------------------\n  // la proc\u00e9dure principale\n  public static void main(String[] arguments) throws IOException {\n\n    // on pr\u00e9pare le flux d'entr\u00e9e clavier\n    BufferedReader clavier = new BufferedReader(new InputStreamReader(System.in));\n\n    // saisie des donn\u00e9es n\u00e9cessaires au calcul des si\u00e8ges\n...\n    // calcul des si\u00e8ges obtenus par les diff\u00e9rentes listes\n....\n    // affichage des r\u00e9sultats\n...\n  } // main\n} // classe\n</code></pre> <p>La solution pr\u00e9c\u00e9dente inclut trois phases classiques :</p> <ul> <li>l'acquisition des donn\u00e9es, lignes 17-18</li> <li>le calcul de la solution, lignes 19-20</li> <li>l'affichage et / ou la persistance des r\u00e9sultats, lignes 21-22 Seule la phase 2 est vraiment constante. La phase 1 peut varier : les donn\u00e9es peuvent venir du clavier comme dans les exemples \u00e9tudi\u00e9s, d'un fichier texte, d'une interface graphique, d'une base de donn\u00e9es, du r\u00e9seau, ... De m\u00eame il y a de multiples fa\u00e7ons de restituer les r\u00e9sultats dans la phase 3 : les afficher \u00e0 l'\u00e9cran comme cela a \u00e9t\u00e9 fait dans les exemples \u00e9tudi\u00e9s, les enregistrer dans un fichier, dans une base de donn\u00e9es, les envoyer sur le r\u00e9seau, ...</li> </ul> <p>De fa\u00e7on plus g\u00e9n\u00e9rale, une application peut souvent \u00eatre mod\u00e9lis\u00e9e en trois couches ayant chacune un r\u00f4le bien d\u00e9fini :</p> <p>On appelle \u00e9galement cette architecture, \"architecture trois tiers\", traduction de l'anglais \"three tier architecture\". Le terme \"trois tiers\" d\u00e9signe normalement une architecture o\u00f9 chaque tier est sur une machine diff\u00e9rente. Lorsque les tiers sont sur une m\u00eame machine, l'architecture devient une architecture \"trois couches\".</p> <ul> <li>la couche [metier] est celle qui contient les r\u00e8gles m\u00e9tier de l'application. Pour notre application d'\u00e9lections, ce sont les r\u00e8gles qui permettent de calculer les si\u00e8ges obtenus par les diff\u00e9rentes listes, une fois que l'on conna\u00eet les voix obtenues par chacune d'elles. Cette couche a besoin de donn\u00e9es pour travailler. Par exemple dans l'application d'\u00e9lections :</li> <li>les listes avec pour chacune son nom et son nombre de voix</li> <li>le nombre de si\u00e8ges \u00e0 pourvoir</li> <li> <p>le seuil \u00e9lectoral au-dessous duquel, une liste est \u00e9limin\u00e9e Dans le sch\u00e9ma ci-dessus, les donn\u00e9es peuvent provenir de deux endroits :</p> </li> <li> <p>la couche d'acc\u00e8s aux donn\u00e9es ou [dao] (DAO = Data Access Object) pour les donn\u00e9es d\u00e9j\u00e0 enregistr\u00e9es dans des fichiers ou bases de donn\u00e9es. Ce pourrait \u00eatre le cas ici du nom des listes, du nombre de si\u00e8ges \u00e0 pourvoir, du seuil \u00e9lectoral. On conna\u00eet en effet ces informations avant l'\u00e9lection elle-m\u00eame.</p> </li> <li>la couche d'interface avec l'utilisateur ou [ui] (UI = User Interface) pour les donn\u00e9es saisies par l'utilisateur ou affich\u00e9es \u00e0 l'utilisateur. Ce pourrait \u00eatre le cas ici des voix des listes qui ne sont connues qu'au dernier moment ainsi que de l'affichage des r\u00e9sultats de l'\u00e9lection.</li> <li>de fa\u00e7on g\u00e9n\u00e9rale, la couche [dao] s'occupe de l'acc\u00e8s aux donn\u00e9es persistantes (fichiers, bases de donn\u00e9es) ou non persistantes (r\u00e9seau, capteurs, ...).</li> <li>la couche [ui] elle, s'occupe des interactions avec l'utilisateur s'il y en a un.</li> <li>les trois couches sont rendues ind\u00e9pendantes gr\u00e2ce \u00e0 l'utilisation d'interfaces Java.</li> <li>pour int\u00e9grer ces couches ensemble dans l'application, il existe diff\u00e9rentes m\u00e9thodes. Nous serons amen\u00e9s \u00e0 utiliser un outil appel\u00e9 \"\u00a0Spring\u00a0\". Sur le sch\u00e9ma, il est transversal aux autres couches. Nous allons reprendre l'application [Elections] d\u00e9velopp\u00e9e pr\u00e9c\u00e9demment pour lui donner une architecture 3 couches. Pour cela, nous allons \u00e9tudier les couches [ui, metier, dao] les unes apr\u00e8s les autres, en commen\u00e7ant par la couche [dao], couche qui s'occupe des donn\u00e9es persistantes.</li> </ul> <p>Auparavant, il nous faut d\u00e9finir les interfaces des diff\u00e9rentes couches de l'application [Elections].</p>"},{"location":"td-architectures-en-couches.html#42-les-interfaces-de-lapplication-elections","title":"4.2. Les interfaces de l'application [Elections]","text":"<p>Rappelons qu'une interface d\u00e9finit un ensemble de signatures de m\u00e9thodes. Les classes impl\u00e9mentant l'interface donnent un contenu \u00e0 ces m\u00e9thodes.</p> <p>Revenons \u00e0 l'architecture 3 couches de notre application :</p> <p>Dans ce type d'architecture, c'est souvent l'utilisateur qui prend les initiatives. Il fait une demande en [1] et re\u00e7oit une r\u00e9ponse en [8]. On appelle cela le cycle demande - r\u00e9ponse. Prenons l'exemple du calcul des si\u00e8ges obtenus au soir des \u00e9lections. Celui-ci va n\u00e9cessiter plusieurs \u00e9tapes :</p> <ul> <li>la couche [ui] va devoir demander \u00e0 l'utilisateur le nombre de voix obtenues par chacune des listes. Pour cela elle va devoir pr\u00e9senter \u00e0 celui-ci le nom des listes en comp\u00e9tition. L'utilisateur n'aura alors qu'\u00e0 mettre le nombre de voix en face de chaque liste puis \u00e0 demander le calcul des si\u00e8ges.</li> <li>la couche [ui] ne dispose pas du nom des listes. Celles-ci sont enregistr\u00e9es dans la source de donn\u00e9es \u00e0 droite du sch\u00e9ma. Elle va utiliser le chemin [2, 3, 4, 5, 6, 7] pour les obtenir. L'op\u00e9ration [2] est la demande des listes, l'op\u00e9ration [7] la r\u00e9ponse \u00e0 cette demande. Ceci fait, elle peut les pr\u00e9senter \u00e0 l'utilisateur par [8].</li> <li>l'utilisateur va transmettre \u00e0 la couche [ui] le nombre de voix obtenues par chacune des listes. C'est l'op\u00e9ration [1] ci-dessus. Au cours de cette \u00e9tape, l'utilisateur n'interagit qu'avec la couche [ui]. C'est celle-ci qui va notamment v\u00e9rifier la validit\u00e9 des donn\u00e9es saisies. Ceci fait, l'utilisateur va demander la liste des si\u00e8ges obtenus par chacune des listes.</li> <li>la couche [ui] va demander \u00e0 la couche m\u00e9tier de faire le calcul des si\u00e8ges. Pour cela elle va lui transmettre les donn\u00e9es qu'elle a re\u00e7ues de l'utilisateur. C'est l'op\u00e9ration [2].</li> <li>la couche [metier] a besoin de certaines informations pour mener \u00e0 bien son travail. Elle a d\u00e9j\u00e0 les listes depuis l'op\u00e9ration (b). Il lui faut \u00e9galement le nombre de si\u00e8ges \u00e0 pourvoir ainsi que la valeur du seuil \u00e9lectoral. Elle va demander ces informations \u00e0 la couche [dao] avec le chemin [3, 4, 5, 6]. [3] est la demande initiale et [6] la r\u00e9ponse \u00e0 cette demande.</li> <li>ayant toutes les donn\u00e9es dont elle avait besoin, la couche [metier] calcule les si\u00e8ges obtenus par chacune des listes.</li> <li>la couche [metier] peut maintenant r\u00e9pondre \u00e0 la demande de la couche [ui] faite en (d). C'est le chemin [7].</li> <li>la couche [ui] va mettre en forme ces r\u00e9sultats pour les pr\u00e9senter \u00e0 l'utilisateur sous une forme appropri\u00e9e puis les pr\u00e9senter. C'est le chemin [8].</li> <li>on peut imaginer que ces r\u00e9sultats doivent \u00eatre m\u00e9moris\u00e9s dans un fichier ou une base de donn\u00e9es. Cela peut \u00eatre fait de fa\u00e7on automatique. Dans ce cas, apr\u00e8s l'op\u00e9ration (f), la couche [metier] va demander \u00e0 la couche [dao] d'enregistrer les r\u00e9sultats. Ce sera le chemin [3, 4, 5, 6]. Cela peut \u00eatre fait \u00e9galement seulement sur demande de l'utilisateur. Ce sera le chemin [1-8] qui sera utilis\u00e9 par le cycle demande - r\u00e9ponse. On voit dans cette description qu'une couche est amen\u00e9e \u00e0 utiliser les ressources de la couche qui est \u00e0 sa droite, jamais de celle qui est \u00e0 sa gauche. Consid\u00e9rons deux couches contig\u00fces :</li> </ul> <p>La couche [A] fait des demandes \u00e0 la couche [B]. Dans les cas les plus simples, une couche est impl\u00e9ment\u00e9e par une unique classe. Une application \u00e9volue au cours du temps. Ainsi la couche [B] peut avoir des classes d'impl\u00e9mentation diff\u00e9rentes [B1, B2, ...]. Si la couche [B] est la couche [dao], celle-ci peut avoir une premi\u00e8re impl\u00e9mentation [B1] qui va chercher des donn\u00e9es dans un fichier. Quelques ann\u00e9es plus tard, on peut vouloir mettre les donn\u00e9es dans une base de donn\u00e9es.  On va alors construire une seconde classe d'impl\u00e9mentation [B2]. Si dans l'application initiale, la couche [A] travaillait directement avec la classe [B1] on est oblig\u00e9s de r\u00e9\u00e9crire partiellement le code de la couche [A]. Supposons par exemple qu'on ait \u00e9crit dans la couche [A] quelque chose comme suit :</p> <pre><code>B1 b1=new B1(...);\n..\nb1.getData(...);\n</code></pre> <ul> <li>ligne 1 : une instance de la classe [B1] est cr\u00e9\u00e9e</li> <li>ligne 3 : des donn\u00e9es sont demand\u00e9es \u00e0 cette instance Si on suppose, que la nouvelle classe d'impl\u00e9mentation [B2] utilise des m\u00e9thodes de m\u00eame signature que celle de la classe [B1], il faudra changer tous les [B1] en [B2]. Ca, c'est le cas tr\u00e8s favorable et assez improbable si on n'a pas pr\u00eat\u00e9 attention \u00e0 ces signatures de m\u00e9thodes. Dans la pratique, il est fr\u00e9quent que les classes [B1] et [B2] n'aient pas les m\u00eames signatures de m\u00e9thodes et que donc une bonne partie de la couche [A] doive \u00eatre totalement r\u00e9\u00e9crite.</li> </ul> <p>On peut am\u00e9liorer les choses si on met une interface entre les couches [A] et [B]. Cela signifie qu'on fige dans une interface les signatures des m\u00e9thodes pr\u00e9sent\u00e9es par la couche [B] \u00e0 la couche [A]. Le sch\u00e9ma pr\u00e9c\u00e9dent devient alors le suivant :</p> <p>La couche [A] ne s'adresse d\u00e9sormais plus directement \u00e0 la couche [B] mais \u00e0 son interface [IB]. Ainsi dans le code de la couche [A], la classe d'impl\u00e9mentation [Bi] de la couche [B] n'appara\u00eet qu'une fois, au moment de l'impl\u00e9mentation de l'interface [IB]. Ceci fait, c'est l'interface [IB] et non sa classe d'impl\u00e9mentation qui est utilis\u00e9e dans le code. Le code pr\u00e9c\u00e9dent devient celui-ci :</p> <pre><code>IB ib=new B1(...);\n..\nib.getData(...);\n</code></pre> <ul> <li>ligne 1 : une instance [ib] impl\u00e9mentant l'interface [IB] est cr\u00e9\u00e9e par instanciation de la classe [B1]</li> <li>ligne 3 : des donn\u00e9es sont demand\u00e9es \u00e0 l'instance [ib] D\u00e9sormais si on remplace l'impl\u00e9mentation [B1] de la couche [B] par une impl\u00e9mentation [B2], et que ces deux impl\u00e9mentations respectent la m\u00eame interface [IB], alors seule la ligne 1 de la couche [A] doit \u00eatre modifi\u00e9e et aucune autre. C'est un grand avantage qui \u00e0 lui seul justifie l'usage syst\u00e9matique des interfaces entre deux couches.</li> </ul> <p>On peut aller encore plus loin et rendre la couche [A] totalement ind\u00e9pendante de la couche [B]. Dans le code ci-dessus, la ligne 1 pose probl\u00e8me parce qu'elle r\u00e9f\u00e9rence en dur la classe [B1]. L'id\u00e9al serait que la couche [A] puisse disposer d'une impl\u00e9mentation de l'interface [IB] sans avoir \u00e0 nommer de classe. Ce serait coh\u00e9rent avec notre sch\u00e9ma ci-dessus. On y voit que la couche [A] s'adresse \u00e0 l'interface [IB] et on ne voit pas pourquoi elle aurait besoin de conna\u00eetre le nom de la classe qui impl\u00e9mente cette interface. Ce d\u00e9tail n'est pas utile \u00e0 la couche [A].</p> <p>Le framework Spring (http://www.springframework.org) permet d'obtenir ce r\u00e9sultat. L'architecture pr\u00e9c\u00e9dente \u00e9volue de la fa\u00e7on suivante :</p> <p>La couche transversale [Spring] va permettre \u00e0 une couche d'obtenir par configuration une r\u00e9f\u00e9rence sur la couche situ\u00e9e \u00e0 sa droite sans avoir \u00e0 conna\u00eetre le nom de la classe d'impl\u00e9mentation de la couche. Ce nom sera dans les fichiers de configuration et non pas dans le code Java. Le code Java de la couche [A] prend alors la forme suivante :</p> <pre><code>IB ib; // initialis\u00e9 par Spring\n..\nib.getData(...);\n</code></pre> <ul> <li>ligne 1 : une instance [ib] impl\u00e9mentant l'interface [IB] de la couche [B]. Cette instance est cr\u00e9\u00e9e par Spring sur la base d'informations trouv\u00e9es dans un fichier de configuration. Spring va s'occuper de cr\u00e9er :</li> <li>l'instance [b] impl\u00e9mentant la couche [B]</li> <li>l'instance [a] impl\u00e9mentant la couche [A]. Cette instance sera initialis\u00e9e. Le champ [ib] ci-dessus recevra pour valeur la r\u00e9f\u00e9rence [b] de l'objet impl\u00e9mentant la couche [B]</li> <li>ligne 3 : des donn\u00e9es sont demand\u00e9es \u00e0 l'instance [ib] On voit maintenant que, la classe d'impl\u00e9mentation [B1] de la couche B n'appara\u00eet nulle part dans le code de la couche [A]. Lorsque l'impl\u00e9mentation [B1] sera remplac\u00e9e par une nouvelle impl\u00e9mentation [B2], rien ne changera dans le code de la classe [A]. On changera simplement les fichiers de configuration de Spring pour instancier [B2] au lieu de [B1].</li> </ul> <p>Le couple Spring et interfaces Java apporte une am\u00e9lioration d\u00e9cisive \u00e0 la maintenance d'applications en rendant les couches de celles-ci \u00e9tanches entre elles. C'est cette solution que nous utiliserons pour l'application [Elections].</p> <p>Revenons \u00e0 l'architecture trois couches de notre application :</p> <p>Dans les cas simples, on peut partir de la couche [metier] pour d\u00e9couvrir les interfaces de l'application. Pour travailler, elle a besoin de donn\u00e9es :</p> <ul> <li>d\u00e9j\u00e0 disponibles dans des fichiers, bases de donn\u00e9es ou via le r\u00e9seau. Elles sont fournies par la couche [dao].</li> <li> <p>pas encore disponibles. Elles sont alors fournies par la couche [ui] qui les obtient aupr\u00e8s de l'utilisateur de l'application. Quelle interface doit offrir la couche [dao] \u00e0 la couche [metier] ? Quelles sont les interactions possibles entre ces deux couches ? La couche [dao] doit fournir les donn\u00e9es suivantes \u00e0 la couche [metier] :</p> </li> <li> <p>le nombre de si\u00e8ges \u00e0 pourvoir</p> </li> <li>la valeur du seuil \u00e9lectoral au-dessous duquel une liste est \u00e9limin\u00e9e</li> <li>les noms des listes Ces informations sont en effet connues avant l'\u00e9lection et peuvent donc \u00eatre m\u00e9moris\u00e9es. Dans le sens [metier] -&gt; [dao], la couche [metier] peut demander \u00e0 la couche [dao] d'enregistrer le r\u00e9sultat des \u00e9lections, notamment les si\u00e8ges obtenus par les diff\u00e9rentes listes.</li> </ul> <p>Avec ces informations, on pourrait tenter une premi\u00e8re d\u00e9finition de l'interface de la couche [dao] :</p> <pre><code>public interface IElectionsDao {\n\n  public double getSeuilElectoral();\n\n  public int getNbSiegesAPourvoir();\n\n  public ListeElectorale[] getListesElectorales();\n\n  public void setListesElectorales(ListeElectorale[] listesElectorales);\n}\n</code></pre> <ul> <li>ligne 1 : l'interface s'appelle [IElectionsDao]. Elle d\u00e9finit quatre m\u00e9thodes :</li> <li>trois m\u00e9thodes pour lire des donn\u00e9es venant de la source de donn\u00e9es : [getSeuilElectoral,  getNbSiegesAPourvoir,  getListesElectorales]. Ces trois m\u00e9thodes permettront \u00e0 la couche [metier] d'obtenir les donn\u00e9es qui caract\u00e9risent l'\u00e9lection courante.</li> <li>une m\u00e9thode pour \u00e9crire des donn\u00e9es dans la source de donn\u00e9es : [setListesElectorales]. Cette m\u00e9thode permettra \u00e0 la couche [metier] de demander l'enregistrement des r\u00e9sultats qu'elle aura calcul\u00e9s. Revenons \u00e0 l'architecture trois couches de notre application :</li> </ul> <p>Quelle interface la couche [metier] doit-elle pr\u00e9senter \u00e0 la couche [ui] ? Examinons les interactions possibles entre ces deux couches.</p> <ul> <li>la couche [ui] va avoir pour r\u00f4le de demander \u00e0 l'utilisateur les voix des diff\u00e9rentes listes en comp\u00e9tition. Pour cela, elle doit conna\u00eetre le nombre de listes. Elle peut demander ce renseignement \u00e0 la couche [metier] qui peut demander \u00e0 son tour le tableau des listes en comp\u00e9tition \u00e0 la couche [dao]. Si la couche [metier] a ce tableau, autant transf\u00e9rer celui-ci dans la couche [ui]. Celle-ci disposera ainsi des noms des listes et pourra affiner ses messages \u00e0 l'utilisateur en demandant par exemple \"\u00a0Nombre de voix de la liste A\u00a0\".</li> <li>lorsque la couche [ui] aura obtenu les voix de toutes les listes, elle demandera le calcul des si\u00e8ges \u00e0 la couche [metier]. Celle-ci pourra faire ce calcul et rendre le r\u00e9sultat \u00e0 la couche [ui].</li> <li>la couche [ui] pourra alors pr\u00e9senter ces r\u00e9sultats \u00e0 l'utilisateur. Celui-ci pourra \u00e9galement demander leur enregistrement.</li> <li>la couche [ui] peut vouloir par ailleurs pr\u00e9senter des informations compl\u00e9mentaires \u00e0 l'utilisateur, telles que le seuil \u00e9lectoral ou le nombre de si\u00e8ges \u00e0 pourvoir. Avec ces informations, on pourrait tenter une premi\u00e8re d\u00e9finition de l'interface de la couche [metier] : </li> </ul> <pre><code>public interface IElectionsMetier {\n\n    public ListeElectorale[] getListesElectorales();\n\n    public int getNbSiegesAPourvoir();\n\n    public double getSeuilElectoral();\n\n    public void recordResultats(ListeElectorale[] listesElectorales);\n\n    public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n\n}\n</code></pre> <ul> <li>ligne 51: l'interface s'appelle [IElectionsMetier]. Elle d\u00e9finit les m\u00e9thodes suivantes :</li> <li>ligne 3\u00a0: une m\u00e9thode [getListesElectorales] qui permettra \u00e0 la couche [ui] d'obtenir le tableau des listes en comp\u00e9tition\u00a0;</li> <li>ligne 5\u00a0: la m\u00e9thode [getNbSiegesAPourvoir] permet d'obtenir le nombre de si\u00e8ges \u00e0 pourvoir\u00a0;</li> <li>ligne 7\u00a0: la m\u00e9thode [getSeuilElectoral] permet d'obtenir le seuil \u00e9lectoral\u00a0;</li> <li>ligne 11\u00a0: une m\u00e9thode [calculerSieges] (ligne 36) qui permettra \u00e0 la couche [ui] de demander le calcul des si\u00e8ges une fois que les nombres  de voix des diff\u00e9rentes listes seront connus. Le param\u00e8tre est le tableau des listes en comp\u00e9tition, sans leurs si\u00e8ges et sans le bool\u00e9en \u00e9limin\u00e9. Le r\u00e9sultat rendu est ce m\u00eame tableau avec cette fois les champs [si\u00e8ges, elimine] initialis\u00e9s\u00a0;</li> <li>ligne 9\u00a0: une m\u00e9thode [recordResultats]  qui permettra \u00e0 la couche [ui] de demander l'enregistrement des r\u00e9sultats. Note\u00a0: de par sa position, la couche [m\u00e9tier] reprend certaines des m\u00e9thodes de la couche [DAO] pour les offrir \u00e0 la couche [UI]. A cause de cette redondance, on peut \u00eatre tent\u00e9 de tout regrouper dans une unique couche qui regrouperait et le m\u00e9tier et l'acc\u00e8s aux donn\u00e9es. Cette unique couche est parfois appel\u00e9e le mod\u00e8le, le M du sigle MVC (Mod\u00e8le - Vue - Contr\u00f4leur). MVC est un mod\u00e8le de conception (design pattern) r\u00e9pandu dans les applications web.</li> </ul> <p>Examinons la signature de la m\u00e9thode [calculerSieges]\u00a0:</p> <pre><code>public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n</code></pre> <p>Il a \u00e9t\u00e9 \u00e9crit plus haut\u00a0: \u00ab\u00a0Le param\u00e8tre est le tableau des listes en comp\u00e9tition, sans leurs si\u00e8ges et sans le bool\u00e9en \u00e9limin\u00e9. Le r\u00e9sultat est ce m\u00eame tableau avec cette fois les champs [si\u00e8ges, elimine]\u00a0\u00bb. La signature de la m\u00e9thode pourrait \u00eatre \u00e9galement la suivante\u00a0:</p> <pre><code>public void calculerSieges(ListeElectorale[] listesElectorales);\n</code></pre> <p>Le param\u00e8tre [listesElectorales] est une r\u00e9f\u00e9rence d'objet, ici un tableau. Chaque \u00e9l\u00e9ment est \u00e0 son tour une r\u00e9f\u00e9rence d'objet, ici un type [ListeElectorale]. La m\u00e9thode [calculerSieges] va changer les champs [sieges, elimine] de chacun de ces objets. La m\u00e9thode appelante d\u00e9tient un pointeur [listesElectorales] qui\u00a0:</p> <ul> <li>avant l'appel, est la r\u00e9f\u00e9rence d'un tableau d'objets [ListeElectorale] ayant ses champs [sieges, elimine] non initialis\u00e9s\u00a0;</li> <li>apr\u00e8s l'appel, est la r\u00e9f\u00e9rence (la m\u00eame) d'un tableau d'objets [ListeElectorale] ayant ses champs [sieges, elimine] initialis\u00e9s\u00a0; Alors pourquoi utiliser la signature\u00a0:</li> </ul> <pre><code>public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n</code></pre> <p>Lorsqu'on \u00e9crit une interface, il est bon de se rappeler qu'elle peut \u00eatre utilis\u00e9e dans deux contextes diff\u00e9rents : local et distant. Dans le contexte local, la m\u00e9thode appelante et la m\u00e9thode appel\u00e9e sont ex\u00e9cut\u00e9es dans la m\u00eame JVM (Java Virtual Machine) :</p> <p>Si la couche [ui] fait appel \u00e0 la m\u00e9thode calculerSieges de la couche [DAO], elle a bien une r\u00e9f\u00e9rence sur le param\u00e8tre [ListeElectorale[] listesElectorales] qu'elle passe \u00e0 la m\u00e9thode.</p> <p>Dans le contexte distant, la m\u00e9thode appelante et la m\u00e9thode appel\u00e9e sont ex\u00e9cut\u00e9es dans des JVM diff\u00e9rentes :</p> <p>Ci-dessus, la couche [ui] s'ex\u00e9cute dans la JVM 1 et la couche [m\u00e9tier] dans la JVM 2 sur deux machines diff\u00e9rentes. Les deux couches ne communiquent pas directement. Entre-elles  s'intercale une couche qu'on appellera couche de communication [1]. Celle-ci est compos\u00e9e d'une couche d'\u00e9mission [2] et d'une couche de r\u00e9ception [3]. Le d\u00e9veloppeur n'a en g\u00e9n\u00e9ral pas \u00e0 \u00e9crire ces couches de communication. Elles sont g\u00e9n\u00e9r\u00e9es automatiquement par des outils logiciels. La couche [metier] est \u00e9crite comme si elle s'ex\u00e9cutait dans la m\u00eame JVM que la couche [DAO]. Il n'y a donc aucune modification de code.</p> <p>Le m\u00e9canisme de communication entre la couche [ui] et la couche [m\u00e9tier] est le suivant :</p> <ul> <li>la couche [ui] fait appel \u00e0 la m\u00e9thode calculerSieges de la couche [m\u00e9tier] en lui passant le param\u00e8tre [ListeElectorale[] listesElectorales1]\u00a0;</li> <li>ce param\u00e8tre est en fait pass\u00e9 \u00e0 la couche d'\u00e9mission [2]. Celle-ci va transmettre sur le r\u00e9seau, la valeur du param\u00e8tre listesElectorales1 et non sa r\u00e9f\u00e9rence. La forme exacte de cette valeur d\u00e9pend du protocole de communication utilis\u00e9\u00a0;</li> <li>la couche de r\u00e9ception [3] va r\u00e9cup\u00e9rer cette valeur et reconstruire \u00e0 partir d'elle un objet [ListeElectorale[] listesElectorales2] image du param\u00e8tre initial envoy\u00e9 par la couche [metier]. On a maintenant deux objets identiques (au sens de contenu) dans deux JVM diff\u00e9rentes : listesElectorales1 et listesElectorales2.</li> <li> <p>la couche de r\u00e9ception va passer l'objet listesElectorales2 \u00e0 la m\u00e9thode calculerSieges de la couche [m\u00e9tier]\u00a0; qui va le persister en base de donn\u00e9es. Apr\u00e8s cette op\u00e9ration, la r\u00e9f\u00e9rence listesElectorales2 pointe sur un tableau d'objets [ListeElectorale] ayant leurs champs [sieges, elimine] initialis\u00e9s. . Ce n'est pas le cas de l'objet listesElectorales1 sur lequel la couche [ui] a une r\u00e9f\u00e9rence. Si on veut que la couche [ui] ait une r\u00e9f\u00e9rence sur l'objet listesElectorales2, il faut lui envoyer celui-ci. Aussi est-on amen\u00e9s \u00e0 utiliser la signature suivante pour la m\u00e9thode [calculerSieges]\u00a0: <pre><code>public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n</code></pre></p> </li> <li> <p>avec cette signature, la m\u00e9thode calculerSieges va rendre comme r\u00e9sultat la r\u00e9f\u00e9rence listesElectorales2. Ce r\u00e9sultat est rendu \u00e0 la couche de r\u00e9ception [3] qui avait appel\u00e9 la couche [m\u00e9tier]. Celle-ci va rendre la valeur (et non la r\u00e9f\u00e9rence) de listesElectorales2 \u00e0 la couche d'\u00e9mission [2]\u00a0;</p> </li> <li>la couche d'\u00e9mission [2] va r\u00e9cup\u00e9rer cette valeur et reconstruire \u00e0 partir d'elle un objet [ListeElectorale[] listesElectorales3] image du r\u00e9sultat rendu par la m\u00e9thode calculerSieges de la couche [m\u00e9tier].</li> <li> <p>l'objet [ListeElectorale[] listesElectorales3] est rendu \u00e0 la m\u00e9thode de la couche [ui] dont l'appel \u00e0 la m\u00e9thode calculerSieges de la couche [DAO] avait initi\u00e9 tout ce m\u00e9canisme\u00a0; Dans ce processus, des objets de type [ListeElectorale] vont transiter entre les couches [2] et [3]\u00a0:</p> </li> <li> <p>lorsque la couche [2] transmet la valeur d'un objet [ListeElectorale] \u00e0 la couche [3], on dit que l'objet est s\u00e9rialis\u00e9. La forme exacte de cette s\u00e9rialisation d\u00e9pend du protocole de communication utilis\u00e9\u00a0;</p> </li> <li>lorsque la couche [3] r\u00e9cup\u00e8re la valeur d'un objet [ListeElectorale] afin de cr\u00e9er de nouveau un objet [ListeElectorale], on dit que l'objet est d\u00e9s\u00e9rialis\u00e9\u00a0; Pour qu'un objet puisse subir cette s\u00e9rialisation / d\u00e9s\u00e9rialisation, certains protocoles exigent que l'objet impl\u00e9mente l'interface [Serializable]. Cette interface est juste un marqueur. Il n'y a pas de m\u00e9thodes \u00e0 impl\u00e9menter. Aussi la classe [ListeElectorale] sera-t-elle d\u00e9sormais d\u00e9clar\u00e9e de la fa\u00e7on suivante\u00a0:</li> </ul> <pre><code>public abstract class ListeElectorale implements Serializable {\n    private static final long serialVersionUID = 1L;\n</code></pre> <ul> <li>le champ de la ligne 2 est impos\u00e9. On peut le conserver tel quel et l'utiliser pour toute classe de type [Serializable].</li> </ul>"},{"location":"td-architectures-en-couches.html#43-la-classe-dexception","title":"4.3. La classe d'exception","text":"<p>Revenons \u00e0 l'interface de la couche [DAO]\u00a0:</p> <pre><code>public interface IElectionsDao {\n\n  public double getSeuilElectoral();\n\n  public int getNbSiegesAPourvoir();\n\n  public ListeElectorale[] getListesElectorales();\n\n  public void setListesElectorales(ListeElectorale[] listesElectorales);\n}\n</code></pre> <p>Ces m\u00e9thodes travaillent avec une base de donn\u00e9es et peuvent rencontrer diverses erreurs, par exemple un SGBD non disponible. Lorsqu'on \u00e9crit une m\u00e9thode, il faut toujours pr\u00e9voir les cas d'erreur. Celles-ci sont signal\u00e9es classiquement par une exception. Nous avons d\u00e9j\u00e0 rencontr\u00e9 la classe [ElectionsException] au paragraphe 3.3, page 22. Nous allons continuer \u00e0 l'utiliser mais en l'enrichissant de la fa\u00e7on suivante\u00a0:</p> <pre><code>package ...;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// classe d'exception pour l'application Elections\n// l'exception est non contr\u00f4l\u00e9e\n\npublic class ElectionsException extends RuntimeException implements Serializable {\n\n    // serial ID\n    private static final long serialVersionUID = 1L;\n\n    // champs locaux\n    private int code;\n    private List&lt;String&gt; erreurs;\n\n    // constructeurs\n    public ElectionsException() {\n        super();\n    }\n\n    public ElectionsException(int code, Throwable e) {\n        // parent\n        super(e);\n        // local\n        this.code = code;\n        this.erreurs = getErreursForException(e);\n    }\n\n    public ElectionsException(int code, String message, Throwable e) {\n        // parent\n        super(message,e);\n        // local\n        this.code = code;\n        this.erreurs = getErreursForException(e);\n    }\n\n    public ElectionsException(int code, String message) {\n        // parent\n        super(message);\n        // local\n        this.code = code;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        erreurs.add(message);\n        this.erreurs = erreurs;\n    }\n\n    public ElectionsException(int code, List&lt;String&gt; erreurs) {\n        // parent\n        super();\n        // local\n        this.code = code;\n        this.erreurs = erreurs;\n    }\n\n    // liste des messages d'erreur d'une exception\n    private List&lt;String&gt; getErreursForException(Throwable th) {\n        // on r\u00e9cup\u00e8re la liste des messages d'erreur de l'exception\n        Throwable cause = th;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        while (cause != null) {\n            // on r\u00e9cup\u00e8re le message seulement s'il est !=null et non blanc\n            String message = cause.getMessage();\n            if (message != null) {\n                message = message.trim();\n                if (message.length() != 0) {\n                    erreurs.add(message);\n                }\n            }\n            // cause suivante\n            cause = cause.getCause();\n        }\n        return erreurs;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>lignes 16-17\u00a0: le type [ElectionsException] encapsule\u00a0:</li> <li>un code d'erreur, ligne 16\u00a0;</li> <li> <p>une liste de messages d'erreur, ligne 17\u00a0; La classe supporte cinq constructeurs\u00a0:</p> </li> <li> <p>ligne 20\u00a0: ElectionsException()</p> </li> <li>ligne 24\u00a0: ElectionsException(int code, Throwable e)\u00a0: le second param\u00e8tre est un type [Throwable] qui est la classe parente de la classe [Exception]. Ce constructeur permet d'encapsuler l'exception e avec un code d'erreur. Le type [Throwable] (et donc le type Exception) permet d'encapsuler une ou plusieurs exceptions. L'id\u00e9e est\u00a0:</li> <li>d'arr\u00eater (catch) une exception qui se produit\u00a0;</li> <li>de l'enrichir d'un message en l'encapsulant dans une nouvelle exception\u00a0;</li> <li>de relancer la nouvelle exception\u00a0; <pre><code>try{\n...\n}catch (Exception1 e1){\n   throw new Exception2(\u00abun message\u00bb,e1);\n}\n</code></pre></li> </ul> <p>L'encapsulation a lieu ligne 34 par l'instruction [super(message,e)]. Ce processus d'encapsulation peut \u00eatre r\u00e9p\u00e9t\u00e9 et l'exception initiale enrichie de diff\u00e9rents messages. On dit alors qu'on a une pile d'exceptions. La m\u00e9thode [private List&lt;String&gt; getErreursForException(Throwable th)] permet d'obtenir les diff\u00e9rents messages associ\u00e9s aux exceptions encapsul\u00e9es\u00a0:</p> <ul> <li>l'exception encapsul\u00e9e est obtenue par la m\u00e9thode Throwable [Throwable].getCause()\u00a0;</li> <li>le message associ\u00e9 \u00e0 une exception est la m\u00e9thode String [Throwable].getMessage()\u00a0;</li> <li>lignes 28-29\u00a0: on construit les champs [code, erreurs]\u00a0;</li> <li>ligne 32\u00a0: public ElectionsException(int code, String message, Throwable e)\u00a0: ce constructeur est analogue au pr\u00e9c\u00e9dent, si ce n'est qu'il enrichit l'exception qu'il va encapsuler et d'un code et d'un message\u00a0;</li> <li>ligne 40\u00a0: public ElectionsException(int code, String message)\u00a0: constructeur sans encapsulation d'exception\u00a0;</li> <li>ligne 50\u00a0: public ElectionsException(int code, List&lt;String&gt; erreurs)\u00a0: constructeur sans encapsulation d'exception, ni mesage\u00a0; La classe [ElectionsException] pourra \u00eatre utilis\u00e9e de la fa\u00e7on suivante\u00a0:</li> </ul> <pre><code>try{\n...\n}catch (Exception1 e1){\n   throw new ElectionsException(un_code,un_message,e1);\n}\n</code></pre> <p>o\u00f9 le message sera ou non pr\u00e9sent. Une fois cr\u00e9\u00e9e, l'exception [ElectionsException] n'a pas vocation \u00e0 encapsuler de nouvelles exceptions. Ci-dessus, elle encapsule l'exception e1 et les exceptions que e1 encapsule. Il n'y a ensuite, plus de nouvelles encapsulations.</p> <p>La classe [ElectionsException] pourra \u00eatre \u00e9galement utilis\u00e9e de la fa\u00e7on suivante\u00a0:</p> <pre><code>// code susceptible de rencontrer un cas d'erreur (mais pas sous la forme d'une exception)\n...\nif(erreur){\n    throw new ElectionsException(un_code,un_message);\n}\n</code></pre>"},{"location":"td-classes.html","title":"3. [TD]\u00a0: Classes","text":"<p>Mots cl\u00e9s : classe, interface, h\u00e9ritage, exception, polymorphisme</p> <p>Lectures conseill\u00e9es :</p> <ul> <li>paragraphes 2.1, 2.2, 2.4 et 2.7 du chapitre 2 de [ref1] : Classes et interfaces</li> <li>paragraphes 3.3 (classe String), 3.5 (classe ArrayList), 3.6 (classe Arrays) Dans la partie 1 de l'exercice ELECTIONS aucune classe n'a \u00e9t\u00e9 utilis\u00e9e. On a construit une solution comme on l'aurait construite en langage C. Nous introduisons maintenant la notion de classe Java.</li> </ul>"},{"location":"td-classes.html#31-support","title":"3.1. Support","text":"<p>Le dossier [support / chap-03] contient le projet Eclipse de ce chapitre.</p> <p>On travaillera d\u00e9sormais avec le JDK 1.8 car certains des projets \u00e0 suivre n\u00e9cessitent ce JDK. Pour conna\u00eetre le JDK utilis\u00e9, proc\u00e9dez de la fa\u00e7on suivante\u00a0:</p> <ul> <li>en [4], le JRE (Java Runtime Environment) utilis\u00e9. Ce JRE est en fait ici un JDK (Java Development Kit), ici [jdk1.8.0_60]. Si ce n'est pas un JDK ou si vous avez une version inf\u00e9rieure \u00e0 1.8, proc\u00e9dez comme suit [5-21]\u00a0;</li> </ul> <ul> <li>en [8], le JRE utilis\u00e9 actuellement par d\u00e9faut par Eclipse\u00a0;</li> <li>en [11], les diff\u00e9rents JDK et JRE actuellement connus par Eclipse\u00a0;</li> </ul> <ul> <li>en [15], choisissez un JDK plut\u00f4t qu'un JRE. Ce document utilise des projets Maven qui ont besoin d'un JDK\u00a0;</li> </ul> <ul> <li>en [21], on a un JDK de version &gt;=1.8\u00a0;</li> <li>en [22-23], acc\u00e9dez aux facets (diff\u00e9rentes vues d'un m\u00eame projet Eclipse) du projet\u00a0;</li> </ul> <ul> <li>en [24], v\u00e9rifiez que vous utilisez une version Java &gt;=1.8\u00a0;</li> </ul>"},{"location":"td-classes.html#32-la-classe-listeelectorale","title":"3.2. La classe [ListeElectorale]","text":"<p>En langage C, nous aurions probablement utilis\u00e9 une structure pour repr\u00e9senter une liste participant \u00e0 l'\u00e9lection. Elle aurait pu \u00eatre de la forme suivante :</p> <pre><code>struct t_liste\n   {\n     char nom[15];\n     long voix;\n     int  elimine;\n     int sieges;\n   };\n</code></pre> <p>La notion de structure n'existe pas dans le langage Java. Il faut la remplacer par celle de classe. On d\u00e9cide donc de cr\u00e9er une classe pour m\u00e9moriser les informations sur une liste candidate. Celle-ci aurait le squelette suivant :</p> <pre><code>package istia.st.elections;\n\npublic class ListeElectorale {\n\n    /**\n     * identit\u00e9 de la liste\n     */\n    private int id;\n\n    /**\n     * nom de la liste\n     */\n    private String nom;\n    /**\n     * nombre de voix de la liste\n     */\n    private int voix;\n    /**\n     * nombre de si\u00e8ges de la liste\n     */\n    private int sieges;\n    /**\n     * indique si la liste est \u00e9limin\u00e9e ou non\n     */\n    private boolean elimine;\n\n    /**\n     * constructeur par d\u00e9faut\n     */\n    public ListeElectorale() {\n    }\n\n    /**\n     *\n     * @param nom String : le nom de la liste\n     * @param voix int : son nombre de voix\n     * @param sieges int : son nombre de sieges\n     * @param elimine boolean : son \u00e9tat \u00e9limin\u00e9 ou non\n     */\n    public ListeElectorale(int id,String nom, int voix, int sieges, boolean elimine) {\n...\n    }\n\n    /**\n     *\n     * @return int : l'identifiant de la liste\n     */\n    public int getId() {\n...\n    }\n\n    /**\n     * initialise l'identifiant de liste\n     * @param id int : identifiant de la liste\n     * @throws ElectionsException si id&lt;1\n     */\n    public void setId(int id) {\n...\n    }\n\n    /**\n     *\n     * @return String : le nom de la liste\n     */\n    public String getNom() {\n...\n    }\n\n    /**\n     * initialise le nom de la liste\n     * @param nom String : nom de la liste\n     *  @throws ElectionsException si le nom est vide ou blanc\n     */\n    public void setNom(String nom) {\n...\n    }\n\n    /**\n     *\n     * @return int : le nombre de voix de la liste\n     */\n    public int getVoix() {\n ...\n    }\n\n    /**\n     * initialise le nombre de voix de la liste\n     * @param voix int : le nombre de voix de la liste\n     */\n    public void setVoix(int voix) {\n ...\n    }\n\n    /**\n     *\n     * @return int : le nombre de si\u00e8ges de la liste\n     */\n    public int getSieges() {\n ...\n    }\n\n    /**\n     * fixe le nombre de si\u00e8ges de la liste\n     * @param sieges int : le nombre de si\u00e8ges de la liste\n     */\n    public void setSieges(int sieges) {\n...\n    }\n\n    /**\n     *\n     * @return boolean : valeur du champ elimine\n     */\n    public boolean isElimine() {\n  ...\n    }\n\n    /**\n     *\n     * @param sieges int\n     */\n    public void setElimine(boolean elimine) {\n ...\n    }\n\n    /**\n     *\n     * @return String : identit\u00e9 de la liste \u00e9lectorale\n     */\n    public String toString() {\n   ...\n    }\n}\n</code></pre> <ul> <li>ligne 8 : n\u00b0 identifiant une liste de fa\u00e7on unique. N'est pas indispensable ici mais est pr\u00e9vu pour une utilisation future.</li> <li>ligne 13 : le nom de la liste.</li> <li>ligne 17 : le nombre de voix de la liste</li> <li>ligne 21 : le nombre de si\u00e8ges de la liste</li> <li> <p>ligne 25 : bool\u00e9en indiquant si la liste est \u00e9limin\u00e9e (pourcentage de voix obtenues au-dessous du seuil \u00e9lectoral) ou non. Chaque champ priv\u00e9 nomm\u00e9 [xyz] peut \u00eatre initialis\u00e9 par une m\u00e9thode nomm\u00e9e [setXyz]. La m\u00e9thode [getXyz] permet elle d'obtenir la valeur du champ priv\u00e9 [xyz]. Dans le cas particulier o\u00f9 [xyz] est un champ de type bool\u00e9en, la m\u00e9thode [getXyz] peut \u00eatre remplac\u00e9e par la m\u00e9thode [isXyz]. Le nommage particulier de ces m\u00e9thodes ob\u00e9it \u00e0 une norme de codage appel\u00e9e norme JavaBean. Ainsi nous d\u00e9finissons les m\u00e9thodes publiques suivantes :</p> </li> <li> <p>getId (ligne 48), setId (ligne 57)</p> </li> <li>getNom (ligne 65), setNom (ligne 74)</li> <li>getVoix (ligne 82), setVoix (ligne 90)</li> <li>getSieges (ligne 98), setSieges (ligne 106)</li> <li>isElimine (ligne 114), setElimine (ligne 122)</li> <li>lignes 30-31 : d\u00e9finissent un constructeur sans param\u00e8tres. Celui-ci permet de cr\u00e9er un objet [ListeElectorale] sans l'initialiser. Celui-ci peut ensuite \u00eatre initialis\u00e9 gr\u00e2ce aux m\u00e9thodes set.</li> <li>lignes 40-42 : d\u00e9finissent un constructeur permettant de cr\u00e9er un objet [ListeElectorale]  tout en initialisant ses cinq champs priv\u00e9s.</li> <li>ligne 130-132 : d\u00e9finissent la m\u00e9thode [toString] qui rend une cha\u00eene de caract\u00e8res donnant les valeurs des cinq champs de l'objet. Un programme de test de la classe ListeElectorale pourrait \u00eatre le suivant :</li> </ul> <pre><code>package istia.st.elections.tests;\n\nimport istia.st.elections.ListeElectorale;\n\npublic class MainTest1ListeElectorale {\n    public static void main(String[] args) {\n        // cr\u00e9ation d'une liste \u00e9lectorale\n        ListeElectorale listeElectorale1 = new ListeElectorale(1, \"A\", 32000,\n                0, false);\n        // affichage identit\u00e9 liste\n        System.out.println(\"listeElectorale1=\" + listeElectorale1);\n        // modification du nombre de si\u00e8ges\n        listeElectorale1.setSieges(2);\n        // affichage identit\u00e9 liste 1\n        System.out.println(\"listeElectorale1=\" + listeElectorale1);\n        // une nouvelle liste \u00e9lectorale\n        ListeElectorale listeElectorale2 = listeElectorale1;\n        // affichage identit\u00e9 liste 2\n        System.out.println(\"listeElectorale2=\" + listeElectorale2);\n        // modification du nombre de si\u00e8ges\n        listeElectorale2.setSieges(3);\n        // affichage identit\u00e9 des 2 listes\n        System.out.println(\"listeElectorale2=\" + listeElectorale2);\n        System.out.println(\"listeElectorale1=\" + listeElectorale1);\n    }\n}\n</code></pre> <p>L'environnement Eclipse de ce test pourrait \u00eatre le suivant :</p> <ul> <li>[1] : le projet s'appelle [elections-02A]</li> <li>[2] : l'application sera plac\u00e9e dans un paquetage, ici [istia.st.elections]</li> <li>[3] : [ListeElectorale.java] est le code source de la classe [ListeElectorale]</li> <li>[4] : les classes de test seront plac\u00e9es dans un paquetage, ici [istia.st.elections.tests]</li> <li>[5] : la classe de test [MainTest1ListeElectorale] L'affichage \u00e9cran obtenu apr\u00e8s ex\u00e9cution du programme ci-dessus est le suivant :</li> </ul> <p></p> <p>Travail \u00e0 faire : en vous aidant de ce qui pr\u00e9c\u00e8de, compl\u00e9tez le code de la classe ListeElectorale.</p>"},{"location":"td-classes.html#33-creation-dune-classe-dexception-electionsexception","title":"3.3. Cr\u00e9ation d'une classe d'exception [ElectionsException]","text":"<p>Parmi les diff\u00e9rentes classes d'exception du langage Java, il en est une appel\u00e9e [RuntimeException]. Cette classe d\u00e9rive de la classe [Exception], racine de toutes les classes d'exception. La particularit\u00e9 des instances de [RuntimeException] ou instances d\u00e9riv\u00e9es est que l'on n'est pas oblig\u00e9 de les d\u00e9clarer ou de les g\u00e9rer. On les appelle des exceptions non contr\u00f4l\u00e9es.</p> <p>Prenons un premier exemple. La classe [BufferedReader] est une classe dont les instances permettent de lire des lignes de texte dans un flux de donn\u00e9es. Elle poss\u00e8de une m\u00e9thode [readLine] dont la signature est la suivante :</p> <pre><code>public String readLine()throws IOException\n</code></pre> <p>On voit que la m\u00e9thode peut lancer une exception de type [IOException]. L'arborescence de cette classe est la suivante :</p> <pre><code>java.lang.Object\n  java.lang.Throwable\n      java.lang.Exception\n          java.io.IOException\n</code></pre> <p>La classe [IOException] d\u00e9rive de la classe [Exception] (ligne 3). Le compilateur nous force \u00e0 g\u00e9rer et \u00e0 d\u00e9clarer les exceptions de type [java.lang.Exception] ou d\u00e9riv\u00e9 (sauf pour la branche [RuntimeException] que nous allons pr\u00e9senter plus loin). Ainsi, pour lire une ligne de texte tap\u00e9e au clavier, on sera oblig\u00e9 d'\u00e9crire quelque chose comme :</p> <pre><code>BufferedReader clavier=....;\nString ligne=null;\ntry{\n    ligne=clavier.readLine();\n}catch (IOException ex){\n    // g\u00e9rer l'exception\n    ....\n}\n</code></pre> <p>Prenons un autre exemple. Pour transformer une cha\u00eene en entier on peut utiliser la m\u00e9thode statique [Integer.parseInt] dont la signature est la suivante :</p> <pre><code>public static int parseInt(String s) throws NumberFormatException\n</code></pre> <p>L'argument [s] est la cha\u00eene de caract\u00e8res \u00e0 transformer en entier. On voit que la m\u00e9thode peut lancer une exception de type [NumberFormatException]. L'arborescence de cette classe est la suivante :</p> <pre><code>java.lang.Object\n  java.lang.Throwable\n      java.lang.Exception\n          java.lang.RuntimeException\n              java.lang.IllegalArgumentException\n                  java.lang.NumberFormatException\n</code></pre> <p>La classe [NumberFormatException] d\u00e9rive de la classe [RuntimeException] (ligne 4). Le compilateur ne nous force pas \u00e0 g\u00e9rer et \u00e0 d\u00e9clarer les exceptions de type [java.lang.RuntimeException] ou d\u00e9riv\u00e9. Ainsi, on pourra \u00e9crire quelque chose comme :</p> <pre><code>BufferedReader clavier=....;\nString ligne=null;\ntry{\n    ligne=clavier.readLine();\n}catch (IOException ex){\n    // g\u00e9rer l'exception\n    ....\n}\nint age=Integer.parseInt(ligne);\n</code></pre> <p>Nous ne sommes pas oblig\u00e9s de mettre une clause [try - catch] pour g\u00e9rer l'\u00e9ventuelle exception g\u00e9n\u00e9r\u00e9e par [Integer.parseInt] (ligne 9).</p> <p>Il y a des avantages et inconv\u00e9nients \u00e0 cr\u00e9er et utiliser des classes d'exception d\u00e9riv\u00e9es de [RuntimeException] :</p> <ul> <li>au chapitre des avantages : le code est plus l\u00e9ger</li> <li>au chapitre des inconv\u00e9nients : on peut \u00eatre ramen\u00e9 aux m\u00e9thodes du C o\u00f9 chaque fonction rend un code d'erreur que peu de gens utilisent, justement pour avoir un code plus l\u00e9ger. Lorsqu'une telle erreur non g\u00e9r\u00e9e se produit, le programme plante, g\u00e9n\u00e9ralement de fa\u00e7on peu \u00e9l\u00e9gante. Nous d\u00e9cidons de cr\u00e9er une classe sp\u00e9ciale regroupant toutes les exceptions pouvant survenir dans notre application ELECTIONS. Elle s'appellera [ElectionsException] et d\u00e9rivera de la classe [RuntimeException]. Son code est le suivant :</li> </ul> <pre><code>package istia.st.elections;\n\npublic class ElectionsException extends RuntimeException {\n    private static final long serialVersionUID = 1L;\n\n    public ElectionsException() {\n        super();\n    }\n\n    public ElectionsException(String message) {\n        super(message);\n    }\n\n    public ElectionsException(Throwable cause) {\n        super(cause);\n    }\n\n    public ElectionsException(String message, Throwable cause) {\n        super(message, cause);\n    }\n}\n</code></pre> <ul> <li>ligne 1 : nous pla\u00e7ons la classe dans le paquetage [istia.st.elections]\u00a0;</li> <li>ligne 3 : la classe d\u00e9rive de [RuntimeException]. Elle est donc non contr\u00f4l\u00e9e\u00a0;</li> <li>ligne 4\u00a0: un identifiant de s\u00e9rialisation qu'on peut ignorer pour le moment\u00a0;</li> <li>nous utiliserons dans notre application deux sortes de constructeur :</li> <li>celui classique des lignes 15-17 comme ci-dessous : <pre><code>throw new ElectionsException(\"Le nombre de si\u00e8ges doit \u00eatre &gt;0\")\n</code></pre></li> </ul> <p>Dans ce cas, la m\u00e9thode qui appelle une m\u00e9thode lan\u00e7ant une telle exception peut la g\u00e9rer comme suit :</p> <pre><code>        // test exception\n        try {\n            listeElectorale2.setSieges(-3);\n        } catch (ElectionsException ex) {\n            System.err.println(\"L'exception suivante s'est produite : [\"\n                    + ex.toString() + \"]\");\n        }\n</code></pre> <ul> <li>ou celui des lignes 14-20 destin\u00e9 \u00e0 faire remonter une exception d\u00e9j\u00e0 survenue, en l'encapsulant dans une exception de type [ElectionsException] : <pre><code>    try {\n        ...;\n        } catch (SQLException ex) {\n            // on encapsule l'exception\n            throw new ElectionsException(\"erreur de fermeture de la connexion \u00e0 la BD\",ex);\n        }\n</code></pre></li> </ul> <p>Cette seconde m\u00e9thode a l'avantage de conserver l'information que peut contenir la premi\u00e8re exception. Dans ce cas, la m\u00e9thode qui appelle une m\u00e9thode lan\u00e7ant une telle exception peut la g\u00e9rer comme suit :</p> <pre><code>        try {\n            ...;\n        } catch (ElectionsException ex) {\n            System.out.println(ex.getMessage() + \", Cause : \"+ ex.getCause().getMessage());\n            System.exit(1);\n        }\n</code></pre> <p>Travail \u00e0 faire : reprenez le code de la classe ListeElectorale de fa\u00e7on \u00e0 ce que les m\u00e9thodes set lancent une exception de type [ElectionsException] si l'initialisation demand\u00e9e est incorrecte, comme par exemple initialiser le nom avec une cha\u00eene vide.</p> <p>Le projet Eclipse de test de cette nouvelle version pourrait \u00eatre le suivant :</p> <ul> <li>[1] : le projet s'appelle [elections-02B]</li> <li>[2] : l'application est plac\u00e9e dans un paquetage, ici [istia.st.elections]</li> <li>[3] : les classes [ListeElectorale] et [ElectionsException]</li> <li>[4] : les classes de test sont plac\u00e9es dans un paquetage, ici [istia.st.elections.tests]</li> <li>[5] : la classe de test [MainTest1ListeElectorale] La classe de test [MainTest1ListeElectorale] d\u00e9j\u00e0 \u00e9tudi\u00e9e est l\u00e9g\u00e8rement modifi\u00e9e pour tester les cas d'exception :</li> </ul> <pre><code>package istia.st.elections.tests;\n\nimport istia.st.elections.ElectionsException;\nimport istia.st.elections.ListeElectorale;\n\npublic class MainTest1ListeElectorale {\n    public static void main(String[] args) {\n        // cr\u00e9ation d'une liste \u00e9lectorale\n        ListeElectorale listeElectorale1 = new ListeElectorale(1, \"A\", 32000,\n                0, false);\n        // affichage identit\u00e9 liste\n        System.out.println(\"listeElectorale1=\" + listeElectorale1);\n        // modification du nombre de si\u00e8ges\n        listeElectorale1.setSieges(2);\n        // affichage identit\u00e9 liste 1\n        System.out.println(\"listeElectorale1=\" + listeElectorale1);\n        // une nouvelle liste \u00e9lectorale\n        ListeElectorale listeElectorale2 = listeElectorale1;\n        // affichage identit\u00e9 liste 2\n        System.out.println(\"listeElectorale2=\" + listeElectorale2);\n        // modification du nombre de si\u00e8ges\n        listeElectorale2.setSieges(3);\n        // affichage identit\u00e9 des 2 listes\n        System.out.println(\"listeElectorale2=\" + listeElectorale2);\n        System.out.println(\"listeElectorale1=\" + listeElectorale1);\n        // test exception\n        try {\n            listeElectorale2.setSieges(-3);\n        } catch (ElectionsException ex) {\n            System.err.println(\"L'exception suivante s'est produite : [\"\n                    + ex.toString() + \"]\");\n        }\n\n    }\n}\n</code></pre> <ul> <li>ligne 28 : on essaie d'initialiser le nombre de si\u00e8ges avec une valeur interdite</li> <li>ligne 30 : s'il y a exception, elle est affich\u00e9e L'ex\u00e9cution du test donne les r\u00e9sultats suivants :</li> </ul> <p></p> <p>On remarque que la classe [ListeElectorale] a bien g\u00e9n\u00e9r\u00e9 une exception lorsqu'on a voulu initialiser le nombre de si\u00e8ges avec une valeur invalide (ligne 28 du code).</p>"},{"location":"td-classes.html#34-une-classe-de-test-unitaire","title":"3.4. Une classe de test unitaire","text":"<p>Le type de test pr\u00e9c\u00e9dent repose sur une v\u00e9rification visuelle. On v\u00e9rifie qu'on obtient \u00e0 l'\u00e9cran ce qui est attendu. C'est une m\u00e9thode \u00e0 d\u00e9conseiller en milieu professionnel. Les tests doivent toujours \u00eatre automatis\u00e9s au maximum et viser \u00e0 ne n\u00e9cessiter aucune intervention humaine. L'\u00eatre humain est en effet sujet \u00e0 la fatigue et sa capacit\u00e9 \u00e0 v\u00e9rifier des tests s'\u00e9mousse au fil de la journ\u00e9e.</p> <p>Une application \u00e9volue au fil du temps. A chaque \u00e9volution, on doit v\u00e9rifier que l'application ne \"r\u00e9gresse\" pas, c.a.d. qu'elle continue \u00e0 passer les tests de bon fonctionnement qui avaient \u00e9t\u00e9 faits lors de son \u00e9criture initiale. On appelle ces tests, des tests de \"non r\u00e9gression\". Une application un peu importante peut n\u00e9cessiter des centaines de tests. On teste en effet chaque m\u00e9thode de chaque classe de l'application. On appelle cela des tests unitaires. Ceux-ci peuvent mobiliser beaucoup de d\u00e9veloppeurs s'ils n'ont pas \u00e9t\u00e9 automatis\u00e9s.</p> <p>Des outils ont \u00e9t\u00e9 d\u00e9velopp\u00e9s pour automatiser les tests. L'un d'eux s'appelle [JUnit]. C'est une biblioth\u00e8que de classes destin\u00e9es \u00e0 g\u00e9rer les tests. Nous allons utiliser cet outil pour tester la classe [ListeElectorale].</p> <p>Un programme de test JUnit (versions 4.x) a la forme suivante :</p> <pre><code>package istia.st.elections.tests;\n\nimport org.junit.Assert;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class JUnitEssai {\n\n    @Before\n    public void avant() throws Exception {\n        System.out.println(\"tearUp\");\n    }\n\n    @After\n    public void apr\u00e8s() throws Exception {\n        System.out.println(\"tearDown\");\n    }\n\n    @Test\n    public void t1() {\n        System.out.println(\"test1\");\n        Assert.assertEquals(1, 1);\n    }\n\n    @Test\n    public void t2() {\n        System.out.println(\"test2\");\n        Assert.assertEquals(1, 2);\n    }\n\n}\n</code></pre> <ul> <li>ligne 1 : la classe a \u00e9t\u00e9 plac\u00e9e dans le paquetage [istia.st.elections.tests]\u00a0;</li> <li>ligne 11\u00a0: la m\u00e9thode annot\u00e9e par l'annotation [@Before] est ex\u00e9cut\u00e9e avant chaque test unitaire\u00a0; </li> <li>ligne 16\u00a0: la m\u00e9thode annot\u00e9e par l'annotation [@After] est ex\u00e9cut\u00e9e apr\u00e8s chaque test unitaire\u00a0;</li> <li>ligne 21\u00a0: une m\u00e9thode annot\u00e9e par l'annotation [@Test] est une m\u00e9thode test\u00e9e par le test unitaire. Le m\u00e9thodes annot\u00e9es par [@Test] seront ex\u00e9cut\u00e9es les unes apr\u00e8s les autres, sauf indication contraire du testeur qui peut s\u00e9lectionner lui-m\u00eame les m\u00e9thodes \u00e0 tester. Avant chaque ex\u00e9cution d'une m\u00e9thode [@Test], la m\u00e9thode [@Before] est ex\u00e9cut\u00e9e.  Apr\u00e8s chaque ex\u00e9cution d'une m\u00e9thode [@Test], la m\u00e9thode [@After] est ex\u00e9cut\u00e9e\u00a0;</li> <li>lignes 22-25 : d\u00e9finissent une m\u00e9thode [t1] de test\u00a0;</li> <li>ligne 18 : l'une des m\u00e9thodes [Assert.assert*] qui permet de v\u00e9rifier des assertions. On trouve les m\u00e9thodes [assert] suivantes :</li> <li>assertEquals(expression1, expression2) : v\u00e9rifie que les valeurs des deux expressions sont \u00e9gales. De nombreux types d'expression sont accept\u00e9s (int, String, float, double, boolean, char, short). Si les deux expressions ne sont pas \u00e9gales, alors une exception de type [AssertionFailedError ] est lanc\u00e9e,</li> <li>assertEquals(r\u00e9el1, r\u00e9el2, delta) : v\u00e9rifie que deux r\u00e9els sont \u00e9gaux \u00e0 delta pr\u00e8s, c.a.d abs(r\u00e9el1-r\u00e9el2)&lt;=delta. On pourra \u00e9crire par exemple assertEquals(r\u00e9el1, r\u00e9el2, 1E-6) pour v\u00e9rifier que deux valeurs sont \u00e9gales \u00e0 10-6 pr\u00e8s,</li> <li>assertEquals(message, expression1, expression2) et assertEquals(message, r\u00e9el1, r\u00e9el2, delta) sont des variantes permettant de pr\u00e9ciser le message d'erreur \u00e0 associer \u00e0 l'exception  de type [AssertionFailedError] lanc\u00e9e lorsque la m\u00e9thode [assertEquals] \u00e9choue,</li> <li>assertNotNull(Object) et assertNotNull(message, Object) : v\u00e9rifie que Object n'est pas \u00e9gal \u00e0 null,</li> <li>assertNull(Object) et assertNull(message, Object) : v\u00e9rifie que Object est \u00e9gal \u00e0 null,</li> <li>assertSame(Object1, Object2) et assertSame(message, Object1, Object2) : v\u00e9rifie que les r\u00e9f\u00e9rences Object1 et Object2 pointent sur le m\u00eame objet,</li> <li>assertNotSame(Object1, Object2) et assertNotSame(message, Object1, Object2) : v\u00e9rifie que les r\u00e9f\u00e9rences Object1 et Object2 ne pointent pas sur le m\u00eame objet\u00a0;</li> <li>ligne 24 : cette assertion doit r\u00e9ussir\u00a0;</li> <li>ligne 30 : cette assertion doit \u00e9chouer\u00a0; Dans l'environnement Eclipse, la cr\u00e9ation d'une classe de test JUnit peut se faire de la fa\u00e7on suivante :</li> </ul> <ul> <li>[1] : clic droit sur le paquetage dans lequel on veut ajouter la classe de test , puis option [JUnit / New / JUnit Test Case]</li> </ul> <ul> <li>[1] : choix d'une version JUnit\u00a0;</li> <li>[2] : choix du dossier dans lequel la classe de test doit \u00eatre cr\u00e9\u00e9e\u00a0;</li> <li>[3] : choix du paquetage dans lequel la classe de test doit \u00eatre cr\u00e9\u00e9e\u00a0;</li> <li>[4] : nom de la classe de test\u00a0;</li> <li>[5] : choix des m\u00e9thodes \u00e0 inclure dans la classe qui va \u00eatre g\u00e9n\u00e9r\u00e9e\u00a0;</li> <li>[6] : la classe JUnitEssai a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e L'assistant pr\u00e9c\u00e9dent g\u00e9n\u00e8re une classe quasiment vide :</li> </ul> <pre><code>package istia.st.elections.tests;\n\nimport org.junit.Assert;\nimport org.junit.After;\nimport org.junit.Before;\n\npublic class JUnitEssai {\n\n    @Before\n    public void setUp() throws Exception {        \n    }\n\n    @After\n    public void tearDown() throws Exception {\n    }\n}\n</code></pre> <p>Compl\u00e9tons et modifions le code pr\u00e9c\u00e9dent de la fa\u00e7on suivante :</p> <pre><code>package istia.st.elections.tests;\n\nimport org.junit.Assert;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class JUnitEssai2 {\n\n    @Before\n    public void avant() throws Exception {\n        System.out.println(\"tearUp\");\n    }\n\n    @After\n    public void apr\u00e8s() throws Exception {\n        System.out.println(\"tearDown\");\n    }\n\n    @Test\n    public void t1() {\n        System.out.println(\"test1\");\n        Assert.assertEquals(1, 1);\n    }\n\n    @Test\n    public void t2() {\n        System.out.println(\"test2\");\n        Assert.assertEquals(1, 2);\n    }\n\n}\n</code></pre> <p>Sous Eclipse, un clic droit sur la classe de test, puis option [Run as / JUnit test], permet de l'ex\u00e9cuter :</p> <p></p> <p>Les r\u00e9sultats obtenus \u00e0 l'ex\u00e9cution de ce test sont les suivants :</p> <p></p> <p>Ci-dessus la m\u00e9thode [test2] a \u00e9chou\u00e9. A chaque fois qu'un test \u00e9choue, un message d'erreur lui est associ\u00e9. Pour [test2], c'est celui affich\u00e9 ci-dessus. Le message indique le n\u00b0 de la ligne o\u00f9 l'erreur s'est produite (ligne 30). Ligne 30, l'appel qui a \u00e9chou\u00e9 \u00e9tait :</p> <pre><code>    Assert.assertEquals(1, 2);\n</code></pre> <p>Le premier param\u00e8tre est appel\u00e9 la valeur attendue, le second la valeur r\u00e9elle. Le message d'erreur de [test2] ci-dessus indique que la valeur attendue \u00e9tait 2 mais que la valeur r\u00e9elle a \u00e9t\u00e9 3.</p> <p>Enfin, les messages \u00e9crits sur la console par les diff\u00e9rentes m\u00e9thodes de test ont \u00e9t\u00e9 les suivants :</p> <p></p> <p>Ces messages montrent que les m\u00e9thodes [@Before] et [@After] ont bien \u00e9t\u00e9 appel\u00e9es respectivement, avant et apr\u00e8s chaque m\u00e9thode de test.</p> <p>Les classes de test ne sont pas n\u00e9cessairement \u00e9crites par les d\u00e9veloppeurs eux-m\u00eames. Elles peuvent l'\u00eatre par les personnes qui ont \u00e9crit les sp\u00e9cifications de l'application. Certaines m\u00e9thodes de d\u00e9veloppement dites TDD (Test Driven Development) pr\u00e9conisent l'\u00e9criture des classes de tests avant m\u00eame l'\u00e9criture des classes \u00e0 tester. Cela permet parfois de clarifier des sp\u00e9cifications qui pourraient sinon \u00eatre interpr\u00e9t\u00e9es de plusieurs fa\u00e7ons.</p> <p>Cr\u00e9ons un test JUnit 4, appel\u00e9 [JUnitTest1ListeElectorale], pour la classe [ListeElectorale]. Sous Eclipse, on proc\u00e9dera comme d\u00e9crit pr\u00e9c\u00e9demment :</p> <p>Nous compl\u00e9tons le code g\u00e9n\u00e9r\u00e9 par l'assistant de la fa\u00e7on suivante :</p> <pre><code>package istia.st.elections.tests;\n\nimport org.junit.Assert;\nimport istia.st.elections.ElectionsException;\nimport istia.st.elections.ListeElectorale;\n\nimport org.junit.Test;\n\npublic class JUnitTest1ListeElectorale {\n\n    @Test\n    public void t1() {\n        // cr\u00e9ation liste \u00e9lectorale\n        ListeElectorale liste = new ListeElectorale(1, \"a\", 32000, 0, false);\n        // v\u00e9rifications\n        Assert.assertEquals(\"a\", liste.getNom());\n        Assert.assertEquals(32000, liste.getVoix());\n        Assert.assertEquals(false, liste.isElimine());\n        Assert.assertEquals(0, liste.getSieges());\n        // v\u00e9rification validit\u00e9 id\n        boolean erreur = false;\n        try {\n            liste.setId(-4);\n        } catch (ElectionsException e) {\n            erreur = true;\n        }\n        Assert.assertEquals(true, erreur);\n        // v\u00e9rification validit\u00e9 nom\n        erreur = false;\n        try {\n            liste.setNom(\"\");\n        } catch (ElectionsException e) {\n            erreur = true;\n        }\n        Assert.assertEquals(true, erreur);\n        // v\u00e9rification validit\u00e9 voix\n        erreur = false;\n        try {\n            liste.setVoix(-4);\n        } catch (ElectionsException e) {\n            erreur = true;\n        }\n        Assert.assertEquals(true, erreur);\n        // v\u00e9rification validit\u00e9 si\u00e8ges\n        erreur = false;\n        try {\n            liste.setSieges(-4);\n        } catch (ElectionsException e) {\n            erreur = true;\n        }\n        Assert.assertEquals(true, erreur);\n    }\n\n}\n</code></pre> <p>L'ex\u00e9cution du test donne le r\u00e9sultat suivant :</p> <p></p> <p>Les tests sont r\u00e9ussis. Nous consid\u00e8rerons d\u00e9sormais que nous avons une classe [ListeElectorale] op\u00e9rationnelle.</p>"},{"location":"td-classes.html#35-mainelections-version-2","title":"3.5. MainElections : version 2","text":"<p>Lectures conseill\u00e9es :</p> <ul> <li>paragraphes 2.1, 2.2, 2.4 et 2.7 du chapitre 2 de [1] : Classes et interfaces</li> <li> <p>paragraphes 3.3 (classe String), 3.5 (classe ArrayList), 3.6 (classe Arrays) On d\u00e9sire r\u00e9\u00e9crire l'application [Elections] en y ajoutant les nouvelles contraintes suivantes :</p> </li> <li> <p>on utilisera la classe [ListeElectorale] pour repr\u00e9senter une liste candidate</p> </li> <li>l'application demandera au clavier les informations suivantes :</li> <li>le nombre de si\u00e8ges \u00e0 pourvoir</li> <li>les noms et voix des listes. On ne sait pas \u00e0 priori combien il y a de listes. La derni\u00e8re liste sera signal\u00e9e par un nom \u00e9gal \u00e0 la cha\u00eene \"*\".</li> <li>parce qu'on ne conna\u00eet  pas \u00e0 priori le nombre de listes, celles-ci seront tout d'abord m\u00e9moris\u00e9es dans un objet de type [ArrayList]. Puis, lorsque toutes les listes auront \u00e9t\u00e9 saisies, elles seront transf\u00e9r\u00e9es dans un tableau de listes.</li> <li> <p>les r\u00e9sultats seront affich\u00e9s par ordre d\u00e9croissant du nombre de si\u00e8ges obtenus. Pour trier un tableau T, on dispose de diff\u00e9rentes m\u00e9thodes statiques de la classe [Arrays] :</p> </li> <li> <p>Arrays.sort(T) : trie le tableau T selon un ordre naturel s'il en a un (croissant pour les nombres, les dates, alphab\u00e9tique pour les cha\u00eenes, ...)</p> </li> <li>Arrays.sort(T,comparateur) : pour trier des tableaux T n'ayant pas un ordre naturel. C'est le cas ici du tableau des listes qu'il faut trier selon un champ particulier de la liste : le nombre de si\u00e8ges obtenus. Dans la m\u00e9thode Arrays.sort(T,comparateur), le param\u00e8tre comparateur est un objet impl\u00e9mentant l'interface Comparator suivante :</li> </ul> <p></p> <ul> <li>la m\u00e9thode compare permet de comparer deux \u00e9l\u00e9ments du tableau T</li> <li> <p>la m\u00e9thode equals permet de dire si deux objets sont \u00e9gaux Les deux m\u00e9thodes comparent des types Object obj1 et obj2. Dire que obj1&lt;obj2 ou obj1=obj2 ou obj1&gt;obj2 d\u00e9pend de la relation d'ordre que l'on veut cr\u00e9er entre les deux objets. C'est au d\u00e9veloppeur qui impl\u00e9mente cette interface d'indiquer comment on sait que :</p> </li> <li> <p>obj1 est plus petit que obj2</p> </li> <li>obj1 est plus grand que obj2</li> <li>obj1 est \u00e9gal \u00e0 obj2 La classe Object dont d\u00e9rive toute classe Java dispose d\u00e9j\u00e0 d'une m\u00e9thode [equals]. Pour trier un tableau T d'objets de type O, la m\u00e9thode [equals] de la classe O n'est pas utile. On peut donc laisser l'impl\u00e9mentation par d\u00e9faut apport\u00e9e par la classe Object. Seule la m\u00e9thode [compare] doit \u00eatre alors impl\u00e9ment\u00e9e. Cette m\u00e9thode est appel\u00e9e de fa\u00e7on r\u00e9p\u00e9t\u00e9e par la m\u00e9thode [Arrays.sort]. Celle-ci va \u00e0 chaque fois passer comme param\u00e8tres obj1 et obj2 de la m\u00e9thode compare, deux \u00e9l\u00e9ments du tableau T \u00e0 trier. Dans notre cas, ces \u00e9l\u00e9ments seront de type [ListeElectorale]. On notera ici le polymorphisme \u00e0 l'oeuvre. La m\u00e9thode [compare] est d\u00e9finie comme recevant des param\u00e8tres de type [Object]. Cela veut dire qu'elle peut recevoir des param\u00e8tres de type [Object] ou d\u00e9riv\u00e9 (polymorphisme). Comme [Object] est la classe parent de toutes les classes Java, les param\u00e8tres effectifs peuvent avoir le type [ListeElectorale].</li> </ul> <p>Pour un tri dans l'ordre croissant, la m\u00e9thode [compare] doit rendre :</p> <ul> <li>-1 si obj1 est plus petit que obj2</li> <li>+1 si obj1 est plus grand que obj2</li> <li>0 si obj1 est \u00e9gal \u00e0 obj2 Pour un tri dans l'ordre d\u00e9croissant, les valeurs +1 et -1 sont invers\u00e9es. Les termes \"est plus petit que\", \"est plus grand que\", \"est \u00e9gal \u00e0\" expriment une relation d'ordre. Pour des objets de type [ListeElectorale], on aura la relation liste1 \"est plus petit que\"  liste2 si liste1 a moins de voix que liste2.</li> </ul> <p>Dans le m\u00eame fichier source que la classe [MainElections], on pourra ajouter une deuxi\u00e8me classe :</p> <pre><code>// classe de comparaison de listes \u00e9lectorales\nclass CompareListesElectorales implements Comparator {\n\n    // comparaison de deux listes \u00e9lectorales selon le nombre de voix\n    public int compare(Object obj1, Object obj2) {\n        // on r\u00e9cup\u00e8re les listes \u00e9lectorales\n        ListeElectorale listeElectorale1 = (ListeElectorale) obj1;\n        ListeElectorale listeElectorale2 = (ListeElectorale) obj2;\n        // on compare les voix de ces deux listes\n....        \n    }\n}\n</code></pre> <ul> <li>ligne 2 : la classe n'est pas d\u00e9clar\u00e9e publique. Dans un fichier source Java, il peut y avoir plusieurs classes mais une seule peut avoir l'attribut public, celle qui porte le nom du fichier source. Dans la m\u00e9thode compare pr\u00e9c\u00e9dente, les param\u00e8tres sont de type Object, ce qui oblige lignes 7 et 8, \u00e0 faire un transtypage des param\u00e8tres de la m\u00e9thode, du type Object vers le type ListeElectorale. La signature de la m\u00e9thode compare est impos\u00e9e par l'interface Comparator qui a \u00e9t\u00e9 \u00e9crite pour comparer des objets quelconques. Depuis le JDK 1.5, il existe une interface Comparator g\u00e9n\u00e9rique : Comparator&lt;T&gt; o\u00f9 T est un type Java quelconque. La m\u00e9thode compare de l'interface Comparator&lt;T&gt; compare des objets de type T et non de type Object ce qui \u00e9vite les transtypages pr\u00e9c\u00e9dents. La classe de comparaison des objets de type ListeElectorale pourrait ressembler \u00e0 ceci :</li> </ul> <pre><code>// classe de comparaison de listes \u00e9lectorales\nclass CompareListesElectorales implements Comparator&lt;ListeElectorale&gt; {\n\n    // comparaison de deux listes \u00e9lectorales selon le nombre de si\u00e8ges\n    public int compare(ListeElectorale listeElectorale1,\n            ListeElectorale listeElectorale2) {\n...\n    }\n}\n</code></pre> <ul> <li>ligne 2 : la classe impl\u00e9mente l'interface Comparator&lt;ListeElectorale&gt;</li> <li>lignes 5-6 : les param\u00e8tres de la m\u00e9thode compare sont de type ListeElectorale. Le transtypage est d\u00e9sormais inutile. Le JDK 1.5 a introduit le concept de classe / interface g\u00e9n\u00e9rique pour diverses classes / interfaces du JDK 1.4 qui manipulaient initialement uniquement des objets de type Object. C'est le cas des listes, dictionnaires, ...</li> </ul> <p>Nous avons dit un peu plus haut que, parce qu'on ne connaissait pas le nombre de listes, on ne pouvait m\u00e9moriser celles-ci dans un tableau. Elles peuvent \u00eatre m\u00e9moris\u00e9es dans un objet ArrayList qui impl\u00e9mente la notion de \"liste d'objets\". Cette classe m\u00e9morise des objets de type Object. Depuis le JDK 1.5, il existe des listes d'objets typ\u00e9s. Ainsi on utilisera un objet ArrayList&lt;ListeElectorale&gt; pour m\u00e9moriser les listes avant de les transf\u00e9rer dans un tableau. Si ce dernier s'appelle tListes, son tri sera obtenu par l'instruction :</p> <pre><code>// tri des listes\nArrays.sort(tListes, new CompareListesElectorales());\n</code></pre> <p>o\u00f9 CompareListesElectorales est la classe impl\u00e9mentant l'interface Comparator&lt;ListeElectorale&gt;.</p> <p>Travail \u00e0 faire : r\u00e9\u00e9crivez l'application [Elections] en tenant compte de ces nouvelles sp\u00e9cifications.</p> <p>Le projet Eclipse pourrait \u00eatre le suivant :</p> <p>Un exemple d'ex\u00e9cution de [1] est le suivant :</p> <p></p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html","title":"15. [TD]\u00a0: cr\u00e9ation d'un client pour le service web","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, service web / jSON, client / serveur</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#151-support","title":"15.1. Support","text":"<p>Les projets de ce chapitre seront trouv\u00e9s dans le dossier [support / chap-15].</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#152-larchitecture-client-serveur","title":"15.2. L'architecture client / serveur","text":"<p>Nous voulons cr\u00e9er l'architecture client / serveur suivante\u00a0:</p> <p>La couche [ui] sera celle d\u00e9j\u00e0 d\u00e9velopp\u00e9e aux paragraphes 9 et 10. Cela sera possible parce que la couche [m\u00e9tier] ci-dessus impl\u00e9mentera la m\u00eame interface [IElectionsMetier] que la couche [m\u00e9tier] du paragraphe 8\u00a0:</p> <pre><code>package elections.client.metier;\n\nimport elections.client.entities.ListeElectorale;\n\npublic interface IElectionsMetier {\n\n    // obtenir les listes en comp\u00e9tition\n    public ListeElectorale[] getListesElectorales();\n\n    // le nombre de si\u00e8ges \u00e0 pourvoir\n    public int getNbSiegesAPourvoir();\n\n    // le seuil \u00e9lectoral\n    public double getSeuilElectoral();\n\n    // l'enregistrement des r\u00e9sultats\n    public void recordResultats(ListeElectorale[] listesElectorales);\n\n    // le calcul des si\u00e8ges\n    public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n\n}\n</code></pre> <p>Dans le paragraphe 7, la couche [DAO] \u00e9changeait des donn\u00e9es avec un SGBD. Ici la couche [DAO] \u00e9change des donn\u00e9es avec un serveur web / jSON.</p> <p>Dans un premier temps, nous nous int\u00e9resserons \u00e0 l'architecture suivante\u00a0:</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#153-le-projet-eclipse","title":"15.3. Le projet Eclipse","text":"<p>Le projet Eclipse est le suivant\u00a0:</p> <p>Cette structure reprend celle du projet exemple du paragraphe 13.6.1, page 248. Nous allons suivre la m\u00eame d\u00e9marche.</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#154-configuration-maven","title":"15.4. Configuration Maven","text":"<p>C'est celle d\u00e9crite au paragraphe 13.6.2, page 249.</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#155-implementation-de-la-couche-dao","title":"15.5. Impl\u00e9mentation de la couche [DAO]","text":"<ul> <li>le package [elections.client.config] contient la configation Spring de la couche [DAO]\u00a0;</li> <li>le package [elections .client.dao] contient l'impl\u00e9mentation de la couche [DAO]\u00a0;</li> <li>le package [elections .client.entities] contient les objets \u00e9chang\u00e9s avec le service web / jSON\u00a0;</li> <li>le package [elections .client.metier] contient la couche [m\u00e9tier]</li> <li>le package [elections .client.ui] contient la couche [UI]</li> </ul>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#1551-configuration-de-la-couche-metier","title":"15.5.1. Configuration de la couche [m\u00e9tier]","text":"<p>La classe [MetierConfig] fait la configuration Spring de la couche [m\u00e9tier]. Son code est le suivant\u00a0:</p> <pre><code>package elections.client.config;\n\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.web.client.RestTemplate;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n@ComponentScan({ \"elections.client.dao\",\"elections.client.metier\" })\npublic class MetierConfig {\n\n    // constantes\n    static private final int TIMEOUT = 1000;\n    static private final String URL_WEBJSON = \"http://localhost:8080\";\n\n    @Bean\n    public RestTemplate restTemplate(int timeout) {\n        // cr\u00e9ation du composant RestTemplate\n        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory();\n        RestTemplate restTemplate = new RestTemplate(factory);\n        // timeout des \u00e9changes\n        factory.setConnectTimeout(timeout);\n        factory.setReadTimeout(timeout);\n        // r\u00e9sultat\n        return restTemplate;\n    }\n\n    @Bean\n    public int timeout() {\n        return TIMEOUT;\n    }\n\n    @Bean\n    public String urlWebJson() {\n        return URL_WEBJSON;\n    }\n\n    // mappeur jSON\n    @Bean\n    @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n    public ObjectMapper jsonMapper() {\n        return new ObjectMapper();\n    }\n}\n</code></pre> <p>Ce code a \u00e9t\u00e9 expliqu\u00e9 au paragraphe 13.6.3.1, page 251. Il est plus simple car il n'y a pas ici de filtres jSON \u00e0 g\u00e9rer.</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#1552-les-entites","title":"15.5.2. Les entit\u00e9s","text":"<p>Les entit\u00e9s manipul\u00e9es par les couches [DAO] et [m\u00e9tier] sont celles qu'elles \u00e9changent avec le service web / jSON. Ce sont les objets de type [ElectionsConfig] et [ListeElectorale]. C\u00f4t\u00e9 serveur, ces entit\u00e9s avaient des annotations de persistence JPA. Ici, ces annotations ont \u00e9t\u00e9 enlev\u00e9es. Nous redonnons le code des entit\u00e9s pour rappel\u00a0:</p> <p>[AbstractEntity]</p> <pre><code>package spring.webjson.client.entities;\n\n\npublic abstract class AbstractEntity {\n    // propri\u00e9t\u00e9s\n    protected Long id;\n    protected Long version;\n\n    // constructeurs\n    public AbstractEntity() {\n\n    }\n\n    public AbstractEntity(Long id, Long version) {\n        this.id = id;\n        this.version = version;\n    }\n\n    // red\u00e9finition [equals] et [hashcode]\n    @Override\n    public int hashCode() {\n        return (id != null ? id.hashCode() : 0);\n    }\n\n    @Override\n    public boolean equals(Object entity) {\n        if (!(entity instanceof AbstractEntity)) {\n            return false;\n        }\n        String class1 = this.getClass().getName();\n        String class2 = entity.getClass().getName();\n        if (!class2.equals(class1)) {\n            return false;\n        }\n        AbstractEntity other = (AbstractEntity) entity;\n        return id != null &amp;&amp; this.id == other.id.longValue();\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre> <p>[ElectionsConfig]</p> <pre><code>package elections.webjson.client.entities;\n\n\npublic class ElectionsConfig extends AbstractEntity {\n\n    // champs\n    private int nbSiegesAPourvoir;\n    private double seuilElectoral;\n\n    // constructeurs\n    public ElectionsConfig() {\n\n    }\n\n    public ElectionsConfig(int nbSiegesAPourvoir, double seuilElectoral) {\n        this.nbSiegesAPourvoir = nbSiegesAPourvoir;\n        this.seuilElectoral = seuilElectoral;\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre> <p>[ListeElectorale]</p> <pre><code>package elections.webjson.client.entities;\n\n\npublic class ListeElectorale extends AbstractEntity {\n\n    // champs\n    private String nom;\n    private int voix;\n    private int sieges;\n    private boolean elimine;\n\n    // constructeurs\n    public ListeElectorale() {\n    }\n\n    public ListeElectorale(String nom, int voix, int sieges, boolean elimine) {\n        setNom(nom);\n        setVoix(voix);\n        setSieges(sieges);\n        setElimine(elimine);\n    }\n\n    // getters et setters\n    ...\n}\n</code></pre>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#1553-linterface-de-la-couche-dao","title":"15.5.3. L'interface de la couche [DAO]","text":"<p>La couche [DAO] pr\u00e9sente l'interface [IClientDao] suivante\u00a0:</p> <pre><code>package elections.client.dao;\n\npublic interface IClientDao {\n\n    // requ\u00eate g\u00e9n\u00e9rique\n    String getResponse(String url, String jsonPost);\n\n}\n</code></pre> <p>L'interface n'a qu'une unique m\u00e9thode [getResponse]\u00a0:</p> <ul> <li>le 1er param\u00e8tre est l'URL du serveur \u00e0 interroger\u00a0;</li> <li>le second param\u00e8tre est la valeur jSON de la valeur \u00e0 poster, null s'il n'y a rien \u00e0 poster\u00a0;</li> <li>le r\u00e9sultat est la cha\u00eene jSON d'un objet [Response&lt;T&gt;] o\u00f9 la classe [Response] a \u00e9t\u00e9 d\u00e9crite au paragraphe 14.7, page 272\u00a0;</li> </ul>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#1554-implementation-des-echanges-avec-le-service-web-json","title":"15.5.4. Impl\u00e9mentation des \u00e9changes avec le service web / jSON","text":"<p>La classe [ClientDao] impl\u00e9mente l'interface [IClientDao] de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.client.dao;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.RequestEntity;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.client.RestTemplate;\n\nimport elections.client.entities.ElectionsException;\n\n@Component\npublic class ClientDao implements IClientDao {\n\n    // data\n    @Autowired\n    protected RestTemplate restTemplate;\n    @Autowired\n    protected String urlServiceWebJson;\n\n    // requ\u00eate g\u00e9n\u00e9rique\n    @Override\n    public String getResponse(String url, String jsonPost) {\n\n        try {\n            // url : URL \u00e0 contacter\n            // jsonPost : la valeur jSON \u00e0 poster\n\n            // ex\u00e9cution requ\u00eate\n            RequestEntity&lt;?&gt; request;\n            if (jsonPost != null) {\n                // requ\u00eate POST\n                request = RequestEntity.post(new URI(String.format(\"%s%s\", urlServiceWebJson, url)))\n                        .header(\"Content-Type\", \"application/json\").accept(MediaType.APPLICATION_JSON).body(jsonPost);\n            } else {\n                // requ\u00eate GET\n                request = RequestEntity.get(new URI(String.format(\"%s%s\", urlServiceWebJson, url)))\n                        .accept(MediaType.APPLICATION_JSON).build();\n            }\n            // on ex\u00e9cute la requ\u00eate\n            return restTemplate.exchange(request, new ParameterizedTypeReference&lt;String&gt;() {\n            }).getBody();\n        } catch (URISyntaxException e1) {\n            throw new ElectionsException(200, e1);\n        } catch (RuntimeException e2) {\n            throw new ElectionsException(201, e2);\n        }\n    }\n}\n</code></pre> <p>Ce code a \u00e9t\u00e9 d\u00e9crit page 257.</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#156-implementation-de-la-couche-metier","title":"15.6. Impl\u00e9mentation de la couche [m\u00e9tier]","text":"<p>Comme il a \u00e9t\u00e9 dit, la couche [m\u00e9tier] pr\u00e9sente la m\u00eame interface [IElectionsMetier] que dans le paragraphe 8.4, page 128\u00a0:</p> <pre><code>package elections.client.metier;\n\nimport elections.client.entities.ListeElectorale;\n\npublic interface IElectionsMetier {\n\n    // obtenir les listes en comp\u00e9tition\n    public ListeElectorale[] getListesElectorales();\n\n    // le nombre de si\u00e8ges \u00e0 pourvoir\n    public int getNbSiegesAPourvoir();\n\n    // le seuil \u00e9lectoral\n    public double getSeuilElectoral();\n\n    // l'enregistrement des r\u00e9sultats\n    public void recordResultats(ListeElectorale[] listesElectorales);\n\n    // le calcul des si\u00e8ges\n    public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n\n}\n</code></pre> <p>Cette interface est impl\u00e9ment\u00e9e par la classe [ElectionsMetier] suivante\u00a0:</p> <pre><code>package elections.client.metier;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.annotation.PostConstruct;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Component;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport elections.client.dao.IClientDao;\nimport elections.client.entities.ElectionsConfig;\nimport elections.client.entities.ElectionsException;\nimport elections.client.entities.ListeElectorale;\n\n@Component\npublic class ElectionsMetier implements IElectionsMetier {\n\n    @Autowired\n    private IClientDao dao;\n    @Autowired\n    private ApplicationContext context;\n\n    // configuration de l'\u00e9lection\n    private ElectionsConfig electionsConfig;\n\n    @PostConstruct\n    public void init() {\n        // mappeurs jSON\n        ObjectMapper mapperResponse = context.getBean(ObjectMapper.class);\n        try {\n            // requ\u00eate\n            Response&lt;ElectionsConfig&gt; response = mapperResponse.readValue(dao.getResponse(\"/getElectionsConfig\", null),\n                    new TypeReference&lt;Response&lt;ElectionsConfig&gt;&gt;() {\n                    });\n            // erreur ?\n            if (response.getStatus() != 0) {\n                // on lance 1 exception\n                throw new ElectionsException(response.getStatus(), response.getMessages());\n            } else {\n                electionsConfig = response.getBody();\n            }\n        } catch (ElectionsException e1) {\n            throw e1;\n        } catch (Exception e2) {\n            throw new ElectionsException(100, getMessagesForException(e2));\n        }\n    }\n\n    @Override\n    public ListeElectorale[] getListesElectorales() {\n        ...\n    }\n\n    @Override\n    public int getNbSiegesAPourvoir() {\n        return electionsConfig.getNbSiegesAPourvoir();\n    }\n\n    @Override\n    public double getSeuilElectoral() {\n        return electionsConfig.getSeuilElectoral();\n    }\n\n    @Override\n    public void recordResultats(ListeElectorale[] listesElectorales) {\n    ...\n    }\n\n    @Override\n    public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales) {\n...\n    }\n\n    // liste des messages d'erreur d'une exception\n    private List&lt;String&gt; getMessagesForException(Exception exception) {\n        // on r\u00e9cup\u00e8re la liste des messages d'erreur de l'exception\n        Throwable cause = exception;\n        List&lt;String&gt; erreurs = new ArrayList&lt;String&gt;();\n        while (cause != null) {\n            // on r\u00e9cup\u00e8re le message seulement s'il est !=null et non blanc\n            String message = cause.getMessage();\n            if (message != null) {\n                message = message.trim();\n                if (message.length() != 0) {\n                    erreurs.add(message);\n                }\n            }\n            // cause suivante\n            cause = cause.getCause();\n        }\n        return erreurs;\n    }\n}\n</code></pre> <p>Le type [Response] utilis\u00e9 ligne 37 est la r\u00e9ponse du serveur web / jSON d\u00e9crite au paragraphe 14.7, page 272\u00a0;</p> <p>Travail \u00e0 faire\u00a0: en suivant le paragraphe 13.6.3.7, page 258, compl\u00e9tez la classe [ElectionsMetier]\u00a0;</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#157-le-test-junit","title":"15.7. Le test Junit","text":"<p>Revenons \u00e0 l'architecture client / serveur en cours de construction\u00a0:</p> <p>La couche [JUnit] [1] communique avec la couche [M\u00e9tier] du serveur [5] au travers des couches [2-4]. En faisant en sorte que les couches [M\u00e9tier] [2] et [5] aient la m\u00eame interface, on rend les couches [2-4] transparentes. La couche [1] a l'impression de communiquer directement avec la couche [5]. Le point int\u00e9ressant est qu'en [1] on va pouvoir utiliser le test JUnit qui avait \u00e9t\u00e9 utilis\u00e9 pour tester la couche [M\u00e9tier] [5].</p> <p>Travail \u00e0 faire\u00a0: passez le test JUnit du projet pour v\u00e9rifier votre impl\u00e9mentation et du serveur et de son client.</p>"},{"location":"td-creation-dx27un-client-pour-le-service-web.html#158-implementation-de-la-couche-ui","title":"15.8. Impl\u00e9mentation de la couche [UI]","text":"<p>Revenons \u00e0 l'architecture que nous voulons construire\u00a0:</p> <p>Maintenant que la couche [m\u00e9tier] [2] a \u00e9t\u00e9 construite et test\u00e9e, nous pouvons construire la couche [ui] [1].</p> <p>Comme l'interface [IElectionsMetier] de la couche [m\u00e9tier] est identique \u00e0 celle du projet d\u00e9crit au paragraphe 8, page 125, nous pouvons en [3], copier le projet de la couches [ui] du paragraphe 10, page 140. Ce projet \u00e9tait un projet Netbeans. Il suffit de faire un copier / coller des classes Java concern\u00e9es de Netbeans vers Eclipse. Ceci fait, il y a des ajustements de packages et d'imports \u00e0 faire.</p> <p>On fera de m\u00eame pour les classes ex\u00e9cutables du package [elections.client.boot] [4].</p> <p>La classe [AbstractBootElections] est la suivante\u00a0:</p> <pre><code>package elections.client.boot;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport elections.client.config.UiConfig;\nimport elections.client.entities.ElectionsException;\nimport elections.client.ui.IElectionsUI;\n\npublic abstract class AbstractBootElections {\n\n    // r\u00e9cup\u00e9ration du contexte Spring\n    protected AnnotationConfigApplicationContext ctx;\n\n    public void run() {\n        // instanciation couche [ui]\n        IElectionsUI electionsUI = null;\n        try {\n            // r\u00e9cup\u00e9ration du contexte Spring\n            ctx = new AnnotationConfigApplicationContext(UiConfig.class);\n            // r\u00e9cup\u00e9ration de la couche [ui]\n            electionsUI = getUI();\n\n...\n</code></pre> <ul> <li>ligne 19\u00a0: le contexte Spring d\u00e9fini par la classe de configuration [UiConfig] est instanci\u00e9. Cette classe est la suivante\u00a0:</li> </ul> <p>La classe [UiConfig] est la suivante\u00a0:</p> <pre><code>package elections.client.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n\n@Import(MetierConfig.class)\n@ComponentScan(basePackages = { \"elections.client.ui\" })\npublic class UiConfig {\n}\n</code></pre> <ul> <li>ligne 6\u00a0: on importe les beans de la couche [m\u00e9tier]\u00a0;</li> <li>ligne 7\u00a0: on indique qu'il y des beans Spring dans le package [elections.client.ui]\u00a0; Travail \u00e0 faire\u00a0: v\u00e9rifiez que les versions console et swing de la couche [ui] fonctionnent.</li> </ul>"},{"location":"td-elections-avec-des-requetes-inter-domaines.html","title":"19. [TD] Elections avec des requ\u00eates inter-domaines","text":"<p>Mots cl\u00e9s : CORS (Cross-Origin Resource Sharing).</p> <p>Nous allons ici cr\u00e9er un nouveau projet pour que le service web s\u00e9curis\u00e9 des \u00e9lections accepte des requ\u00eates inter-domaines.</p> <p>Le projet Eclipse est le suivant\u00a0:</p> <p>Travail \u00e0 faire\u00a0: en suivant le processus d\u00e9crit au paragraphe 18.9, page 364, construisez ce projet.</p> <p>Lorsque ce projet est construit, voici ce qu'on peut faire avec le client HTML d\u00e9crit au paragraphe 18.2, page 353. Au d\u00e9part des requ\u00eates, la base de donn\u00e9es [dbelections] est la suivante\u00a0:</p> <p>En [1], la valeur jSON post\u00e9e est la suivante\u00a0:</p> <pre><code>[{\"id\":1,\"version\":8,\"nom\":\"A\",\"voix\":32000,\"sieges\":0,\"elimine\":false},{\"id\":2,\"version\":12,\"nom\":\"B\",\"voix\":25000,\"sieges\":0,\"elimine\":false},{\"id\":3,\"version\":13,\"nom\":\"C\",\"voix\":16000,\"sieges\":0,\"elimine\":false},{\"id\":4,\"version\":12,\"nom\":\"D\",\"voix\":12000,\"sieges\":0,\"elimine\":false},{\"id\":5,\"version\":13,\"nom\":\"E\",\"voix\":8000,\"sieges\":0,\"elimine\":false},{\"id\":6,\"version\":12,\"nom\":\"F\",\"voix\":4500,\"sieges\":0,\"elimine\":false},{\"id\":7,\"version\":12,\"nom\":\"G\",\"voix\":2500,\"sieges\":0,\"elimine\":false}]\n</code></pre> <p>En [2], les champs [sieges] et [elimine] ont \u00e9t\u00e9 calcul\u00e9s. Nous copions le champ [body] de [2] en [3] ci-dessous\u00a0:</p> <p>La base de donn\u00e9es [dbelections] est alors la suivante\u00a0:</p>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html","title":"14. [TD]\u00a0: Exposition sur le web de la couche [metier]","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, service web / jSON, client / serveur.</p> <p>Revenons \u00e0 l'architecture actuelle de l'application du TD\u00a0:</p> <p>Nous allons faire \u00e9voluer cette architecture vers la suivante\u00a0:</p> <p>afin d'exposer sur le web l'interface [IMetier] de la couche m\u00e9tier. Pour cela nous allons suivre la m\u00e9thodologie d\u00e9crite au paragraphe 13.5, page 229.</p>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#141-support","title":"14.1. Support","text":"<p>Les projets de ce chapitre seront trouv\u00e9s dans le dossier [support / chap-14].</p>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#142-le-projet-eclipse-de-la-couche-metier","title":"14.2. Le projet Eclipse de la couche [m\u00e9tier]","text":""},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#1421-configuration-maven","title":"14.2.1. Configuration Maven","text":"<p>Le projet de la couche [m\u00e9tier] est un projet Maven configur\u00e9 par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-metier-dao-spring-data&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n\n    &lt;!-- d\u00e9pendances --&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;dependencies&gt;\n        &lt;!-- couche [DAO] --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-dao-spring-data-01&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;!-- use UTF-8 for everything --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 18-22\u00a0: la d\u00e9pendance sur la couche [DAO] construite au paragraphe 12, page 209\u00a0;</li> <li>lignes 23-34\u00a0: les d\u00e9pendances n\u00e9cessaires aux tests\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#1422-configuration-spring","title":"14.2.2. Configuration Spring","text":"<p>Le projet de la couche [m\u00e9tier] est un projet Spring configur\u00e9 par le fichier [MetierConfig] suivant\u00a0:</p> <pre><code>package elections.metier.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n\nimport elections.dao.config.DaoConfig;\n\n@Import({ DaoConfig.class })\n@ComponentScan({ \"elections.metier.service\" })\npublic class MetierConfig {\n}\n</code></pre> <ul> <li>nous n'utilisons pas ici la notation [@Configuration] qui fait de la classe une classe de configuration Spring. La pr\u00e9sence des annotations [@Import, @ComponentScan] fait automatiquement d'elle une classe de configuration\u00a0;</li> <li>ligne 8\u00a0: on importe le fichier de configuration de la couche [DAO]. On dispose alors de tous les beans d\u00e9finis par ce fichier\u00a0;</li> <li>ligne 9\u00a0: d'autres beans Spring sont \u00e0 chercher dans le dossier [elections.metier.service]\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#1423-implementation-de-la-couche-metier","title":"14.2.3. Impl\u00e9mentation de la couche [m\u00e9tier]","text":"<p>L'impl\u00e9mentation de la couche [m\u00e9tier] est celle qui a \u00e9t\u00e9 d\u00e9finie au paragraphe 8.5, page 128.</p>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#1424-le-test-de-la-couche-metier","title":"14.2.4. Le test de la couche [m\u00e9tier]","text":"<p>La classe de test est celle d\u00e9crite au paragraphe 8.6, page 130.</p> <p>Travail \u00e0 faire\u00a0: impl\u00e9mentez le projet de la couche [m\u00e9tier] et passer son test unitaire. G\u00e9n\u00e9rez l'archive de la couche dans le d\u00e9p\u00f4t Maven local (run as/ Maven / install).</p>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#143-le-projet-eclipse-de-la-couche-web","title":"14.3. Le projet Eclipse de la couche [web]","text":"<p>La couche web est une couche Spring MVC\u00a0:</p> <p>Le projet Eclipse a la structure suivante\u00a0:</p> <ul> <li>[Boot.java] est la classe qui lance le service web\u00a0;</li> <li>[WebConfig.java] est la classe de configuration du service web\u00a0;</li> <li>[Response.java] est la r\u00e9ponse faite par les diff\u00e9rentes URL du service web\u00a0;</li> <li>[ElectionsController] est la classe d'impl\u00e9mentation du service web\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#144-configuration-maven","title":"14.4. Configuration Maven","text":"<p>Le projet est un projet Maven configur\u00e9 par le fichier [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-webjson-metier-dao-spring-data&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;name&gt;elections-webjson-metier-dao-spring-data&lt;/name&gt;\n    &lt;description&gt;couche m\u00e9tier expos\u00e9e comme un service web / jSON&lt;/description&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- couche m\u00e9tier --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-metier-dao-spring-data&lt;/artifactId&gt;\n            &lt;version&gt;0.1.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- couche MVC --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 19-23\u00a0: la d\u00e9pendance sur l'archive la couche [m\u00e9tier]. C'est celle que nous avons cr\u00e9\u00e9 au paragraphe 14 page 266;</li> <li>lignes 25-28\u00a0: la d\u00e9pendance pour avoir une application Spring MVC\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#145-configuration-spring","title":"14.5. Configuration Spring","text":"<p>La classe [WebConfig] configure le service web\u00a0:</p> <pre><code>package elections.webjson.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerFactory;\nimport org.springframework.boot.context.embedded.ServletRegistrationBean;\nimport org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.servlet.DispatcherServlet;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport elections.metier.config.MetierConfig;\n\n@EnableWebMvc\n@Import({ MetierConfig.class })\n@ComponentScan({ \"elections.webjson.service\" })\npublic class WebConfig {\n    // -------------------------------- configuration couche [web]\n    @Autowired\n    private ApplicationContext context;\n\n    @Bean\n    public DispatcherServlet dispatcherServlet() {\n        DispatcherServlet servlet = new DispatcherServlet((WebApplicationContext) context);\n        return servlet;\n    }\n\n    @Bean\n    public ServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) {\n        return new ServletRegistrationBean(dispatcherServlet, \"/*\");\n    }\n\n    @Bean\n    public EmbeddedServletContainerFactory embeddedServletContainerFactory() {\n        return new TomcatEmbeddedServletContainerFactory(\"\", 8080);\n    }\n    // mappeur jSON\n    @Bean\n    @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n    public ObjectMapper jsonMapper() {\n        return new ObjectMapper();\n    }\n\n}\n</code></pre> <ul> <li>la signification de cette configuration a \u00e9t\u00e9 donn\u00e9e au paragraphe 13.5.3.1, page 231. Nous n'expliquons que les nouveaut\u00e9s\u00a0:</li> <li>ligne 22\u00a0: on importe le fichier de configuration de la couche [m\u00e9tier] pour b\u00e9n\u00e9ficier de tous ses beans\u00a0;</li> <li>ligne 23\u00a0: on indique que d'autres beans seront trouv\u00e9s dans le dossier [elections.webjson.server.service]\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#146-la-classe-de-lancement-du-service-web","title":"14.6. La classe de lancement du service web","text":"<p>La classe [Boot] lance le service web de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.webjson.boot;\n\nimport org.springframework.boot.SpringApplication;\n\nimport elections.webjson.config.WebConfig;\n\npublic class Boot {\n\n    public static void main(String[] args) {\n        SpringApplication.run(WebConfig.class, args);\n    }\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la m\u00e9thode statique [SpringApplication.run] va exploiter le fichier de configuration [WebConfig]. A cause de l'annotation [@EnableAutoConfiguration], Spring Boot va lancer le serveur Tomvat et d\u00e9ployer le service web dessus\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#147-la-reponse-des-url-du-service-web","title":"14.7. La r\u00e9ponse des URL du service web","text":"<p>Toutes les URL du service web / jSON envoient le m\u00eame type de r\u00e9ponse\u00a0:</p> <pre><code>package elections.webjson.service;\n\nimport java.util.List;\n\npublic class Response&lt;T&gt; {\n\n    // ----------------- propri\u00e9t\u00e9s\n    // statut de l'op\u00e9ration\n    private int status;\n    // les \u00e9ventuels messages d'erreur\n    private List&lt;String&gt; messages;\n    // le corps de la r\u00e9ponse\n    private T body;\n\n    // constructeurs\n    public Response() {\n\n    }\n\n    public Response(int status, List&lt;String&gt; messages, T body) {\n        this.status = status;\n        this.messages = messages;\n        this.body = body;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>Cette classe a \u00e9t\u00e9 pr\u00e9sent\u00e9e et \u00e9tudi\u00e9e au paragraphe 13.5.5.3, page 238.</p>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#148-limplementation-du-service-web-json","title":"14.8. L'impl\u00e9mentation du service web / jSON","text":"<p>Le service web / jSON est impl\u00e9ment\u00e9 par la classe [ElectionsController] suivante\u00a0:</p> <pre><code>package elections.webjson.service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport elections.dao.entities.ElectionsConfig;\nimport elections.dao.entities.ElectionsException;\nimport elections.metier.service.IElectionsMetier;\n\n@Controller\npublic class ElectionsController {\n\n    // d\u00e9pendances Spring\n    @Autowired\n    private ObjectMapper jsonMapper;\n\n    @Autowired\n    private IElectionsMetier metier;\n\n    @RequestMapping(value = \"/getElectionsConfig\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String getElectionsConfig() throws JsonProcessingException {\n        // r\u00e9ponse\n        Response&lt;ElectionsConfig&gt; response;\n        try {\n            response = new Response&lt;&gt;(0, null,\n                    new ElectionsConfig(metier.getNbSiegesAPourvoir(), metier.getSeuilElectoral()));\n        } catch (ElectionsException e1) {\n            response = new Response&lt;&gt;(e1.getCode(), e1.getErreurs(), null);\n        } catch (RuntimeException e2) {\n            response = new Response&lt;&gt;(1000, getErreursForException(e2), null);\n        }\n        // r\u00e9ponse\n        return jsonMapper.writeValueAsString(response);\n    }\n\n    @RequestMapping(value = \"/getListesElectorales\", method = RequestMethod.GET, produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String getListesElectorales() throws JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not supported yet\");\n    }\n\n    @RequestMapping(value = \"/setListesElectorales\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\", produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String setListesElectorales(HttpServletRequest request) throws JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not supported yet\");\n    }\n\n    @RequestMapping(value = \"/calculerSieges\", method = RequestMethod.POST, consumes = \"application/json; charset=UTF-8\", produces = \"application/json; charset=UTF-8\")\n    @ResponseBody\n    public String calculerSieges(HttpServletRequest request) throws JsonProcessingException {\n        throw new UnsupportedOperationException(\"Not supported yet\");\n    }\n\n    // m\u00e9thodes priv\u00e9es -----------------------------\n    // liste des messages d'erreur d'une RuntimeException\n    private List&lt;String&gt; getErreursForException(Exception e) {\n        // on r\u00e9cup\u00e8re la liste des messages d'erreur de l'exception\n        Throwable cause = e;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        while (cause != null) {\n            // on r\u00e9cup\u00e8re le message seulement s'il est !=null et non blanc\n            String message = cause.getMessage();\n            if (message != null) {\n                message = message.trim();\n                if (message.length() != 0) {\n                    erreurs.add(message);\n                }\n            }\n            // cause suivante\n            cause = cause.getCause();\n        }\n        return erreurs;\n    }\n\n}\n</code></pre> <p>Travail \u00e0 faire\u00a0: en suivant ce qui a \u00e9t\u00e9 fait au paragraphe 13.5.5, page 236, compl\u00e9tez le code de la classe [ElectionsController].</p> <p>Notes\u00a0: </p> <ul> <li>il n'y a pas ici de filtres jSON car les tables [CONF] et [LISTES] ne sont pas li\u00e9es entre-elles par une relation de cl\u00e9 \u00e9trang\u00e8re, ce qui all\u00e8ge consid\u00e9rablement le code du service web\u00a0;</li> <li>ne pas oublier les diff\u00e9rentes annotations Spring n\u00e9cessaires\u00a0;</li> <li>on donnera aux URL le nom des m\u00e9thodes associ\u00e9es\u00a0;</li> <li>la m\u00e9thode [setListeElectorales] est appel\u00e9e avec une op\u00e9ration [POST]. La valeur post\u00e9e est le tableau des listes en comp\u00e9tition (de type ListeElectorale[]) avec leurs attributs [sieges, voix, elimine] qu'il faut enregistrer en base. Cette m\u00e9thode rend un type [Response&lt;Void&gt;] avec un champ [status=0] s'il n'y a pas eu d'erreur, autre chose sinon\u00a0;</li> <li>la m\u00e9thode [calculerSieges] est appel\u00e9e avec une op\u00e9ration [POST]. La valeur post\u00e9e est le tableau des listes en comp\u00e9tition (de type ListeElectorale[]) avec leurs attributs [nom, voix]. Cette m\u00e9thode rend un type [Response&lt;ListeElectorale[]&gt;] avec comme corps, les listes \u00e9lectorales avec leurs champs [sieges, elimine] initialis\u00e9s\u00a0;</li> </ul>"},{"location":"td-exposition-sur-le-web-de-la-couche-metier.html#149-tests","title":"14.9. Tests","text":"<p>Aor\u00e8s avoir lanc\u00e9 le service web, vous ferez les tests suivants pour vous assurer du bon fonctionnement du service web avec l'utilitaire [Advanced Rest Client]\u00a0:</p> <p>La r\u00e9ponse jSON \u00e0 la demande pr\u00e9c\u00e9dente est la suivante [1]\u00a0:</p> <p>1</p><p>2</p> <p>En [2], copier la r\u00e9ponse dans le presse-papiers puis copiez celui-ci dans un \u00e9diteur de texte quelconque [3]\u00a0:</p> <p>Isolez la valeur du champ [body] et changez par exemple les voix des listes. Ci-dessous [4], on passe \u00e0 100 les voix de toutes les listes\u00a0:</p> <p>V\u00e9rifiez que votre cha\u00eene jSON commence par [ et se termine par ]. Ces caract\u00e8res servent \u00e0 d\u00e9limiter un tableau jSON. En [5], collez la cha\u00eene jSON ci-dessus. Ce sera la valeur post\u00e9e pour la prochaine URL. Pour cela, il faut s\u00e9lectionner la m\u00e9thode HTTP [POST] [7].</p> <ul> <li>en [6], demandez l'URL [setListesElectorales]. Cette URL se demande avec un POST. La valeur post\u00e9e est le tableau jSON des listes en comp\u00e9tition dont il faut enregistrer les r\u00e9sultats en base\u00a0; On obtient le r\u00e9sultat suivant\u00a0:</li> </ul> <p>Le champ [status=0] indique qu'il n'y a pas eu d'erreur. Pour le v\u00e9rifier, redemandez les listes en comp\u00e9tition et v\u00e9rifiez que les modifications que vous aviez faites sur les listes ont \u00e9t\u00e9 prises en compte\u00a0:</p> <p>On refait un [POST] pour calculer les si\u00e8ges obtenus par les listes\u00a0:</p> <ul> <li>en [1]\u00a0: l'URL du calcul des si\u00e8ges\u00a0;</li> <li>en [2]\u00a0: on fait un [POST]\u00a0;</li> <li>en [3]\u00a0: les listes en comp\u00e9tition. On donne au champ [voix] les valeurs du TD, tous les [sieges] sont \u00e0 0, tous les champs [elimine] sont \u00e0 false\u00a0; Le r\u00e9sultat obtenu est le suivant\u00a0:</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html","title":"7. [TD]\u00a0: Impl\u00e9mentation de la couche [DAO] du TD avec l'API JDBC","text":"<p>Mots cl\u00e9s : bases de donn\u00e9es relationnelles, API JDBC, SQLException.</p> <p>Revenons sur l'architecture en couches de notre application :</p> <p>Les donn\u00e9es n\u00e9cessaires \u00e0 l'\u00e9lection sont enregistr\u00e9es dans une base de donn\u00e9es MySQL [dbelections]</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#71-support","title":"7.1. Support","text":"<p>Le dossier [support / chap-07] [1] contient\u00a0:</p> <ul> <li>les projets Eclipse de ce chapitre [2]\u00a0;</li> <li>le script SQL de cr\u00e9ation de la base MySQL [dbelections] [3]\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#72-la-base-de-donnees-dbelections","title":"7.2. La base de donn\u00e9es [dbelections]","text":"<p>Travail \u00e0 faire\u00a0: cr\u00e9ez la base MySQL [dblelections] en suivant la proc\u00e9dure suivie au paragraphe 6.4.2, page 85.</p> <p>La base [dbelections] est une base MySQL avec deux tables\u00a0:</p> <p>La table [conf] contient les informations de configuration de l'\u00e9lection\u00a0:</p> <ul> <li>[id]\u00a0: cl\u00e9 primaire auto-incr\u00e9ment\u00e9e\u00a0;</li> <li>[version]\u00a0: n\u00b0 de version de l'enregistrement - peut \u00eatre ignor\u00e9 ici\u00a0;</li> <li>[sap]\u00a0: nombre de si\u00e8ges \u00e0 pourvoir\u00a0;</li> <li>[seuilelectoral]\u00a0: la barre au-dessous de laquelle une liste est \u00e9limin\u00e9e\u00a0; Son contenu est le suivant\u00a0:</li> </ul> <p>La table [listes] contient les listes candidates de l'\u00e9lection\u00a0:</p> <ul> <li>[id]\u00a0: cl\u00e9 primaire auto-incr\u00e9ment\u00e9e\u00a0;</li> <li>[version]\u00a0: n\u00b0 de version de l'enregistrement - peut \u00eatre ignor\u00e9 ici\u00a0;</li> <li>[nom]\u00a0: nom de la liste\u00a0;</li> <li>[voix]\u00a0: voix de la liste - n'est connu qu'apr\u00e8s saisie de l'utilisateur dans la couche [pr\u00e9sentation]\u00a0;</li> <li>[sieges]\u00a0: nombre de si\u00e8ges obtenus - n'est connu qu'apr\u00e8s calcul de la couche [m\u00e9tier]\u00a0;</li> <li>[elimine]\u00a0: \u00e0 1 si la liste est \u00e9limin\u00e9e, \u00e0 0 sinon - n'est connu qu'apr\u00e8s calcul de la couche [m\u00e9tier]\u00a0; Le contenu de la table [listes] est le suivant\u00a0:</li> </ul> <p>Le script SQL pour g\u00e9n\u00e9rer la base [dbelections] s'appelle [dbelections.sql] et est sur le serveur. Son code est le suivant\u00a0:</p> <pre><code>-- phpMyAdmin SQL Dump\n-- version 4.0.4\n-- http://www.phpmyadmin.net\n--\n-- Client: localhost\n-- G\u00e9n\u00e9r\u00e9 le: Mer 11 Mars 2015 \u00e0 12:20\n-- Version du serveur: 5.6.12-log\n-- Version de PHP: 5.4.12\n\nSET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\nSET time_zone = \"+00:00\";\n\n\n/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;\n/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;\n/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;\n/*!40101 SET NAMES utf8 */;\n\n--\n-- Base de donn\u00e9es: `dbelections`\n--\nCREATE DATABASE IF NOT EXISTS `dbelections` DEFAULT CHARACTER SET utf8 COLLATE utf8_swedish_ci;\nUSE `dbelections`;\n\n-- --------------------------------------------------------\n\n--\n-- Structure de la table `conf`\n--\n\nCREATE TABLE IF NOT EXISTS `conf` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `version` int(11) NOT NULL DEFAULT '1',\n  `sap` tinyint(4) NOT NULL,\n  `seuilelectoral` double NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_swedish_ci AUTO_INCREMENT=2 ;\n\n--\n-- Contenu de la table `conf`\n--\n\nINSERT INTO `conf` (`id`, `version`, `sap`, `seuilelectoral`) VALUES\n(1, 1, 6, 0.05);\n\n-- --------------------------------------------------------\n\n--\n-- Structure de la table `listes`\n--\n\nCREATE TABLE IF NOT EXISTS `listes` (\n  `id` bigint(11) NOT NULL AUTO_INCREMENT,\n  `version` int(11) NOT NULL DEFAULT '1',\n  `nom` varchar(20) COLLATE utf8_swedish_ci NOT NULL,\n  `voix` int(11) NOT NULL,\n  `sieges` int(11) NOT NULL,\n  `elimine` tinyint(1) NOT NULL DEFAULT '0',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `nom` (`nom`)\n) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COLLATE=utf8_swedish_ci AUTO_INCREMENT=8 ;\n\n--\n-- Contenu de la table `listes`\n--\n\nINSERT INTO `listes` (`id`, `version`, `nom`, `voix`, `sieges`, `elimine`) VALUES\n(1, 21, 'A', 10, 1, 0),\n(2, 22, 'B', 20, 2, 0),\n(3, 21, 'C', 30, 3, 0),\n(4, 13, 'D', 40, 3, 0),\n(5, 17, 'E', 50, 6, 0),\n(6, 18, 'F', 60, 1, 0),\n(7, 19, 'G', 70, 2, 0);\n\n/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;\n/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;\n/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;\n</code></pre>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#73-le-projet-eclipse","title":"7.3. Le projet Eclipse","text":"<p>Le projet Eclipse de la couche [DAO] sera le suivant\u00a0:</p> <ul> <li>le package [elections.dao.entities] contient les objets manipul\u00e9s par la couche [DAO]\u00a0;</li> <li>le package [elections.dao.service] contient l'impl\u00e9mentation de la couche [DAO]\u00a0;</li> <li>le package [elections.dao.config] contient la configuration de la couche [DAO]</li> <li>le package [elections.dao.junit] contient une classe de test JUnit du projet\u00a0;</li> <li>le package [elections.dao.console] contient une classe ex\u00e9cutable de test\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#74-configuration-du-projet-maven","title":"7.4. Configuration du projet Maven","text":"<p>Le fichier [pom.xml] qui configure le projet Maven est le suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-dao-jdbc-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- MySQL --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Tomcat Jdbc --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- biblioth\u00e8que jSON --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Logging --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;archive&gt;\n                        &lt;manifest&gt;\n                            &lt;mainClass&gt;config.AppConfig&lt;/mainClass&gt;\n                        &lt;/manifest&gt;\n                    &lt;/archive&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;!-- pour l'installation de l'artifact du projet dans le d\u00e9p\u00f4t local Maven --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <p>Ce fichier est analogue \u00e0 celui d\u00e9crit au paragraphe 6.5.1, page 94. On y a apport\u00e9 les modifications suivantes\u00a0:</p> <ul> <li>lignes 8-12\u00a0: on a d\u00e9fini un projet Maven parent. Le projet [spring-boot-starter-parent] (ligne 10) d\u00e9finit un tr\u00e8s grand nombre de d\u00e9pendances avec leurs versions. Lorsqu'on utilise l'une d'elles (lignes 19-57), il est alors inutile d'en pr\u00e9ciser la version, celle-ci \u00e9tant d\u00e9finie dans le projet Maven parent\u00a0;</li> <li>lignes 40-51\u00a0: d\u00e9pendances n\u00e9cessaires \u00e0 la classe de test du projet. Ces d\u00e9pendances ont l'attribut [&lt;scope&gt;test&lt;/scope&gt;] qui signifie qu'elles ne sont n\u00e9cessaires que pour les classes du dossier [src / test / java]. Ces d\u00e9pendances ne seront pas incluses dans l'archive finale du projet\u00a0;</li> <li>lignes 53-56\u00a0: la biblioth\u00e8que [spring-boot-starter-logging] sera utilis\u00e9e par Spring pour faire des logs \u00e0 l'\u00e9cran\u00a0;</li> <li>lignes 14-17\u00a0: des propri\u00e9t\u00e9s de configuration Maven\u00a0:</li> <li>ligne 15\u00a0: indique que les fichiers source sont cod\u00e9s en UTF-8\u00a0;</li> <li>ligne 16\u00a0: indique que le compilateur \u00e0 utiliser doit \u00eatre de niveau 1.8\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#75-les-entites-de-la-couche-dao","title":"7.5. Les entit\u00e9s de la couche [DAO]","text":"<ul> <li>[ElectionsConfig] est le mod\u00e8le objet associ\u00e9 \u00e0 une ligne de la table [CONF]\u00a0;</li> <li>[ListeElectorale] est le mod\u00e8le objet associ\u00e9 \u00e0 une ligne de la table [LISTES]\u00a0;</li> <li>[AbstactEntity] est la classe parent des deux classes pr\u00e9c\u00e9dentes. Elle factorise les champs [id, version] communs aux deux classes\u00a0;</li> <li>[ElectionsException] est une classe d'exception\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#751-la-classe-electionsexception","title":"7.5.1. La classe [ElectionsException]","text":"<p>La classe [ElectionsException] a \u00e9t\u00e9 d\u00e9crite au paragraphe 4.3, page 39. Nous redonnons son code\u00a0:</p> <pre><code>package ...;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n// classe d'exception pour l'application Elections\n// l'exception est non contr\u00f4l\u00e9e\n\npublic class ElectionsException extends RuntimeException implements Serializable {\n\n    // serial ID\n    private static final long serialVersionUID = 1L;\n\n    // champs locaux\n    private int code;\n    private List&lt;String&gt; erreurs;\n\n    // constructeurs\n    public ElectionsException() {\n        super();\n    }\n\n    public ElectionsException(int code, Throwable e) {\n        // parent\n        super(e);\n        // local\n        this.code = code;\n        this.erreurs = getErreursForException(e);\n    }\n\n    public ElectionsException(int code, String message, Throwable e) {\n        // parent\n        super(message,e);\n        // local\n        this.code = code;\n        this.erreurs = getErreursForException(e);\n    }\n\n    public ElectionsException(int code, String message) {\n        // parent\n        super(message);\n        // local\n        this.code = code;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        erreurs.add(message);\n        this.erreurs = erreurs;\n    }\n\n    public ElectionsException(int code, List&lt;String&gt; erreurs) {\n        // parent\n        super();\n        // local\n        this.code = code;\n        this.erreurs = erreurs;\n    }\n\n    // liste des messages d'erreur d'une exception\n    private List&lt;String&gt; getErreursForException(Throwable th) {\n        // on r\u00e9cup\u00e8re la liste des messages d'erreur de l'exception\n        Throwable cause = th;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        while (cause != null) {\n            // on r\u00e9cup\u00e8re le message seulement s'il est !=null et non blanc\n            String message = cause.getMessage();\n            if (message != null) {\n                message = message.trim();\n                if (message.length() != 0) {\n                    erreurs.add(message);\n                }\n            }\n            // cause suivante\n            cause = cause.getCause();\n        }\n        return erreurs;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>Un objet [ElectionsException] est caract\u00e9ris\u00e9 par deux informations\u00a0:</p> <ul> <li>ligne 16\u00a0: un code d'erreur\u00a0;</li> <li>ligne 17\u00a0: une liste de messages d'erreur associ\u00e9s \u00e0 la pile des exceptions qui se sont produites\u00a0;</li> <li>la classe a 5 constructeurs (lignes 20, 24, 32, 40, 50)\u00a0;</li> <li>lignes 59-76\u00a0: la m\u00e9thode [getErreursForException] permet de r\u00e9cup\u00e9rer les messages d'erreur de la pile d'exceptions\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#752-la-classe-abstractentity","title":"7.5.2. La classe [AbstractEntity]","text":"<p>La classe [AbstractEntity] est la suivante\u00a0:</p> <pre><code>package elections.dao.entities;\n\nimport java.io.Serializable;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\npublic abstract class AbstractEntity implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    // champs\n    protected Long id;\n    protected Long version;\n\n    // constructeurs\n    public AbstractEntity() {\n\n    }\n\n    public AbstractEntity(Long id, Long version) {\n        this.id = id;\n        this.version = version;\n    }\n\n    // signature\n    public String toString() {\n        try {\n            return new ObjectMapper().writeValueAsString(this);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>Elle m\u00e9morise les champs [ID, NOM] des lignes des tables [CONF] et [LISTES] (lignes 8-9).</p> <ul> <li>ligne 8\u00a0: la classe a l'attribut [Abstract] indiquant qu'elle ne peut \u00eatre instanci\u00e9e. Elle ne peut \u00eatre que d\u00e9riv\u00e9e\u00a0;</li> <li>lignes 26-33\u00a0: signature jSON de l'objet\u00a0;</li> <li>ligne 28\u00a0: on retourne la cha\u00eene jSON de [this]. Si au moment de l'ex\u00e9cution, [this] repr\u00e9sente un objet d\u00e9riv\u00e9 de [AbstactEntity], c'est la cha\u00eene jSON de l'objet d\u00e9riv\u00e9 qui est obtenue. Les classes d\u00e9riv\u00e9es n'auront ainsi pas besoin de d\u00e9finir une m\u00e9thode [toString]. Celle de la classe parent est suffisante\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#753-la-classe-electionsconfig","title":"7.5.3. La classe [ElectionsConfig]","text":"<p>La classe [ElectionsConfig] est la suivante\u00a0:</p> <pre><code>package elections.dao.entities;\n\n\npublic class ElectionsConfig extends AbstractEntity {\n\n    private static final long serialVersionUID = 1L;\n    // champs\n    private int nbSiegesAPourvoir;\n    private double seuilElectoral;\n\n    // constructeurs\n    public ElectionsConfig() {\n    }\n\n    public ElectionsConfig(Long id, Long version, int nbSiegesAPourvoir, double seuilElectoral) {\n        // parent\n        super(id, version);\n        // champs locaux\n        this.nbSiegesAPourvoir = nbSiegesAPourvoir;\n        this.seuilElectoral = seuilElectoral;\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <ul> <li>ligne 4\u00a0: la classe \u00e9tend la classe [AbstractEntity]\u00a0;</li> <li>lignes 8-9\u00a0: m\u00e9morisent les informations des colonnes [SAP, SEUILELECTORAL] de la table [CONF]\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#754-la-classe-listeelectorale","title":"7.5.4. La classe [ListeElectorale]","text":"<p>La classe [ListeElectorale] est la suivante\u00a0:</p> <pre><code>package elections.dao.entities;\n\npublic class ListeElectorale extends AbstractEntity {\n\n    // champs\n    private String nom;\n    private int voix;\n    private int sieges;\n    private boolean elimine;\n\n    // constructeurs\n    public ListeElectorale() {\n    }\n\n    public ListeElectorale(String nom, int voix, int sieges, boolean elimine) {\n        // parent\n        super();\n        // champs locaux\n        initNom(nom);\n        initVoix(voix);\n        initSieges(sieges);\n        this.elimine=elimine;\n    }\n\n    public ListeElectorale(Long id, Long version, String nom, int voix, int sieges, boolean elimine) {\n        // parent\n        super(id, version);\n        // champs locaux\n        initNom(nom);\n        initVoix(voix);\n        initSieges(sieges);\n        this.elimine=elimine;\n    }\n\n    // m\u00e9thodes priv\u00e9es\n    private void initNom(String nom) {\n        this.nom = nom.trim();\n        if (\"\".equals(nom)) {\n            throw new ElectionsException(10, \"Le nom ne peut \u00eatre vide\");\n        }\n    }\n\n    private void initVoix(int voix) {\n        this.voix = voix;\n        if (voix &lt; 0) {\n            throw new ElectionsException(11, \"Le nombre de voix ne peut \u00eatre &lt;0\");\n        }\n    }\n\n    private void initSieges(int sieges) {\n        this.sieges = sieges;\n        if (sieges &lt; 0) {\n            throw new ElectionsException(12, \"Le nombre de si\u00e8ges ne peut \u00eatre &lt;0\");\n        }\n    }\n\n    // getters et setters\n\n    public String getNom() {\n        return nom;\n    }\n\n    public void setNom(String nom) {\n        initNom(nom);\n    }\n\n    public int getVoix() {\n        return voix;\n    }\n\n    public void setVoix(int voix) {\n        initVoix(voix);\n    }\n\n    public int getSieges() {\n        return sieges;\n    }\n\n    public void setSieges(int sieges) {\n        initSieges(sieges);\n    }\n\n    public boolean isElimine() {\n        return elimine;\n    }\n\n    public void setElimine(boolean elimine) {\n        this.elimine = elimine;\n    }\n\n}\n</code></pre> <ul> <li>ligne 3\u00a0: la classe \u00e9tend la classe [AbstractEntity]\u00a0;</li> <li>lignes 6-9\u00a0: la classe m\u00e9morise les colonnes [NOM, VOIX, SIEGES, ELIMINE] de la table [LISTES]\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#76-configuration-spring-de-la-couche-dao","title":"7.6. Configuration Spring de la couche [DAO]","text":"<p>La classe [AppConfig] est une classe de configuration Spring qui configure l'acc\u00e8s \u00e0 la base de donn\u00e9es de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.dao.config;\n\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.cache.concurrent.ConcurrentMapCacheManager;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@ComponentScan(basePackages = { \"elections.dao.service\" })\n@EnableCaching\npublic class AppConfig {\n\n    // constantes\n    public final static String URL = \"jdbc:mysql://localhost:3306/dbelections\";\n    public final static String USER = \"root\";\n    public final static String PASSWD = \"\";\n    public final static String DRIVER_CLASSNAME = \"com.mysql.jdbc.Driver\";\n    public final static String SELECT_LISTES = \"SELECT ID, VERSION, NOM, VOIX, SIEGES, ELIMINE FROM LISTES\";\n    public final static String SELECT_CONF = \"SELECT ID, VERSION, SAP, SEUILELECTORAL, SAP FROM CONF\";\n    public final static String UPDATE_LISTES = \"UPDATE LISTES SET VOIX=?, SIEGES=?, ELIMINE=? WHERE ID=?\";\n\n    @Bean\n    public DataSource dataSource() {\n        // source de donn\u00e9es TomcatJdbc\n        DataSource dataSource = new DataSource();\n        // configuration acc\u00e8s JDBC\n        dataSource.setDriverClassName(DRIVER_CLASSNAME);\n        dataSource.setUsername(USER);\n        dataSource.setPassword(PASSWD);\n        dataSource.setUrl(URL);\n        // une connexion ouverte initialement\n        dataSource.setInitialSize(1);\n        // r\u00e9sultat\n        return dataSource;\n    }\n\n    @Bean\n    public CacheManager cacheManager() {\n        return new ConcurrentMapCacheManager(\"electionsConfig\");\n    }\n}\n</code></pre> <ul> <li>lignes 25-38\u00a0: l'acc\u00e8s \u00e0 la BD se fera via une source de donn\u00e9es [tomcat-jdbc]. Ce type de source a \u00e9t\u00e9 utilis\u00e9e et expliqu\u00e9e au paragraphe 6.5, page 94\u00a0;</li> <li>lignes 17-23\u00a0: un ensemble de constantes statiques accessibles par toutes les classes du projet\u00a0;</li> <li>ligne 13\u00a0: l'annotation [@Configuration] fait de la classe [AppConfig] une classe de configuration Spring\u00a0;</li> <li>ligne 11\u00a0: l'annotation [@ComponentScan] indique les packages o\u00f9 on peut trouver des objets Spring. Ici, nous allons d\u00e9finir un objet Spring dans le package [dao]. L'annotation [@ComponentScan] fait de la classe une classe de configuration qui nous \u00e9pargne de mettre l'annotation [@Configuration]\u00a0;</li> <li>la ligne 12 active la gestion d'un cache. Le principe est la suivant\u00a0:</li> <li>on met l'annotation [@Cacheable('nom_du_cache')] \u00e0 une m\u00e9thode M. Le 'nom_du-cache' est le nom utilis\u00e9 ligne 41\u00a0;</li> <li>lorsque la m\u00e9thode M est appel\u00e9e la 1\u00e8re fois, ses r\u00e9sultats sont rendus et \u00e9galement mis dans le cache nomm\u00e9 par l'annotation\u00a0;</li> <li>lorsque la m\u00e9thode M est appel\u00e9e les fois suivantes avec les m\u00eames param\u00e8tres que la 1\u00e8re fois, elle n'est pas ex\u00e9cut\u00e9e et Spring se contente de rendre les valeurs mises en cache\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#77-configuration-des-logs","title":"7.7. Configuration des logs","text":"<p>Les biblioth\u00e8ques de logs sont d\u00e9finies par la d\u00e9pendance suivante dans [pom.xml]\u00a0:</p> <pre><code>        &lt;!-- Spring Boot Logging --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Cette d\u00e9pendance am\u00e8ne les biblioth\u00e8ques suivantes\u00a0:</p> <p>C'est la biblioth\u00e8que [logback] qui va assurer les logs. Elle est configur\u00e9e par deux fichiers\u00a0:</p> <ul> <li>[logback.xml] pour la branche principale du code\u00a0;</li> <li> <p>[logback-test.xml] pour la branche de test du code. En l'absence de ce fichier, le fichier pr\u00e9c\u00e9dent est alors utilis\u00e9\u00a0; Ces deux fichiers doivent se trouver dans le [Classpath] du projet. Pour cette raison, ils sont plac\u00e9s dans le dossier\u00a0:</p> </li> <li> <p>[src / main / ressources] pour la branche principale du code\u00a0;</p> </li> <li>[src / test / ressources] pour la branche de test du code\u00a0; Le contenu des fichiers est ici le m\u00eame\u00a0:</li> </ul> <pre><code>&lt;configuration&gt; \n\n  &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; \n    &lt;!-- encoders are  by default assigned the type\n         ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;\n    &lt;encoder&gt;\n      &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n    &lt;/encoder&gt;\n  &lt;/appender&gt;\n\n  &lt;!-- contr\u00f4le niveau des logs --&gt;\n  &lt;root level=\"info\"&gt; &lt;!-- info, debug, warn --&gt;\n    &lt;appender-ref ref=\"STDOUT\" /&gt;\n  &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>Tout se passe ligne 12 o\u00f9 on fixe le niveau d'information d\u00e9sir\u00e9\u00a0:</p> <ul> <li>[debug]\u00a0: le niveau le plus d\u00e9taill\u00e9\u00a0;</li> <li>[off]\u00a0: pas de logs\u00a0;</li> <li>[info]\u00a0: le niveau normal des logs\u00a0;</li> <li>[warn]\u00a0: idem niveau [info] plus les messages d'avertissement (warning). Ces messages indiquent une possibilit\u00e9 d'erreur\u00a0; Passez en mode [debug] d\u00e8s que des erreurs apparaissent \u00e0 l'ex\u00e9cution.</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#78-implementation-de-la-couche-dao","title":"7.8. Impl\u00e9mentation de la couche [DAO]","text":"<p>L'interface [IDao] de la couche [DAO] est la suivante\u00a0:</p> <pre><code>package istia.st.elections.webapi.client.dao;\n\nimport istia.st.elections.webapi.client.entities.ElectionsConfig;\nimport istia.st.elections.webapi.client.entities.ListeElectorale;\n\npublic interface IDao {\n    // configuration des \u00e9lections\n    public ElectionsConfig getElectionsConfig();\n\n    // les listes en comp\u00e9tition\n    public ListeElectorale[] getListesElectorales();\n\n    // sauvegarde des r\u00e9sultats de l'\u00e9lection\n    public void setListesElectorales(ListeElectorale[] listesElectorales);\n\n}\n</code></pre> <p>Le squelette de la classe [ElectionsDaoJdbc] impl\u00e9mentant la couche [dao] avec une base de donn\u00e9es sera le suivant :</p> <pre><code>package elections.dao.service;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport org.apache.tomcat.jdbc.pool.DataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Component;\n\nimport elections.dao.entities.ElectionsConfig;\nimport elections.dao.entities.ElectionsException;\nimport elections.dao.entities.ListeElectorale;\n\n@Component\n@SuppressWarnings(\"unused\")\npublic class ElectionDaoJdbc implements IElectionsDao {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @Cacheable(\"electionsConfig\")\n    // obtention conf de l'\u00e9lection\n    public ElectionsConfig getElectionsConfig() {\n        throw new RuntimeException(\"[getElectionsConfig] not yet implemented\");\n    }\n\n    // obtention des listes\n    public ListeElectorale[] getListesElectorales() {\n        throw new RuntimeException(\"[getListesElectorales] not yet implemented\");\n    }\n\n    // modification des listes [voix, sieges, elimine]\n    public void setListesElectorales(ListeElectorale[] listesElectorales) {\n        throw new RuntimeException(\"[setListesElectorales] not yet implemented\");\n    }\n\n    // -------------------- m\u00e9thodes priv\u00e9es\n\n    // gestion du finally\n    private ElectionsException doFinally(int code, ResultSet rs, PreparedStatement ps, Connection connexion) {\n        // fermeture ResultSet\n        if (rs != null) {\n            try {\n                rs.close();\n            } catch (SQLException e1) {\n\n            }\n        }\n        // fermeture [PreparedStatement]\n        if (ps != null) {\n            try {\n                ps.close();\n            } catch (SQLException e2) {\n\n            }\n        }\n        // fermer la connexion\n        if (connexion != null) {\n            try {\n                connexion.close();\n            } catch (SQLException e3) {\n                // on retourne une [ElectionsException]\n                return new ElectionsException(code, e3);\n            }\n        }\n        // pas d'exception\n        return null;\n    }\n\n    // gestion du catch\n    private ElectionsException doCatchException(int code1, int code2, Connection connexion, Throwable th) {\n        // on g\u00e9n\u00e8re une [ElectionsException]\n        ElectionsException ex1 = new ElectionsException(code1, th);\n        // annulation transaction\n        try {\n            if (connexion != null) {\n                connexion.rollback();\n            }\n        } catch (SQLException e2) {\n        }\n        // on retourne l'exception\n        return ex1;\n    }\n}\n</code></pre> <ul> <li>ligne 24\u00a0: l'annotation [@Cacheable] est une annotation Spring qui demande de mettre en m\u00e9moire ('cacher') les r\u00e9sultats de la m\u00e9thode [getElectionsConfig]. Il est possible de faire cela ici parce que le contenu de la table [CONF] ne change jamais. Il ne serait pas possible de mettre cette annotation sur la m\u00e9thode [getListesElectorales] car le contenu de la table [LISTES] change au cours du temps\u00a0;</li> <li>les m\u00e9thodes [doCatchException] et [doFinally] retournent un type [ElectionsException]. La m\u00e9thode [doFinally] rend un pointeur null si la lib\u00e9ration des ressources s'est faite sans erreurs\u00a0; Travail \u00e0 faire : \u00e9crivez la classe [ElectionDaoJdbc] en vous inspirant de la classe [IntroJdbc02] \u00e9tudi\u00e9e au paragraphe 6.5.2, page 96.</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#79-la-classe-de-test-main","title":"7.9. La classe de test [Main]","text":"<p>La classe [Main] est la suivante\u00a0:</p> <pre><code>package elections.dao.console;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport elections.dao.config.AppConfig;\nimport elections.dao.entities.ElectionsConfig;\nimport elections.dao.entities.ElectionsException;\nimport elections.dao.entities.ListeElectorale;\nimport elections.dao.service.IElectionsDao;\n\npublic class Main {\n\n    // source de donn\u00e9es\n    private static IElectionsDao dao;\n\n    public static void main(String[] args) {\n        // on r\u00e9cup\u00e8re la r\u00e9f\u00e9rence de la couche [DAO] apr\u00e8s avoir instanci\u00e9 le contexte Spring\n        try (AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class)) {\n            // r\u00e9cup\u00e9ration de la source de donn\u00e9es\n            dao = ctx.getBean(IElectionsDao.class);\n        } catch (Exception e) {\n            System.out.println(\"Les erreurs suivantes se sont produites lors de l'initialisation du contexte Spring -------\");\n            for (String erreur : getErreursForThrowable(e)) {\n                System.out.println(erreur);\n            }\n            // fin\n            return;\n        }\n        // lecture de la BD\n        ElectionsConfig electionsConfig = null;\n        ListeElectorale[] listes;\n        try {\n            // contenu des deux tables\n            electionsConfig = dao.getElectionsConfig();\n            listes = dao.getListesElectorales();\n        } catch (ElectionsException e) {\n            System.out.println(\"Les erreurs suivantes se sont produites lors de la lecture des tables ----------\");\n            for (String erreur : e.getErreurs()) {\n                System.out.println(erreur);\n            }\n            // fin\n            return;\n        }\n        // tout s'est bien pass\u00e9 - affichage\n        System.out.println(String.format(\"Nombre de si\u00e8ges \u00e0 pourvoir : %d\", electionsConfig.getNbSiegesAPourvoir()));\n        System.out.println(String.format(\"Seuil \u00e9lectoral : %5.2f\", electionsConfig.getSeuilElectoral()));\n        System.out.println(\"Listes candidates----------------\");\n        for (ListeElectorale liste : listes) {\n            System.out.println(liste);\n        }\n    }\n\n    // m\u00e9thodes priv\u00e9es ------------------\n    private static List&lt;String&gt; getErreursForThrowable(Throwable th) {\n        // on r\u00e9cup\u00e8re la liste des messages d'erreur de l'exception\n        Throwable cause = th;\n        List&lt;String&gt; erreurs = new ArrayList&lt;&gt;();\n        while (cause != null) {\n            // on r\u00e9cup\u00e8re le message seulement s'il est !=null et non blanc\n            String message = cause.getMessage();\n            if (message != null) {\n                message = message.trim();\n                if (message.length() != 0) {\n                    erreurs.add(message);\n                }\n            }\n            // cause suivante\n            cause = cause.getCause();\n        }\n        return erreurs;\n    }\n\n}\n</code></pre> <ul> <li>lignes 21-31\u00a0: r\u00e9cup\u00e9ration d'une r\u00e9f\u00e9rence sur la couche [DAO]\u00a0;</li> <li> <p>ligne 21\u00a0: on utilise une syntaxe appel\u00e9e try_with_resources. Sa syntaxe est la suivante\u00a0: <pre><code>try (T ressource=expression) {\n            // exploitation de ressource\n...\n}\n</code></pre></p> </li> <li> <p>le type T de la ligne 1 doit impl\u00e9menter l'interface [java.lang.AutoCloseable]\u00a0;</p> </li> <li>\u00e0 la sortie du bloc des lignes 1-4, la ressource de type [java.lang.AutoCloseable] est automatiquement lib\u00e9r\u00e9e qu'il y ait eu exception ou pas. Ceux qui connaissent le langage C# reconna\u00eetront l\u00e0 un fr\u00e8re syntaxique et fonctionnel de la clause using (T ressource=expression)\u00a0;</li> <li>lignes 40-49\u00a0: utilisation de la couche [DAO] pour obtenir le contenu des tables [CONF] et [LISTES]\u00a0;</li> <li>lignes 41-47\u00a0: on teste le cache [electionsconfig]. Celui-ci a \u00e9t\u00e9 d\u00e9fini \u00e0 deux endroits\u00a0:</li> <li> <p>dans la classe [ElectionsDaoJdbc]\u00a0: <pre><code>  @Cacheable(\"electionsConfig\")\n  public ElectionsConfig getElectionsConfig() {\n</code></pre></p> </li> <li> <p>dans la classe de configuration [AppConfig]\u00a0: <pre><code>@EnableCaching\npublic class AppConfig {\n...\n  @Bean\n  public CacheManager cacheManager() {\n    return new ConcurrentMapCacheManager(\"electionsConfig\");\n  }\n}\n</code></pre></p> </li> <li> <p>ligne 59\u00a0: fermeture du contexte Spring\u00a0;</p> </li> <li>lignes 62-67\u00a0: affichage des informations obtenues\u00a0; Les r\u00e9sultats obtenus avec une couche [DAO] impl\u00e9ment\u00e9e sont les suivants\u00a0:</li> </ul> <pre><code>...\nd\u00e9but requ\u00eate 1 : 11:09:29:752\nfin requ\u00eate 1 et d\u00e9but requ\u00eate 2: 11:09:30:132\nfin requ\u00eate 2 : 11:09:30:133\n...\nNombre de si\u00e8ges \u00e0 pourvoir : 6\nSeuil \u00e9lectoral :  0,05\nListes candidates----------------\n{\"id\":1,\"version\":9,\"nom\":\"A\",\"voix\":32000,\"sieges\":2,\"elimine\":false}\n{\"id\":2,\"version\":13,\"nom\":\"B\",\"voix\":25000,\"sieges\":2,\"elimine\":false}\n{\"id\":3,\"version\":14,\"nom\":\"C\",\"voix\":16000,\"sieges\":1,\"elimine\":false}\n{\"id\":4,\"version\":13,\"nom\":\"D\",\"voix\":12000,\"sieges\":1,\"elimine\":false}\n{\"id\":5,\"version\":14,\"nom\":\"E\",\"voix\":8000,\"sieges\":0,\"elimine\":false}\n{\"id\":6,\"version\":13,\"nom\":\"F\",\"voix\":4500,\"sieges\":0,\"elimine\":true}\n{\"id\":7,\"version\":13,\"nom\":\"G\",\"voix\":2500,\"sieges\":0,\"elimine\":true}\n</code></pre> <ul> <li>lignes 2-4\u00a0: montrent l'influence du cache\u00a0:</li> <li>la requ\u00eate 1 dure 80 millisecondes\u00a0;</li> <li>la requ\u00eate 2 dure 1 milliseconde\u00a0; Lorsque la base de donn\u00e9es est coup\u00e9e on obtient les r\u00e9sultats suivants\u00a0:</li> </ul> <pre><code>Les erreurs suivantes se sont produites lors de la lecture des tables ----------\nCommunications link failure\n\nThe last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.\nConnection refused: connect\n</code></pre>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#710-tests-junit-de-la-classe-electionsdaojdbc","title":"7.10. Tests JUnit de la classe [ElectionsDaoJdbc]","text":"<p>La classe [Test01] est la classe de test [JUnit] suivante\u00a0:</p> <pre><code>package elections.dao.junit;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport elections.dao.config.AppConfig;\nimport elections.dao.entities.ElectionsConfig;\nimport elections.dao.entities.ListeElectorale;\nimport elections.dao.service.IElectionsDao;\n\n\n@SpringApplicationConfiguration(classes = AppConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // couche [DAO]\n    @Autowired\n    private IElectionsDao electionsDao;\n\n    @Before\n    public void init() {\n        // on nettoie la table [LISTES]\n        // listes en comp\u00e9tition\n        ListeElectorale[] listes = electionsDao.getListesElectorales();\n        // on met \u00e0 0 les voix et si\u00e8ges et elimine \u00e0 false\n        int voix = 0;\n        int si\u00e8ges = 0;\n        boolean elimine = false;\n        for (ListeElectorale liste : listes) {\n            liste.setVoix(voix);\n            liste.setSieges(si\u00e8ges);\n            liste.setElimine(elimine);\n        }\n        // on rend ces donn\u00e9es persistantes gr\u00e2ce \u00e0 la couche [dao]\n        electionsDao.setListesElectorales(listes);\n    }\n\n    @Test\n    public void testElections01() {\n        ...\n    }\n}\n</code></pre> <ul> <li>ligne 17\u00a0: l'annotation [RunWith] qui est une annotation [JUnit] (ligne 6) assure l'int\u00e9gration avec Spring via la classe [SpringJUnit4ClassRunner]\u00a0;</li> <li>ligne 16\u00a0: l'annotation [SpringApplicationConfiguration] est une annotation [Spring] (ligne 8) qui permet de d\u00e9signer les classes de configuration du test JUnit. Ici on d\u00e9signe la classe [AppConfig] utilis\u00e9e pour configurer le projet. On dispose alors de tous les objets Spring d\u00e9finis par cette classe de configuration. C'est ainsi qu'on peut injecter lignes 21-22 une r\u00e9f\u00e9rence sur la couche [DAO] qui va \u00eatre test\u00e9e\u00a0;</li> <li>ligne 25\u00a0: l'annotation [Before] d\u00e9signe une m\u00e9thode qui doit \u00eatre ex\u00e9cut\u00e9e avant chaque test\u00a0;</li> <li>lignes 26-41\u00a0: la m\u00e9thode [init] met les voix et si\u00e8ges des listes de la table [LISTES] \u00e0 z\u00e9ro et le bool\u00e9en [elimine] \u00e0 [false]\u00a0; L'unique m\u00e9thode de test est la suivante\u00a0:</li> </ul> <pre><code>@Test\n    public void testElections01() {\n        System.out.println(\"testElections01-------------------------------------\");\n        // r\u00e9cup\u00e9ration de la configuration des \u00e9lections\n        ElectionsConfig electionsConfig = electionsDao.getElectionsConfig();\n        int nbSiegesAPourvoir = electionsConfig.getNbSiegesAPourvoir();\n        double seuilElectoral = electionsConfig.getSeuilElectoral();\n        Assert.assertEquals(6, nbSiegesAPourvoir);\n        Assert.assertEquals(0.05, seuilElectoral, 1E-6);\n\n        // listes en comp\u00e9tition\n        ListeElectorale[] listes = electionsDao.getListesElectorales();\n        // affichage valeurs lues\n        System.out.println(\"Nombre de si\u00e8ges \u00e0 pourvoir : \" + nbSiegesAPourvoir);\n        System.out.println(\"Seuil \u00e9lectoral : \" + seuilElectoral);\n        System.out.println(\"Listes en comp\u00e9tition ---------------------\");\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(listes[i]);\n        }\n\n        // on affecte des voix et des si\u00e8ges aux listes\n        int voix = 0;\n        int si\u00e8ges = 0;\n        boolean elimine = false;\n        for (ListeElectorale liste : listes) {\n            liste.setVoix(voix);\n            liste.setSieges(si\u00e8ges);\n            liste.setElimine(elimine);\n            voix += 10;\n            si\u00e8ges += 1;\n            elimine = !elimine;\n        }\n\n        // on rend ces donn\u00e9es persistantes gr\u00e2ce \u00e0 la couche [dao]\n        electionsDao.setListesElectorales(listes);\n\n        // on relit les donn\u00e9es\n        ListeElectorale[] listesElectorales2 = electionsDao.getListesElectorales();\n        // on v\u00e9rifie les donn\u00e9es lues\n        Assert.assertEquals(7, listesElectorales2.length);\n        voix = 0;\n        si\u00e8ges = 0;\n        elimine = false;\n        for (ListeElectorale liste : listesElectorales2) {\n            Assert.assertEquals(voix, liste.getVoix());\n            Assert.assertEquals(si\u00e8ges, liste.getSieges());\n            Assert.assertEquals(elimine, liste.isElimine());\n            voix += 10;\n            si\u00e8ges += 1;\n            elimine = !elimine;\n        }\n        System.out.println(\"Listes en comp\u00e9tition ---------------------\");\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(listes[i]);\n        }\n    }\n</code></pre> <ul> <li>lignes 5-9\u00a0: on s'assure qu'on est capable de r\u00e9cup\u00e9rer le contenu de la table [CONF]\u00a0;</li> <li>lignes 11-19\u00a0: on affiche le contenu de la table [LISTES]. Il n'y a pas de tests ici, seulement un contr\u00f4le visuel\u00a0;</li> <li>lignes 21-35\u00a0: on modifie en base, la table [LISTES] en donnant aux listes des valeurs pour leurs champs [voix, sieges, elimine]\u00a0;</li> <li>lignes 37-51\u00a0: on relit la table [LISTES] et on v\u00e9rifie que ce qui est obtenu est bien \u00e9gal \u00e0 ce qui a \u00e9t\u00e9 mis\u00a0;</li> <li>lignes 52-55\u00a0: v\u00e9rification visuelle\u00a0; Les r\u00e9sultats console obtenus avec une couche [DAO] impl\u00e9ment\u00e9e sont les suivants\u00a0:</li> </ul> <pre><code>mars 11, 2015 4:50:00 PM org.springframework.test.context.support.DefaultTestContextBootstrapper getDefaultTestExecutionListenerClassNames\nINFOS: Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener]\nmars 11, 2015 4:50:00 PM org.springframework.test.context.support.DefaultTestContextBootstrapper instantiateListeners\nINFOS: Could not instantiate TestExecutionListener [org.springframework.test.context.transaction.TransactionalTestExecutionListener]. Specify custom listener classes or make the default listener classes (and their required dependencies) available. Offending class: [org/springframework/transaction/interceptor/TransactionAttributeSource]\nmars 11, 2015 4:50:00 PM org.springframework.test.context.support.DefaultTestContextBootstrapper instantiateListeners\nINFOS: Could not instantiate TestExecutionListener [org.springframework.test.context.web.ServletTestExecutionListener]. Specify custom listener classes or make the default listener classes (and their required dependencies) available. Offending class: [javax/servlet/ServletContext]\nmars 11, 2015 4:50:00 PM org.springframework.test.context.support.DefaultTestContextBootstrapper instantiateListeners\nINFOS: Could not instantiate TestExecutionListener [org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener]. Specify custom listener classes or make the default listener classes (and their required dependencies) available. Offending class: [org/springframework/transaction/interceptor/TransactionAttribute]\nmars 11, 2015 4:50:00 PM org.springframework.test.context.support.DefaultTestContextBootstrapper getTestExecutionListeners\nINFOS: Using TestExecutionListeners: [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@483bf400, org.springframework.test.context.support.DirtiesContextTestExecutionListener@21a06946]\n\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::        (v1.2.2.RELEASE)\n\n[2015-03-11 16:50:01.272] - 11696 INFOS [main] --- org.eclipse.jdt.internal.junit.runner.RemoteTestRunner: Starting RemoteTestRunner on Gportpers3 with PID 11696 (started by ST in D:\\data\\istia-1415\\eclipse\\intro-jdbc\\elections-jdbc-01)\n[2015-03-11 16:50:01.317] - 11696 INFOS [main] --- org.springframework.context.annotation.AnnotationConfigApplicationContext: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@74ad1f1f: startup date [Wed Mar 11 16:50:01 CET 2015]; root of context hierarchy\nmars 11, 2015 4:50:01 PM org.eclipse.jdt.internal.junit.runner.RemoteTestRunner logStarted\nINFOS: Started RemoteTestRunner in 0.775 seconds (JVM running for 1.433)\ntestElections01-------------------------------------\nNombre de si\u00e8ges \u00e0 pourvoir : 6\nSeuil \u00e9lectoral : 0.05\nListes en comp\u00e9tition ---------------------\n{\"id\":1,\"version\":21,\"nom\":\"A\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":2,\"version\":22,\"nom\":\"B\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":3,\"version\":21,\"nom\":\"C\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":4,\"version\":13,\"nom\":\"D\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":5,\"version\":17,\"nom\":\"E\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":6,\"version\":18,\"nom\":\"F\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":7,\"version\":19,\"nom\":\"G\",\"voix\":0,\"sieges\":0,\"elimine\":false}\nListes en comp\u00e9tition ---------------------\n{\"id\":1,\"version\":21,\"nom\":\"A\",\"voix\":0,\"sieges\":0,\"elimine\":false}\n{\"id\":2,\"version\":22,\"nom\":\"B\",\"voix\":10,\"sieges\":1,\"elimine\":true}\n{\"id\":3,\"version\":21,\"nom\":\"C\",\"voix\":20,\"sieges\":2,\"elimine\":false}\n{\"id\":4,\"version\":13,\"nom\":\"D\",\"voix\":30,\"sieges\":3,\"elimine\":true}\n{\"id\":5,\"version\":17,\"nom\":\"E\",\"voix\":40,\"sieges\":4,\"elimine\":false}\n{\"id\":6,\"version\":18,\"nom\":\"F\",\"voix\":50,\"sieges\":5,\"elimine\":true}\n{\"id\":7,\"version\":19,\"nom\":\"G\",\"voix\":60,\"sieges\":6,\"elimine\":false}\n</code></pre> <ul> <li>lignes 1-23\u00a0: logs de Spring Test\u00a0;</li> <li>lignes 25-26\u00a0: le contenu de la table [CONF]\u00a0;</li> <li>lignes 27-34\u00a0: le contenu initial de la table [LISTES]\u00a0;</li> <li>lignes 35-42\u00a0: le contenu de la table [LISTES] apr\u00e8s affectation de valeurs aux champs [voix, sieges, elimine]\u00a0; Par ailleurs le test JUnit r\u00e9ussit\u00a0:</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#711-creation-de-larchive-with-dependencies-de-la-couche-dao","title":"7.11. Cr\u00e9ation de l'archive [with-dependencies] de la couche [dao]","text":"<p>Le projet final a l'architecture suivante\u00a0:</p> <p>Rappelons la configuration Maven du projet\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-dao-jdbc-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- MySQL --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Tomcat Jdbc --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- biblioth\u00e8que jSON --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Logging --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;archive&gt;\n                        &lt;manifest&gt;\n                            &lt;mainClass&gt;config.AppConfig&lt;/mainClass&gt;\n                        &lt;/manifest&gt;\n                    &lt;/archive&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;!-- pour l'installation de l'artifact du projet dans le d\u00e9p\u00f4t local Maven --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <p>Nous allons g\u00e9n\u00e9rer un unique jar qui contiendra les classes de tous les jars ci-dessus plus celles du projet de la couche [DAO]. Cela se fait \u00e0 l'aide d'une modification dans le fichier [pom.xml]\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-jdbc-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        ...\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;archive&gt;\n                        &lt;manifest&gt;\n                            &lt;mainClass&gt;console.Main&lt;/mainClass&gt;\n                        &lt;/manifest&gt;\n                    &lt;/archive&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 25-37\u00a0: configurent un plugin Maven pour g\u00e9n\u00e9rer le jar\u00a0;</li> <li>ligne 15\u00a0: indique la version de Java \u00e0 utiliser pour la compilation\u00a0; Une fois cette modification faite, on peut g\u00e9n\u00e9rer le jar de la fa\u00e7on suivante [1-10]\u00a0:</li> </ul> <ul> <li>en [5], mettre le dossier du projet en utilisant le bouton [6]\u00a0;</li> <li>en [7], donner un nom \u00e0 la configuration d'ex\u00e9cution\u00a0;</li> <li>en [8], mettre la liste des buts Maven \u00e0 ex\u00e9cuter\u00a0:</li> <li>[clean]\u00a0: vide le dossier [target] du projet dans lequel va \u00eatre plac\u00e9 le jar g\u00e9n\u00e9r\u00e9\u00a0;</li> <li>[compile]\u00a0: compile le projet\u00a0;</li> <li>[assembly:single]\u00a0: g\u00e9n\u00e8re un unique jar comprenant toutes les classes du projet et de ses d\u00e9pendances\u00a0;</li> </ul> <ul> <li>en [9-10], v\u00e9rifiez que vous avez un JDK (Java Development Kit) et non un JRE (Java Runtime Environment). La diff\u00e9rence est que le JDK a un compilateur et pas le JRE. Si vous n'avez pas un JDK, il vous faut en ajouter un dans [10] avec [11]. Pour cela, suivre la proc\u00e9dure d\u00e9crite au paragraphe 3.1, page 16\u00a0;</li> </ul> <ul> <li>en [17], ex\u00e9cutez la configuration d'ex\u00e9cution\u00a0;</li> <li>en [13], l'archive g\u00e9n\u00e9r\u00e9e\u00a0; On peut ouvrir cette archive avec un d\u00e9zippeur\u00a0:</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-lx27api-jdbc.html#712-test-de-larchive-de-la-couche-dao","title":"7.12. Test de l'archive de la couche [DAO]","text":"<p>Cr\u00e9ons un projet Eclipse standard (pas Maven) [1]\u00a0:</p> <p>Faisons un copier / coller du package [dao.console] du projet [elections-dao-jdbc-01] dans le projet [elections-dao-jdbc-02] [2]. De nombreuses erreurs apparaissent car la classe [Main] r\u00e9f\u00e9rence des classes qui ne sont pas dans son [Classpath]. Nous allons modifier celui-ci.</p> <p>Nous cr\u00e9ons tout d'abord [2-8] un dossier [lib] dans le nouveau projet\u00a0:</p> <p>En [9], nous mettons l'archive cr\u00e9\u00e9e \u00e0 l'\u00e9tape pr\u00e9c\u00e9dente dans le dossier [lib] puis nous modifions le Build Path du projet\u00a0:</p> <ul> <li>en [18], on a import\u00e9 l'archive de la couche [DAO] cr\u00e9\u00e9e pr\u00e9c\u00e9demment\u00a0;</li> </ul> <ul> <li>en [19], le projet ne pr\u00e9sente plus d'erreurs\u00a0; On peut alors ex\u00e9cuter la classe [Main]. On obtient les m\u00eames r\u00e9sultats que pr\u00e9c\u00e9demment.</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html","title":"12. [TD]\u00a0: Impl\u00e9mentation de la couche [DAO] du TD avec [Spring Data]","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, API JPA (Java Persistence API), Spring Data.</p> <p>Nous allons suivre la m\u00eame d\u00e9marche que pr\u00e9c\u00e9demment pour impl\u00e9menter la couche [DAO] du TD.</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#121-support","title":"12.1. Support","text":"<ul> <li>en [1], le dossier [support / chap-12] contient le projet Eclipse de ce chapitre\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#122-le-projet-eclipse","title":"12.2. Le projet Eclipse","text":"<p>Le projet Eclipse sera le suivant\u00a0:</p> <ul> <li>[elections.dao.config]\u00a0: contient la classe de configuration du projet Spring\u00a0;</li> <li>[elections.dao.entities]\u00a0: contient les entit\u00e9s JPA ainsi que la classe d'exception du projet\u00a0;</li> <li>[elections.dao.repositories]\u00a0: contient les interfaces [CrudRepository] pour les tables [CONF] et [LISTES]\u00a0;</li> <li>[elections.dao.service]\u00a0: contient l'impl\u00e9mentation de la couche [DAO]. C'est elle qu'il nous faut \u00e9crire\u00a0;</li> <li>[elections.dao.console]\u00a0: contient une classe de test de type [console]\u00a0;</li> <li>[pom.xml]\u00a0: le fichier de configuration du projet Maven\u00a0; Ce projet impl\u00e9mente l'architecture suivante\u00a0:</li> </ul> <p>La couche [DAO] ne voit que la couche impl\u00e9ment\u00e9e par [Spring Data].</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#123-configuration-maven","title":"12.3. Configuration Maven","text":"<p>Travail \u00e0 faire\u00a0: construisez le fichier [pom.xml] du projet.</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#124-les-entites-de-la-couche-jpa","title":"12.4. Les entit\u00e9s de la couche [JPA]","text":"<ul> <li>[ElectionsConfig] est le mod\u00e8le objet associ\u00e9 \u00e0 une ligne de la table [CONF]\u00a0;</li> <li>[ListeElectorale] est le mod\u00e8le objet associ\u00e9 \u00e0 une ligne de la table [LISTES]\u00a0;</li> <li>[AbstactEntity] est la classe parent des deux classes pr\u00e9c\u00e9dentes. Elle factorise les champs [id, version] communs aux deux classes\u00a0;</li> <li>[ElectionsException] est la classe d'exception du projet\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#1241-la-classe-electionsexception","title":"12.4.1. La classe [ElectionsException]","text":"<p>La classe [ElectionsException] est l'exception non contr\u00f4l\u00e9e d\u00e9crite au paragraphe 4.3, page 39.</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#1242-la-classe-abstractentity","title":"12.4.2. La classe [AbstractEntity]","text":"<p>La classe [AbstractEntity] est la suivante\u00a0:</p> <pre><code>package elections.dao.entities;\n\nimport java.io.Serializable;\n\nimport javax.persistence.Column;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.MappedSuperclass;\nimport javax.persistence.Version;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n@MappedSuperclass\npublic abstract class AbstractEntity implements Serializable{\n    private static final long serialVersionUID = 1L;\n\n    // propri\u00e9t\u00e9s\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\")\n    protected Long id;\n    @Version\n    @Column(name = \"VERSION\")\n    protected Long version;\n\n    // constructeurs\n    public AbstractEntity() {\n\n    }\n\n    public AbstractEntity(Long id, Long version) {\n        this.id = id;\n        this.version = version;\n    }\n\n    // red\u00e9finition [equals] et [hashcode]\n    @Override\n    public int hashCode() {\n        return (id != null ? id.hashCode() : 0);\n    }\n\n    @Override\n    public boolean equals(Object entity) {\n        if (!(entity instanceof AbstractEntity)) {\n            return false;\n        }\n        String class1 = this.getClass().getName();\n        String class2 = entity.getClass().getName();\n        if (!class2.equals(class1)) {\n            return false;\n        }\n        AbstractEntity other = (AbstractEntity) entity;\n        return id != null &amp;&amp; this.id == other.id;\n    }\n\n    // signature jSON\n    public String toString() {\n        ObjectMapper mapper = new ObjectMapper();\n        try {\n            return mapper.writeValueAsString(this);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    // getters et setters\n...\n}\n</code></pre> <p>C'est la classe d\u00e9crite au paragraphe 11.3.5.2, page 190, sans les filtres jSON. Ici en effet, les tables [CONF] et [LISTES] ne sont pas li\u00e9es par une relation de cl\u00e9 \u00e9trang\u00e8re. Or c'est l'existence d'une telle relation avec le mode [lazy loading] qui induit la n\u00e9cessit\u00e9 de filtres jSON.</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#1243-la-classe-electionsconfig","title":"12.4.3. La classe [ElectionsConfig]","text":"<p>La classe [ElectionsConfig] est l'entit\u00e9 JPA associ\u00e9e \u00e0 la table [CONF]\u00a0;</p> <p>Travail \u00e0 faire\u00a0: construisez la classe [ElectionsConfig].</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#1244-la-classe-listeelectorale","title":"12.4.4. La classe [ListeElectorale]","text":"<p>La classe [ListeElectorale] est l'entit\u00e9 JPA associ\u00e9e \u00e0 la table [LISTES]\u00a0;</p> <p>Travail \u00e0 faire\u00a0: construisez la classe [ListeElectorale].</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#125-la-couche-spring-data","title":"12.5. La couche [Spring Data]","text":"<p>Travail \u00e0 faire\u00a0: \u00e9crivez les deux interfaces de [Spring Data] pour g\u00e9rer les deux tables [CONF] et [LISTES]\u00a0;</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#126-la-couche-dao","title":"12.6. La couche [DAO]","text":"<p>L'interface [IElectionsDao] de la couche [DAO] est la suivante\u00a0:</p> <pre><code>package dao.service;\n\nimport dao.entities.ElectionsConfig;\nimport dao.entities.ListeElectorale;\n\npublic interface IElectionsDao {\n\n    // configuration de l'\u00e9lection\n    public ElectionsConfig getElectionsConfig();\n\n    // listes candidates\n    public ListeElectorale[] getListesElectorales();\n\n    // mise \u00e0 jour des listes candidates\n    public void setListesElectorales(ListeElectorale[] listesElectorales);\n}\n</code></pre> <p>Travail \u00e0 faire\u00a0: \u00e9crivez l'impl\u00e9mentation [ElectionsDaoJpa] de l'interface [IElectionsDao].</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#127-configuration-du-projet-spring","title":"12.7. Configuration du projet Spring","text":"<p>La classe [DaoConfig] configure le projet Spring.</p> <p>Travail \u00e0 faire\u00a0: \u00e9crivez la classe [DaoConfig]</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#128-la-couche-console","title":"12.8. La couche [console]","text":"<p>La classe [Main] est la classe ex\u00e9cutable suivante\u00a0:</p> <pre><code>package dao.console;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport dao.config.AppConfig;\nimport dao.entities.ElectionsConfig;\nimport dao.entities.ListeElectorale;\nimport dao.service.IElectionsDao;\n\npublic class Main {\n\n    // source de donn\u00e9es\n    private static IElectionsDao dao;\n\n    public static void main(String[] args) {\n        // r\u00e9cup\u00e9ration du contexte Spring\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n        // r\u00e9cup\u00e9ration de la source de donn\u00e9es\n        dao = ctx.getBean(IElectionsDao.class);\n        // contenu des deux tables\n        ElectionsConfig electionsConfig = dao.getElectionsConfig();\n        ListeElectorale[] listes = dao.getListesElectorales();\n        // affichage\n        System.out.println(String.format(\"Nombre de si\u00e8ges \u00e0 pourvoir : %d\", electionsConfig.getNbSiegesAPourvoir()));\n        System.out.println(String.format(\"Seuil \u00e9lectoral : %5.2f\", electionsConfig.getSeuilElectoral()));\n        System.out.println(\"Listes candidates----------------\");\n        for (ListeElectorale liste : listes) {\n            System.out.println(liste);\n        }\n        // fermeture contexte Spring\n        ctx.close();\n    }\n\n}\n</code></pre> <p>La classe [Test01] est un test JUnit\u00a0:</p> <pre><code>package dao.tests;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport dao.config.AppConfig;\nimport dao.entities.ElectionsConfig;\nimport dao.entities.ListeElectorale;\nimport dao.service.IElectionsDao;\n\n@SpringApplicationConfiguration(classes = AppConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // couche [DAO]\n    @Autowired\n    private IElectionsDao electionsDao;\n\n    @Before\n    public void init() {\n        // on nettoie la table [LISTES]\n        // listes en comp\u00e9tition\n        ListeElectorale[] listes = electionsDao.getListesElectorales();\n        // on met \u00e0 0 les voix et si\u00e8ges et elimine \u00e0 false\n        int voix = 0;\n        int si\u00e8ges = 0;\n        boolean elimine = false;\n        for (ListeElectorale liste : listes) {\n            liste.setVoix(voix);\n            liste.setSieges(si\u00e8ges);\n            liste.setElimine(elimine);\n        }\n        // on rend ces donn\u00e9es persistantes gr\u00e2ce \u00e0 la couche [dao]\n        electionsDao.setListesElectorales(listes);\n    }\n\n    @Test\n    public void testElections01() {\n        System.out.println(\"testElections01-------------------------------------\");\n        // r\u00e9cup\u00e9ration de la configuration des \u00e9lections\n        ElectionsConfig electionsConfig = electionsDao.getElectionsConfig();\n        int nbSiegesAPourvoir = electionsConfig.getNbSiegesAPourvoir();\n        double seuilElectoral = electionsConfig.getSeuilElectoral();\n        Assert.assertEquals(6, nbSiegesAPourvoir);\n        Assert.assertEquals(0.05, seuilElectoral, 1E-6);\n\n        // listes en comp\u00e9tition\n        ListeElectorale[] listes = electionsDao.getListesElectorales();\n        // affichage valeurs lues\n        System.out.println(\"Nombre de si\u00e8ges \u00e0 pourvoir : \" + nbSiegesAPourvoir);\n        System.out.println(\"Seuil \u00e9lectoral : \" + seuilElectoral);\n        System.out.println(\"Listes en comp\u00e9tition ---------------------\");\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(listes[i]);\n        }\n\n        // on affecte des voix et des si\u00e8ges aux listes\n        int voix = 0;\n        int si\u00e8ges = 0;\n        boolean elimine = false;\n        for (ListeElectorale liste : listes) {\n            liste.setVoix(voix);\n            liste.setSieges(si\u00e8ges);\n            liste.setElimine(elimine);\n            voix += 10;\n            si\u00e8ges += 1;\n            elimine = !elimine;\n        }\n\n        // on rend ces donn\u00e9es persistantes gr\u00e2ce \u00e0 la couche [dao]\n        electionsDao.setListesElectorales(listes);\n\n        // on relit les donn\u00e9es\n        ListeElectorale[] listesElectorales2 = electionsDao.getListesElectorales();\n        // on v\u00e9rifie les donn\u00e9es lues\n        Assert.assertEquals(7, listesElectorales2.length);\n        voix = 0;\n        si\u00e8ges = 0;\n        elimine = false;\n        for (ListeElectorale liste : listes) {\n            Assert.assertEquals(voix, liste.getVoix());\n            Assert.assertEquals(si\u00e8ges, liste.getSieges());\n            Assert.assertEquals(elimine, liste.isElimine());\n            voix += 10;\n            si\u00e8ges += 1;\n            elimine = !elimine;\n        }\n        System.out.println(\"Listes en comp\u00e9tition ---------------------\");\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(listes[i]);\n        }\n    }\n}\n</code></pre> <p>Travail \u00e0 faire\u00a0: passez les tests [console] et [JUnit] sur votre couche [DAO].</p>"},{"location":"td-implementation-de-la-couche-dao-du-td-avec-spring-data.html#129-generation-de-larchive-maven-du-projet","title":"12.9. G\u00e9n\u00e9ration de l'archive Maven du projet","text":"<p>En suivant l'exemple du paragraphe 11.3.12, page 207, g\u00e9n\u00e9rez l'archive Maven du projet.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html","title":"9. [TD]\u00a0: Impl\u00e9mentation de la couche [ui] avec un programme console","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html#91-support","title":"9.1. Support","text":"<p>En [1], le dossier [support / chap-09] contient le projet Eclipse de la couche [UI] de l'application console.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html#92-configuration-maven","title":"9.2. Configuration Maven","text":"<p>Le projet Eclipse [elections-ui-metier-dao-jdbc] est configur\u00e9 par le fichier Maven [pom.xml] suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-ui-metier-dao-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;elections-ui-metier-dao-jdbc&lt;/name&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- m\u00e9tier --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-metier-dao-jdbc&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;archive&gt;\n                        &lt;manifest&gt;\n                            &lt;mainClass&gt;config.AppConfig&lt;/mainClass&gt;\n                        &lt;/manifest&gt;\n                    &lt;/archive&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;!-- pour l'installation de l'artifact du projet dans le d\u00e9p\u00f4t local Maven --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 22-26\u00a0: on importe l'archive de la couche [m\u00e9tier] et par cascade celle de la couche [DAO]\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html#93-configuration-spring","title":"9.3. Configuration Spring","text":"<p>La classe [UiConfig] configure l'application Spring\u00a0:</p> <pre><code>package elections.ui.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n\nimport elections.metier.config.MetierConfig;\n\n@Import(MetierConfig.class)\n@ComponentScan(basePackages = { \"elections.ui.service\" })\npublic class UiConfig {\n}\n</code></pre> <ul> <li>ligne 8\u00a0: on importe les beans d\u00e9finis dans la couche [m\u00e9tier]. Celle-ci importait d\u00e9j\u00e0 les beans d\u00e9finis dans la couche [DAO]. On a donc ici acc\u00e8s aux beans des trois couches\u00a0;</li> <li>ligne 9\u00a0: le package [elections.ui.service] contient d'autres beans\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html#94-linterface-de-la-couche-ui","title":"9.4. L'interface de la couche [UI]","text":"<p>Pour comprendre ce que peut \u00eatre l'interface Java de la couche [UI], il nous faut savoir qui va utiliser cette interface. Il ne s'agit pas de l'utilisateur du sch\u00e9ma ci-dessus mais du programme qui va lancer l'application dans son ensemble.</p> <p>L'interface [IElectionsUI] est pr\u00e9sent\u00e9e au programme principal [main] qui va lancer l'application. Que peut demander [main] \u00e0 la couche [ui] ? Elle peut lui demander de commencer les \u00e9changes avec l'utilisateur qui va saisir les donn\u00e9es manquantes de l'\u00e9lection. On adoptera l'interface minimale suivante :</p> <pre><code>package istia.st.elections.ui;\n\npublic interface IElectionsUI {\n    /**\n     * lance le dialogue avec l'utilisateur\n     */\n    public void run();\n}\n</code></pre> <ul> <li>ligne 7 : l'interface n'a qu'une unique m\u00e9thode : run. En appelant cette m\u00e9thode, on demande \u00e0 la couche [ui] de commencer les \u00e9changes avec l'utilisateur.</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html#95-la-classe-de-demarrage-de-lapplication","title":"9.5. La classe de d\u00e9marrage de l'application","text":"<p>Le classe de d\u00e9marrage de l'application est une classe Java ayant une m\u00e9thode statique [main]. Cette m\u00e9thode doit cr\u00e9er des instances des couches [ui, metier, demo] et demander \u00e0 la couche [ui] de commencer le dialogue avec l'utilisateur. Cette classe pourrait \u00eatre la classe [AbstractBootElections] suivante :</p> <pre><code>package elections.ui.boot;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\nimport elections.dao.entities.ElectionsException;\nimport elections.ui.config.UiConfig;\nimport elections.ui.service.IElectionsUI;\n\npublic abstract class AbstractBootElections {\n\n    // r\u00e9cup\u00e9ration du contexte Spring\n    protected AnnotationConfigApplicationContext ctx;\n\n    public void run() {\n        // instanciation couche [ui]\n        IElectionsUI electionsUI = null;\n        try {\n            // r\u00e9cup\u00e9ration du contexte Spring\n            ctx = new AnnotationConfigApplicationContext(UiConfig.class);\n            // r\u00e9cup\u00e9ration de la couche [ui]\n            electionsUI = getUI();\n        } catch (RuntimeException ex) {\n            // on signale l'erreur\n            afficheExceptions(\"Les erreurs suivantes se sont produites :\", ex);\n            // on arr\u00eate l'application\n            System.exit(1);\n        }\n        // ex\u00e9cution couche [ui]\n        try {\n            electionsUI.run();\n        } catch (ElectionsException ex2) {\n            // on signale l'erreur\n            afficheExceptions(\"Les erreurs suivantes se sont produites :\", ex2);\n            // on arr\u00eate l'application\n            System.exit(3);\n        } catch (RuntimeException ex1) {\n            // on signale l'erreur\n            afficheExceptions(\"Les erreurs suivantes se sont produites :\", ex1);\n            // on arr\u00eate l'application\n            System.exit(2);\n        }\n    }\n\n    protected abstract IElectionsUI getUI();\n\n    private void afficheExceptions(String message, ElectionsException ex) {\n        // on affiche le message\n        System.out.println(String.format(\"%s -------------\", message));\n        System.out.println(String.format(\"Code erreur : %d\", ex.getCode()));\n        // on affiche les erreurs\n        for (String erreur : ex.getErreurs()) {\n            System.out.println(String.format(\"-- %s\", erreur));\n        }\n\n    }\n\n    public void afficheExceptions(String message, Exception ex) {\n        // on affiche le message\n        System.out.println(String.format(\"%s -------------\", message));\n        // on affiche la pile des exceptions\n        Throwable cause = ex;\n        while (cause != null) {\n            System.out.println(String.format(\"-- %s\", cause.getMessage()));\n            cause = cause.getCause();\n        }\n    }\n}\n</code></pre> <ul> <li>ligne 19\u00a0: le contexte Spring est instanci\u00e9\u00a0: tous les beans d\u00e9finis dans les diff\u00e9rents fichiers de configuration vont \u00eatre cr\u00e9\u00e9s\u00a0;</li> <li>ligne 21\u00a0: on r\u00e9cup\u00e8re une r\u00e9f\u00e9rence sur le bean qui impl\u00e9mente l'interface [IElectionsUI]. Nous allons impl\u00e9menter l'interface [IElectionsUI] par deux beans\u00a0:</li> <li>[ElectionsConsole] pour une application console\u00a0;</li> <li> <p>[ElectionsSwing] pour une application Swing\u00a0; La m\u00e9thode [getUI] est abstraite (ligne 44). En effet, la classe [AbstractBootElections] va \u00eatre parente de deux classes\u00a0:</p> </li> <li> <p>[BootElectionsConsole] qui fournira le bean [ElectionsConsole] \u00e0 sa classe parent\u00a0;</p> </li> <li>[BootElectionsSwing] qui fournira le bean [ElectionsSwing] \u00e0 sa classe parent\u00a0;</li> <li> <p>ligne 30\u00a0: la m\u00e9thode [run] de l'interface est ex\u00e9cut\u00e9e\u00a0; Les exceptions sont g\u00e9r\u00e9es \u00e0 divers endroits\u00a0:</p> </li> <li> <p>lignes 22-27\u00a0: une exception peut se produire lors de l'instanciation du contexte Spring\u00a0;</p> </li> <li>lignes 31-41\u00a0: une exception peut se produire lors de l'ex\u00e9cution de la couche [UI]. On distingue deux types d'exception\u00a0:</li> <li>la classe [ElectionsException] que la couche [DAO] lance\u00a0;</li> <li>la classe [RuntimeException] pour les autres exceptions qui pourraient survenir pendant l'ex\u00e9cution\u00a0; La classe [BootElectionsConsole] est la classe qui lance l'impl\u00e9mentation console. Son code est le suivant\u00a0:</li> </ul> <pre><code>package elections.ui.boot;\n\nimport elections.ui.service.IElectionsUI;\n\npublic class BootElectionsConsole extends AbstractBootElections{\n    public static void main(String[] arguments) {\n        new BootElectionsConsole().run();\n    }\n\n    @Override\n    protected IElectionsUI getUI() {\n        return ctx.getBean(\"electionsConsole\",IElectionsUI.class);\n    }\n}\n</code></pre> <ul> <li>ligne 5, la classe [BootElectionsConsole] \u00e9tend la classe [AbstractBootElections]. Elle doit donc impl\u00e9menter la m\u00e9thode [getUI] que sa classe parente avait d\u00e9clar\u00e9e abstraite\u00a0;</li> <li>lignes 10-13\u00a0: impl\u00e9mentation de la m\u00e9thode [getUI]\u00a0;</li> <li>ligne 12\u00a0: on rend le bean nomm\u00e9 [electionsConsole] impl\u00e9mentant l'interface [IElectionsUI]. [ctx] est le contexte Spring d\u00e9fini dans la classe parente par la d\u00e9claration\u00a0: <pre><code>    // r\u00e9cup\u00e9ration du contexte Spring\n    protected AnnotationConfigApplicationContext ctx;\n</code></pre></li> </ul> <p>Parce que le champ a l'attribut [protected], il est visible dans les classes filles.</p> <p>Le bean de la ligne 12 sera d\u00e9clar\u00e9 de la fa\u00e7on suivante\u00a0:</p> <pre><code>@Component\npublic class ElectionsConsole implements IElectionsUI {\n</code></pre> <p>Le nom par d\u00e9faut de ce bean est le nom de la classe avec sa premi\u00e8re lettre en minuscule. On peut s'affranchir de ce nom par d\u00e9faut en \u00e9crivant explicitement\u00a0:</p> <pre><code>@Component(nom_du_bean_entre_guillemets)\n</code></pre> <p>La classe [BootElectionsSwing] qui lancerait l'impl\u00e9mentation Swing pourrait \u00eatre la suivante\u00a0:</p> <pre><code>package elections.ui.boot;\n\nimport elections.ui.service.IElectionsUI;\n\npublic class BootElectionsSwing extends AbstractBootElections {\n    public static void main(String[] arguments) {\n        new BootElectionsSwing().run();\n    }\n\n    @Override\n    protected IElectionsUI getUI() {\n        return ctx.getBean(\"electionsSwing\", IElectionsUI.class);\n    }\n}\n</code></pre> <p>Ce mod\u00e8le de conception o\u00f9 on factorise le comportement commun \u00e0 des classes dans une classe parent, et o\u00f9 on laisse les classes filles impl\u00e9menter les d\u00e9tails qui leur sont sp\u00e9cifiques s'appelle le mod\u00e8le de conception Strategy. Ce mod\u00e8le de conception impose un comportement commun \u00e0 toutes les classes filles.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-un-programme-console.html#96-la-classe-dimplementation-electionsconsole","title":"9.6. La classe d'impl\u00e9mentation [ElectionsConsole]","text":"<p>Notre premi\u00e8re classe d'impl\u00e9mentation de la couche [ui] sera une classe utilisant la console pour communiquer avec l'utilisateur. Voici un exemple de dialogue obtenu sur la console Eclipse :</p> <pre><code>Il y a 7 listes en comp\u00e9tition. Veuillez indiquer le nombre de voix de chacune d'elles :\nNombre de voix de la liste [A] : 2500\nNombre de voix de la liste [B] : 4500\nNombre de voix de la liste [C] : x\nNombre de voix incorrect. Veuillez recommencer\nNombre de voix de la liste [C] : 8000\nNombre de voix de la liste [D] : 12000\nNombre de voix de la liste [E] : 16000\nNombre de voix de la liste [F] : 25000\nNombre de voix de la liste [G] : 32000\n\nR\u00e9sultats de l'\u00e9lection\n\n[G,32000,2,false]\n[F,25000,2,false]\n[E,16000,1,false]\n[D,12000,1,false]\n[C,8000,0,false]\n[B,4500,0,true]\n[A,2500,0,true]\n</code></pre> <p>La classe [ElectionsConsole] pourrait avoir le squelette suivant :</p> <pre><code>package elections.ui.service;\n\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport elections.dao.entities.ListeElectorale;\nimport elections.metier.service.IElectionsMetier;\n\n@Component\npublic class ElectionsConsole implements IElectionsUI {\n\n    @Autowired\n    private IElectionsMetier electionsMetier;\n\n    @Override\n    public void run() {\n        // saisie des donn\u00e9es\n        try (Scanner clavier = new Scanner(System.in)) {\n            // on demande les listes en comp\u00e9tition \u00e0 la couche [metier]\n\n            // on fait la saisie des voix\n\n        }\n        // on fait le calcul des si\u00e8ges\n\n        // on enregistre les r\u00e9sultats\n\n        // tri des listes dans l'ordre d\u00e9croissant des voix\n\n        // on les affiche\n    }\n\n    // classe de comparaison de listes \u00e9lectorales\n    class CompareListesElectorales implements Comparator&lt;ListeElectorale&gt; {\n\n        // comparaison de deux listes candidates selon le nombre de voix\n        @Override\n        public int compare(ListeElectorale listeElectorale1, ListeElectorale listeElectorale2) {\n            // on compare les voix de ces deux listes\n            int nbVoix1 = listeElectorale1.getVoix();\n            int nbVoix2 = listeElectorale2.getVoix();\n            if (nbVoix1 &lt; nbVoix2) {\n                return +1;\n            } else {\n                if (nbVoix1 &gt; nbVoix2)\n                    return -1;\n                else\n                    return 0;\n            }\n        }\n    }\n\n}\n</code></pre> <ul> <li>ligne 12\u00a0: la classe [ElectionsConsole] est un composant Spring\u00a0;</li> <li>ligne 13 : la classe impl\u00e9mente l'interface [IElectionsUI]</li> <li>lignes 15-16 : injection par Spring d'une r\u00e9f\u00e9rence sur la couche [metier]\u00a0;</li> <li>ligne 18-34 : la m\u00e9thode [run] de l'interface [IelectionsUI]\u00a0; Le try des lignes 21-28 s'appelle try-with-resources et sa syntaxe est la suivante\u00a0:</li> </ul> <pre><code>try(ressource){\n\u2026\n}\n</code></pre> <p>La ressource de la ligne 1 doit impl\u00e9menter l'interface [java.lang.AutoCloseable]. La ressource est ouverte ligne1 et automatiquement ferm\u00e9e apr\u00e8s la ligne 3, qu'il y ait exception ou non dans le code ex\u00e9cut\u00e9 entre les deux lignes. Cette syntaxe permet de s'assurer qu'une ressource ouverte sera bien ferm\u00e9e, quoiqu'il arrive.</p> <p>Travail \u00e0 faire : \u00e9crivez le code de la m\u00e9thode [run]. On s'aidera des commentaires.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html","title":"10. [TD]\u00a0: Impl\u00e9mentation de la couche [ui] avec une interface Swing","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, biblioth\u00e8que de composants Swing.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#101-support","title":"10.1. Support","text":"<p>Dans la couche [UI], on veut construire une interface graphique Swing. Netbeans a un outil [Matisse] pour construire ces interfaces Swing qui est sup\u00e9rieur \u00e0 ce que peut proposer Eclipse. Les interfaces Swing tendent \u00e0 \u00eatre remplac\u00e9es par des interfaces JavaFx. Netbeans et Eclipse utilisent le m\u00eame outil pour construire ces derni\u00e8res. Si donc, on construit des  interfaces JavaFx, on peut garder Eclipse de bout en bout de l'architecture en couches.</p> <p>Netbeans peut ouvrir n'importe quel projet Maven. On va donc utiliser le projet Maven pr\u00e9c\u00e9dent et lui ajouter une interface Swing. En [2], on charge (File / Open project) les projets Maven des trois couches que nous avons construites avec Eclipse. Puis, on construit leurs binaires [3]. Les options [Build] et [Clean and Build] construisent le binaire du prjet sur lequel elles sont appliqu\u00e9es. Ces binaires sont plac\u00e9s dans le dossier [target] [4-5] du projet\u00a0:</p> <p>L'option [Clean] supprime ce dossier [target]. L'option [Build] le reconstruit. L'exp\u00e9rience montre que lorsqu'on rencontre des probl\u00e8mes inattendus, la premi\u00e8re chose \u00e0 faire est un [Clean and Build] sur le projet pour \u00eatre s\u00fbr qu'on travaille bien avec la derni\u00e8re version de celui-ci. C'est notamment n\u00e9cessaire lorsqu'on a des fichiers de configuration qui s'ils sont modifi\u00e9s ne provoquent pas une recompilation automatique lorsqu'on ex\u00e9cute le projet. Il faut alors forcer cette recompilation par un [Clean and Build] pour que leurs nouvelles versions soient install\u00e9es dans le dossier [target].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#102-fonctionnement-de-lapplication","title":"10.2. Fonctionnement de l'application","text":"<p>Revenons \u00e0 l'architecture globale de l'application [Elections] :</p> <p>Nous nous int\u00e9ressons maintenant \u00e0 une nouvelle impl\u00e9mentation de la couche [ui]. L'unique impl\u00e9mentation r\u00e9alis\u00e9e pour le moment est une interface console. Nous cr\u00e9ons maintenant une interface graphique.</p> <p>L'utilisateur disposera de l'interface suivante pour interagir avec l'application [Elections] :</p> <p>L'interface graphique se trouve dans la couche [ui]. C'est elle qui interagit avec l'utilisateur.</p> <ul> <li>au d\u00e9marrage, l'application console [main] instancie les trois couches de l'application gr\u00e2ce \u00e0 Spring. Ceci est fait avant m\u00eame que l'interface graphique ne soit visible. Toujours dans cette phase d'initialisation, les renseignements caract\u00e9risant l'\u00e9lection (nombre de si\u00e8ges \u00e0 pourvoir, seuil \u00e9lectoral, listes en comp\u00e9tition) sont demand\u00e9s \u00e0 la couche [dao]. Si cette phase d'initialisation \u00e9choue (impossibilit\u00e9 d'acc\u00e9der aux donn\u00e9es par exemple), un message d'erreur est affich\u00e9 sur la console et l'interface graphique n'est pas affich\u00e9e.</li> <li>si la lecture des donn\u00e9es s'est bien pass\u00e9e, l'interface graphique est affich\u00e9e avec les renseignements suivants (cf copie d'\u00e9cran plus haut) :</li> <li>le nombre de si\u00e8ges \u00e0 pourvoir dans (2)</li> <li>le seuil \u00e9lectoral dans (3)</li> <li>les identifiants et noms des listes candidates dans (4)</li> <li>l'utilisateur affecte alors \u00e0 chaque liste candidate son nombre de voix \u00e0 l'aide des champs 4 (id - nom), 5 (voix), 6 (pour ajouter).</li> </ul> <p></p> <ul> <li>on peut alors utiliser le lien (10) pour calculer les si\u00e8ges :</li> </ul> <p></p> <ul> <li>le lien [Enregistrer] (12) permet d'enregistrer les r\u00e9sultats dans la source de donn\u00e9es.</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#103-la-classe-electionsswing-dimplementation-de-la-couche-ui","title":"10.3. La classe [ElectionsSwing] d'impl\u00e9mentation de la couche [ui]","text":""},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1031-le-projet-netbeans","title":"10.3.1. Le projet Netbeans","text":"<p>Note\u00a0: Le paragraphe 22.4, page 421, indique comment se procurer Netbeans. </p> <p>Le projet Netbeans final de l'application aura la forme suivante [1]. Construisez-le en suivant les \u00e9tape [2-5]\u00a0:</p> <p>On s'assurera que le projet est configur\u00e9 pour \u00eatre compil\u00e9 par un JDK 1.8 [1-6]\u00a0:</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1032-configuration-maven","title":"10.3.2. Configuration Maven","text":"<p>Le nouveau projet [elections-swing-metier-dao-jdbc] va s'appuyer sur le pr\u00e9c\u00e9dent projet [elections-console-metier-dao-jdbc]. Pour cela, on ajoute une d\u00e9pendance Maven de la fa\u00e7on suivante [1-3]\u00a0:</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1033-construction-de-linterface-graphique","title":"10.3.3. Construction de l'interface graphique","text":"<p>Pour cr\u00e9er l'interface graphique, nous pouvons proc\u00e9der comme suit :</p> <ul> <li>[1] : ajout d'un objet au paquetage [elections.ui.service]</li> <li>[2] : choix de l'option [JFrame Form] dans la cat\u00e9gorie [Swing GUI Forms]</li> </ul> <ul> <li>[4] : donner un nom \u00e0 la classe</li> <li>[5] : le package de la classe.</li> <li>Terminer l'assistant.</li> <li>[6] : la classe g\u00e9n\u00e9r\u00e9e</li> </ul> <ul> <li>[7] : la classe [AbstractElectionsSwing] en mode [Design]</li> <li>[8] : l'onglet [Navigator] qui affiche l'arbre [9] des composants de la fen\u00eatre</li> <li>[10] : l'onglet [Properties] qui affiche les propri\u00e9t\u00e9s du composant [jFrame] s\u00e9lectionn\u00e9 en [9]</li> </ul> <ul> <li>[11] : [JFrame] est un conteneur de composants. Ceux-ci peuvent \u00eatre dispos\u00e9s dans le conteneur selon diverses r\u00e8gles de positionnement appel\u00e9es layouts. Ici, nous choisissons le layout [Free Design] [14] qui permet de positionner des composants de fa\u00e7on libre dans le conteneur. Nous trouvons les composants dans la barre d'outils appel\u00e9e Palette :</li> </ul> <ul> <li>[1] : la palette</li> <li>[2] : un composant JLabel est d\u00e9pos\u00e9 dans le conteneur de composants</li> <li>avec un clic droit dessus, on a acc\u00e8s \u00e0 diverses propri\u00e9t\u00e9s : son nom [4], son texte [3] ou bien ses gestionnaires d'\u00e9v\u00e9nements [5]. Nous utilisons [3] pour fixer le texte [6].</li> </ul> <ul> <li>[1] : l'onglet [Properties] du composant [JLabel] donne acc\u00e8s aux propri\u00e9t\u00e9s de celui-ci : son positionnement horizontal [2], vertical [3], la police de caract\u00e8res du texte [4], le texte [5]. Lorsqu'un composant est d\u00e9pos\u00e9 et configur\u00e9 sur l'interface graphique et qu'on sauvegarde (Ctrl-S) le travail fait, du code est g\u00e9n\u00e9r\u00e9 dans la classe [AbstractElectionsSwing]\u00a0:</li> </ul> <p>Il ne faut pas modifier ce code gris\u00e9 car il est supprim\u00e9 et r\u00e9g\u00e9n\u00e9r\u00e9 lors de la sauvegarde suivante. Les modifications faites seraient alors perdues.</p> <p>On trouvera un tutoriel de cr\u00e9ation d'une interface graphique avec Netbeans \u00e0 l'URL [https://netbeans.org/kb/docs/java/quickstart-gui.html?print=yes#design] (novembre 2015).</p> <p>Nous construisons maintenant l'interface suivante :</p> <p>Les composants de l'interface sont les suivants :</p> <p>n\u00b0</p><p>type</p><p>nom</p><p>r\u00f4le</p> <pre><code>1\n</code></pre> <p>JMenuBar</p><p>jMenuBar1</p><p>un menu</p> <pre><code>2\n</code></pre> <p>JLabel</p><p>jLabelSAP</p><p>le nombre de si\u00e8ges \u00e0 pourvoir</p> <pre><code>3\n</code></pre> <p>JLabel</p><p>jLabelSE</p><p>le seuil \u00e9lectoral</p> <pre><code>4\n</code></pre> <p>JComboBox</p><p>jComboBoxNomsListes</p><p>liste des noms des listes en comp\u00e9tition</p> <pre><code>5\n</code></pre> <p>JTextField</p><p>jTextFieldVoixListe</p><p>le nombre de voix d'une liste</p> <pre><code>6\n</code></pre> <p>JLabel</p><p>jLabelAjouter</p><p>pour ajouter une liste \u00e0 (8)</p> <pre><code>7,8\n</code></pre> <p>(JScrollPane, JList)</p><p>jListNomsVoix</p><p>les noms et voix des listes</p> <pre><code>9\n</code></pre> <p>JLabel</p><p>jLabelSupprimer</p><p>pour supprimer de (8) la liste s\u00e9lectionn\u00e9e dans (8)</p> <pre><code>10\n</code></pre> <p>JLabel</p><p>jLabelCalculer</p><p>pour calculer les r\u00e9sultats de l'\u00e9lection</p> <pre><code>11\n</code></pre> <p>JLabel</p><p>jLabelEffacer</p><p>pour effacer les r\u00e9sultats de l'\u00e9lection</p> <pre><code>12\n</code></pre> <p>JLabel</p><p>jLabelEnregistrer</p><p>pour enregistrer les r\u00e9sultats de l'\u00e9lection</p> <pre><code>13,14\n</code></pre> <p>(JScrollPane, JList)</p><p>jListResultats</p><p>pour afficher les r\u00e9sultats de l'\u00e9lection</p> <pre><code>15,16\n</code></pre> <p>(JScrollPane,</p><p>JTextPane)</p><p>jTextPaneMessages</p><p>pour afficher des messages de suivi</p> <p>L'annotation (JScrollPane, JList) [13-14] est l\u00e0 pour indiquer que lorsqu'on d\u00e9pose un composant [JList] dans la fen\u00eatre, il est automatiquement ins\u00e9r\u00e9 dans un composant [JScrollPane] qui permet le d\u00e9filement de la liste. C'est le composant [JScrollPane] qui permet de voir tous les \u00e9l\u00e9ments de la liste alors que seul un nombre restreint d'entre-eux n'est visible \u00e0 un moment donn\u00e9. Il en est de m\u00eame pour le composant [JTextPane] [15-16].</p> <p>Le menu pourra \u00eatre cr\u00e9\u00e9 de la fa\u00e7on suivante :</p> <ul> <li>[1, 2] : un composant [Menu Bar] est d\u00e9pos\u00e9 sur la fen\u00eatre</li> <li>[3] : le menu g\u00e9n\u00e9r\u00e9 par d\u00e9faut tel que pr\u00e9sent\u00e9 dans l'onglet [Navigator]</li> <li>[4,5,6] : par un clic droit sur une option de menu, on peut :</li> <li>changer son texte [4], son nom [5]</li> <li>g\u00e9rer ses \u00e9v\u00e9nements [6]</li> <li>[7] : le menu souhait\u00e9 Le menu d\u00e9sir\u00e9 est le suivant :</li> </ul> <p>niveau 1</p><p>niveau 2</p><p>Elections</p> <p>Quitter</p><p>Listes</p> <p>Ajouter</p> <p>Supprimer</p><p>R\u00e9sultats</p> <p>Calculer</p> <p>Effacer</p> <p>Enregistrer</p><p>A propos</p> <p>On peut tester l'interface graphique \u00e0 tout moment :</p> <p>Lors de la construction de l'interface, il faut associer un gestionnaire d'\u00e9v\u00e9nement sur certains labels et menus [Ajouter, Effacer, ...]. Voici comment faire :</p> <ul> <li>[1] : cliquer droit sur le composant dont on veut g\u00e9rer un \u00e9v\u00e9nement</li> <li>[2] : choisir l'option [Events]</li> <li>[3] : choisir une cat\u00e9gorie d'\u00e9v\u00e9nements</li> <li>[4] : choisir l'\u00e9v\u00e9nement qu'on veut g\u00e9rer Le code Java g\u00e9n\u00e9r\u00e9 par cette op\u00e9ration est le suivant :</li> </ul> <pre><code>    jLabelCalculer.addMouseListener(new java.awt.event.MouseAdapter() {\n      public void mouseClicked(java.awt.event.MouseEvent evt) {\n        jLabelCalculerMouseClicked(evt);\n      }\n    });\n...\n\n  private void jLabelCalculerMouseClicked(java.awt.event.MouseEvent evt) {\n    // TODO add your handling code here:\n}\n</code></pre> <ul> <li>lignes 1-5 : un gestionnaire d'\u00e9v\u00e9nement est ajout\u00e9 au composant jLabelCalculer. La m\u00e9thode addMouseListener attend comme param\u00e8tre une classe impl\u00e9mentant l'interface MouseListener suivante :</li> </ul> <p>L'interface MouseListener est impl\u00e9ment\u00e9e par diff\u00e9rentes classes dont la classe MouseAdapter. Celle-ci impl\u00e9mente les cinq m\u00e9thodes de l'interface MouseListener mais ces m\u00e9thodes ne font rien. Aussi faut-il d\u00e9river cette classe pour impl\u00e9menter la ou les m\u00e9thodes de son choix. Ce qui est fait dans le code ci-dessus et repris ci-dessous :</p> <pre><code>    jLabelCalculer.addMouseListener(new java.awt.event.MouseAdapter() {\n      public void mouseClicked(java.awt.event.MouseEvent evt) {\n        jLabelCalculerMouseClicked(evt);\n      }\n});\n</code></pre> <p>Le code ci-dessus utilise la technique de la classe anonyme expos\u00e9e au paragraphe 2.5 du cours [ref1].</p> <p>Ligne 1, le param\u00e8tre de la m\u00e9thode addMouseListener est une classe anonyme, d\u00e9finie \u00e0 la vol\u00e9e. C'est une instance d'une classe d\u00e9riv\u00e9e de la classe MouseAdapter (ligne 1) dont on red\u00e9finit la m\u00e9thode mouseClicked (lignes 2-4) afin qu'elle fasse quelque chose.</p> <p>La m\u00e9thode jLabelCalculerMouseClicked appel\u00e9e ligne 3 est d\u00e9finie comme suit :</p> <pre><code>  private void jLabelCalculerMouseClicked(java.awt.event.MouseEvent evt) {\n    // TODO add your handling code here:\n}\n</code></pre> <p>Le d\u00e9veloppeur g\u00e8re l'\u00e9v\u00e9nement \"MouseClicked\" en mettant du code dans cette m\u00e9thode.</p> <p>Tous les gestionnaires d'\u00e9v\u00e9nements sont g\u00e9n\u00e9r\u00e9s par Netbeans de cette fa\u00e7on. Le d\u00e9veloppeur peut ignorer les lignes de code g\u00e9n\u00e9r\u00e9es par Netbeans pour associer une m\u00e9thode \u00e0 un \u00e9v\u00e9nement d'un composant. Il peut se contenter de mettre son code en ligne 2 ci-dessus. Voici un exemple :</p> <pre><code>  private void jLabelCalculerMouseClicked(java.awt.event.MouseEvent evt) {\n    System.out.println(\"Mouse Clicked\");\n}\n</code></pre> <p>Si on ex\u00e9cute l'interface graphique et qu'on clique sur le lien [Calculer] on obtient un message sur la console :</p> <ul> <li>[1] : on clique deux fois sur le label [Calculer]</li> <li>[2] : le gestionnaire de cet \u00e9v\u00e9nement a \u00e9t\u00e9 ex\u00e9cut\u00e9 et a produit les messages mouseClicked dans la console de Netbeans. Les composants [jComboBoxNomsListes, jListNomsVoix, jListResultats] sont d\u00e9clar\u00e9s de la fa\u00e7on suivante\u00a0:</li> </ul> <pre><code>protected javax.swing.JComboBox jComboBoxNomsListes;\nprotected javax.swing.JList jListNomsVoix;\nprotected javax.swing.JList jListResultats;\n</code></pre> <p>Ces composants sont des listes qui normalement sont param\u00e9tr\u00e9es par un type T\u00a0: le type des \u00e9l\u00e9ments du mod\u00e8le affich\u00e9 par les composants. Ce type T, peut \u00eatre quelconque. La valeur affich\u00e9e dans le composant liste est de type [String]. Par d\u00e9faut, c'est alors la m\u00e9thode [T.toString()] qui est utilis\u00e9e pour l'affichage. Afin de mieux ma\u00eetriser ce qui sera affich\u00e9, le type T sera ici le type String. Aussi, la d\u00e9claration correcte de nos listes est la suivante\u00a0:</p> <pre><code>protected javax.swing.JComboBox&lt;String&gt; jComboBoxNomsListes;\nprotected javax.swing.JList&lt;String&gt; jListNomsVoix;\nprotected javax.swing.JList&lt;String&gt; jListResultats;\n</code></pre> <p>On obtient ce r\u00e9sultat en modifiant l'une des propri\u00e9t\u00e9s du composant\u00a0:</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1034-separation-du-code","title":"10.3.4. S\u00e9paration du code","text":"<p>Revenons \u00e0 la structure de notre application :</p> <p>La classe [AbstractElectionsSwing] doit impl\u00e9menter la couche [ui] ci-dessus. Son code g\u00e9n\u00e9r\u00e9 par Netbeans ne contient pour l'instant que du code de gestion de la fen\u00eatre et des gestionnaires d'\u00e9v\u00e9nement qui pour l'instant ne font rien. Ci-dessus, on voit que la classe [AbstractElectionsSwing] devra g\u00e9rer des \u00e9changes avec la couche [m\u00e9tier]. Cette gestion se fera dans les gestionnaires d'\u00e9v\u00e9nement. Pour clarifier la structure du code, on d\u00e9cide de le placer dans deux classes :</p> <ul> <li>[AbstractElectionsSwing] qui restera comme elle a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e par Netbeans \u00e0 quelques d\u00e9tails pr\u00e8s. Cette classe ne g\u00e8rera aucun \u00e9v\u00e9nement elle-m\u00eame. Les gestionnaires d'\u00e9v\u00e9nements seront vides et d\u00e9clar\u00e9s abstraits. Ils seront impl\u00e9ment\u00e9s par une classe d\u00e9riv\u00e9e de [AbstractElectionsSwing].</li> <li>[ElectionsSwing], classe d\u00e9riv\u00e9e de [AbstractElectionsSwing] qui impl\u00e9mentera tous les gestionnaires d'\u00e9v\u00e9nement. Ce type de s\u00e9paration n'est pas inhabituel. On le trouve par exemple dans les pages web ASP.NET (version non MVC). Le projet Netbeans \u00e9volue comme suit :</li> </ul> <p>Le code de la classe [AbstractElectionsSwing] lui, \u00e9volue de la fa\u00e7on suivante :</p> <pre><code>public abstract class AbstractElectionsSwing {\n....\n    private void jMenuItemCalculerActionPerformed(java.awt.event.ActionEvent evt) {\n        doCalculer();\n    }\n\n...\n\n    private void jLabelCalculerMouseClicked(java.awt.event.MouseEvent evt) {\n        if (jLabelCalculer.isEnabled()) {\n            doCalculer();\n        }\n    }\n\n....\n    // gestionnaires d'\u00e9v\u00e9nements\n    abstract protected void doSupprimer();\n\n    abstract protected void doCalculer();\n\n    abstract protected void doQuitter();\n\n    abstract protected void doEffacer();\n\n    abstract protected void doEnregistrer();\n\n    abstract protected void doAjouter();\n\n    abstract protected void doInformer();\n\n    abstract protected void doMajLabelAjouter();\n\n    abstract protected void doMajLabelSupprimer();\n...\n}\n</code></pre> <ul> <li>ligne 1 : la classe est d\u00e9clar\u00e9e abstraite</li> <li>lignes 3-5 : gestion du clic sur sur l'option de menu [jMenuItemCalculer]. On voit que le traitement de l'\u00e9v\u00e9nement est d\u00e9port\u00e9 sur la m\u00e9thode doCalculer de la ligne 19. Cette m\u00e9thode n'est pas impl\u00e9ment\u00e9e et est d\u00e9clar\u00e9e abstraite. C'est la classe d\u00e9riv\u00e9e [ElectionsSwing] qui l'impl\u00e9mentera\u00a0;</li> <li>lignes 9-13 : le gestionnaire de l'\u00e9v\u00e9nement clic sur le label [jLabelCalculer]. Le clic provoque toujours un \u00e9v\u00e9nement, que le composant [jLabel] soit actif (enabled=true) ou inactif (enabled=false). On s'assure ici qu'il est bien actif pour traiter l'\u00e9v\u00e9nement\u00a0;</li> <li>lignes 15 et au-del\u00e0 : cette technique de d\u00e9l\u00e9gation du traitement des \u00e9v\u00e9nements vers une m\u00e9thode abstraite est apliqu\u00e9e \u00e0 tous les gestionnaires d'\u00e9v\u00e9nements. La classe [ElectionsSwing] d\u00e9riv\u00e9e de [AbstractElectionsSwing] impl\u00e9mente tous les gestionnaires d'\u00e9v\u00e9nements non impl\u00e9ment\u00e9s par [AbstractElectionsSwing] :</li> </ul> <pre><code>package elections.ui.service;;\n...\npublic class ElectionsSwing extends AbstractElectionsSwing {\n\n    // gestionnaires d'\u00e9vts\n\n    @Override\n    protected void doInformer() {\n...\n    }\n\n    @Override\n    protected void doAjouter() {\n    ...\n    }\n\n    @Override\n    protected void doCalculer() {\n    ...\n    }\n\n    @Override\n    protected void doEffacer() {\n    ...\n    }\n\n    @Override\n    protected void doEnregistrer() {\n...\n    }\n\n    @Override\n    protected void doQuitter() {\n        System.exit(0);\n    }\n\n    @Override\n    protected void doSupprimer() {\n...\n    }\n\n    @Override\n    protected void doMajLabelAjouter() {\n...\n    }\n\n    @Override\n    protected void doMajLabelSupprimer() {\n...\n    }\n\n}\n</code></pre> <ul> <li>ligne 3 : [ElectionsSwing] d\u00e9rive de [AbstractElectionsSwing]</li> <li>lignes 7-50 : les gestionnaires des \u00e9v\u00e9nements de la fen\u00eatre graphique Les m\u00e9thodes de la classe d\u00e9riv\u00e9e [ElectionsSwing] vont manipuler les composants de la classe parent [AbstractElectionsSwing]. Actuellement ces composants ont une port\u00e9e private, interdisant \u00e0 la classe fille [ElectionsSwing] d'y avoir acc\u00e8s :</li> </ul> <pre><code>private JMenuItem jMenuItemAPropos = null;\n\nprivate JLabel jLabelAjouter = null;\n</code></pre> <p>Pour r\u00e9soudre ce probl\u00e8me, on fera en sorte que la port\u00e9e des composants de l'interface graphique soit [protected]\u00a0:</p> <ul> <li>mettre en [3], l'attribut [protected]\u00a0;</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1035-implementation-de-linterface-ielectionsui","title":"10.3.5. Impl\u00e9mentation de l'interface [IElectionsUI]","text":"<p>Revenons \u00e0 la structure de notre application :</p> <p>Ci-dessus la couche [ui] doit pr\u00e9senter l'interface [IElectionsUI] \u00e0 l'objet [main] :</p> <pre><code>package elections.ui.service;\n\npublic interface IElectionsUI {\n    /**\n     * lance le dialogue avec l'utilisateur\n     */\n    public void run();\n}\n</code></pre> <p>Cette interface a \u00e9t\u00e9 d\u00e9finie dans le projet [elections-console-metier-dao-jdbc] et d\u00e9crite au paragraphe 9.4, page 135. Comme ce projet est une d\u00e9pendance du projet [swing], cette interface est connue.</p> <p>Parce que la classe [AbstractElectionsSwing] est devenue abstraite, elle ne peut plus \u00eatre instanci\u00e9e par Spring. C'est la classe [ElectionsSwing] qui doit d\u00e9sormais l'\u00eatre. La classe [ElectionsSwing] doit impl\u00e9menter l'interface [IElectionsUI]. Son code \u00e9volue donc comme suit :</p> <pre><code>public class ElectionsSwing extends AbstractElectionsSwing implements IElectionsUI {\n\n    // m\u00e9thode run de l'interface [ElectionsUI]\n    public void run() {\n...\n    }\n</code></pre> <ul> <li>ligne 1 : la classe [ElectionsSwing] impl\u00e9mente l'interface [IElectionsUI]</li> <li>lignes 4-6 : la m\u00e9thode [run] de cette interface Que doit faire la m\u00e9thode run ? Afficher la fen\u00eatre graphique. Comment fait-on cela ? On peut se laisser guider par la m\u00e9thode [main] qu'\u00e0 g\u00e9n\u00e9r\u00e9e Netbeans dans la classe [AbstractElectionsSwing] et qui fait ce qui est souhait\u00e9 :</li> </ul> <pre><code>public static void main(String args[]) {\n    /* Set the Nimbus look and feel */\n    //&lt;editor-fold defaultstate=\"collapsed\" desc=\" Look and feel setting code (optional) \"&gt;\n    /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.\n         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html \n     */\n    try {\n      for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n        if (\"Nimbus\".equals(info.getName())) {\n          javax.swing.UIManager.setLookAndFeel(info.getClassName());\n          break;\n        }\n      }\n    } catch (ClassNotFoundException ex) {\n      java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    } catch (InstantiationException ex) {\n      java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    } catch (IllegalAccessException ex) {\n      java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n      java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    }\n    //&lt;/editor-fold&gt;\n\n    /* Create and display the form */\n    java.awt.EventQueue.invokeLater(new Runnable() {\n      public void run() {\n        new NewJFrame().setVisible(true);\n      }\n    });\n  }\n</code></pre> <p>Le constructeur [AbstractElectionsSwing] utilis\u00e9 ligne 28 est le suivant\u00a0:</p> <pre><code>  public AbstractElectionsSwing() {\n    initComponents();\n}\n</code></pre> <ul> <li>ligne 2\u00a0: la m\u00e9thode [initComponents] est une m\u00e9thode priv\u00e9e g\u00e9n\u00e9r\u00e9e par le g\u00e9n\u00e9rateur de l'interface graphique. On ne peut changer son code. La m\u00e9thode [run] de la classe [ElectionsSwing] pourrait alors \u00eatre la suivante :</li> </ul> <pre><code>  @Override\n  public void run() {\n    // on affiche l'interface graphique\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        init();\n        setVisible(true);\n      }\n    });\n}\n</code></pre> <ul> <li> <p>ligne 6\u00a0: l'interface graphique est initialis\u00e9e au moyen d'une m\u00e9thode [init]. Ici, on voudrait appeler la m\u00e9thode [initComponents] de la classe parent, mais celle-ci est priv\u00e9e. On ajoute alors dans la classe parent [AbstractElectionsSwing], la m\u00e9thode [init] suivante\u00a0: <pre><code>  protected void init(){\n    initComponents();\n}\n</code></pre></p> </li> <li> <p>parce qu'elle est dans la classe [AbstractElectionsSwing], la m\u00e9thode [init] a acc\u00e8s \u00e0 la m\u00e9thode priv\u00e9e [initComponents] de la m\u00eame classe\u00a0;</p> </li> <li>parce qu'elle a l'attribut [protected], elle est visible dans la classe fille [ElectionsSwing]\u00a0;</li> <li>ligne 7\u00a0: l'interface graphique est rendue visible\u00a0; Note\u00a0: lorsque la m\u00e9thode [run] a \u00e9t\u00e9 \u00e9crite dans la classe [ElectionsSwing], la m\u00e9thode [main] de la classe abstraite [AbstractElectionsSwing] peut \u00eatre supprim\u00e9e.</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1036-la-classe-executable","title":"10.3.6. La classe ex\u00e9cutable","text":"<p>Revenons \u00e0 la structure de notre application :</p> <p>Nous voudrions que Spring instancie la couche [ui] comme il a \u00e9t\u00e9 fait lorsque celle-ci \u00e9tait impl\u00e9ment\u00e9e par une application console. Pour cela, il faut que la classe d'impl\u00e9mentation [ElectionsSwing] ait une r\u00e9f\u00e9rence sur la couche [m\u00e9tier] :</p> <pre><code>@Component\npublic class ElectionsSwing extends AbstractElectionsSwing implements IElectionsUI{\n\n  // r\u00e9f\u00e9rence sur la couche [m\u00e9tier]\n  @Autowired\n  private IElectionsMetier metier;\n...\n</code></pre> <ul> <li>ligne 1 : la classe [ElectionsSwing] est un composant Spring\u00a0;</li> <li>lignes 5-6 : injection par Spring d'une r\u00e9f\u00e9rence sur la couche [m\u00e9tier]\u00a0; L'interface graphique est lanc\u00e9e par l'ex\u00e9cution de la classe [BootElectionsSwing] suivante\u00a0:</li> </ul> <pre><code>package elections.ui.boot;\n\nimport elections.ui.service.IElectionsUI;\n\npublic class BootElectionsSwing extends AbstractBootElections {\n    public static void main(String[] arguments) {\n        new BootElectionsSwing().run();\n    }\n\n    @Override\n    protected IElectionsUI getUI() {\n        return ctx.getBean(\"electionsSwing\", IElectionsUI.class);\n    }\n}\n</code></pre> <p>Nous avons expliqu\u00e9 un code analogue lorsqu'au paragraphe 9.5, page 135, nous avons expliqu\u00e9 le code des classes [AbstractBootElections] et [BootElectionsConsole]. Ligne 12, on r\u00e9cup\u00e8re le bean nomm\u00e9 [electionsSwing] qui correspond au nom Spring standard pour la classe [ElectionsSwing].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1037-initialisation-de-linterface-graphique","title":"10.3.7. Initialisation de l'interface graphique","text":"<p>Lorsque l'interface graphique est affich\u00e9e, certains de ses composants ont \u00e9t\u00e9 initialis\u00e9s :</p> <p></p> <p>On voit ci-dessus : </p> <ul> <li>que le combo a \u00e9t\u00e9 rempli avec les noms des listes\u00a0;</li> <li>que le nombre de si\u00e8ges \u00e0 pourvoir et le seuil \u00e9lectoral sont indiqu\u00e9s\u00a0;</li> <li>que certains liens ont \u00e9t\u00e9 d\u00e9sactiv\u00e9s\u00a0;</li> <li> <p>qu'un message de succ\u00e8s est affich\u00e9 en bas de la fen\u00eatre\u00a0; A quel moment vont se faire ces initialisations ? Elles ne peuvent se faire qu'apr\u00e8s initialisation du champ [electionsMetier] de la classe [ElectionsSwing]. En effet, les noms des listes vont \u00eatre demand\u00e9s \u00e0 la couche [metier]. L'initialisation de ce champ va \u00eatre faite par Spring dans l'ordre suivant :</p> </li> <li> <p>utilisation du constructeur sans param\u00e8tres de la classe [ElectionsSwing]\u00a0;</p> </li> <li>injection des d\u00e9pendances, ici la r\u00e9f\u00e9rence de la couche [m\u00e9tier]\u00a0;</li> <li> <p>ex\u00e9cution de la m\u00e9thode [run] de la classe [ElectionsSwing]\u00a0: <pre><code>    @Override\n    public void run() {\n        // on affiche l'interface graphique\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                init();\n                setVisible(true);\n            }\n        });\n}\n</code></pre></p> </li> <li> <p>ligne 12, nous avons dit qu'on appelait la m\u00e9thode [init] de la classe parent qui va dessiner les composants de l'interface graphique. Nous allons red\u00e9finir cette m\u00e9thode, localement, dans la classe [ElectionsSwing]. C'est dans cette m\u00e9thode que nous initialiserons, avec des donn\u00e9es cette fois, les composants de la fen\u00eatre (combo, labels)\u00a0: La m\u00e9thode locale [init] pourrait avoir le squelette suivant :</p> </li> </ul> <pre><code>public class ElectionsSwing extends AbstractElectionsSwing implements IElectionsUI {\n\n    ...\n  // r\u00e9f\u00e9rence sur la couche [m\u00e9tier]\n  @Autowired\n  private IElectionsMetier metier;\n\n    // initialisations\n    public void init() {\n      // g\u00e9n\u00e9ration des composants par la classe parent\n    super.init();\n\n    // on demande les listes \u00e0 la couche [metier]\n        ...\n        // on associe les noms des listes au combo jComboBoxNomsListes\n        ...\n        // ainsi que les param\u00e8tres de l'\u00e9lection\n        ...\n        // on initialise les labels li\u00e9s \u00e0 ces deux informations\n        ...\n        // message de succ\u00e8s\n        ...\n        // initialisation \u00e9tat de certains composants formulaire\n...\n}\n</code></pre> <p>On notera bien, ligne 11, l'appel de la m\u00e9thode [init] de la classe parent.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1038-la-classe-utilitaires","title":"10.3.8. La classe [Utilitaires]","text":"<p>Un certain nombre de m\u00e9thodes utilitaires statiques ont \u00e9t\u00e9 rassembl\u00e9es dans la classe [Utilitaires] :</p> <p>La classe [Utilitaires] est la suivante :</p> <pre><code>package istia.st.elections.ui;\n\nimport javax.swing.JLabel;\nimport javax.swing.JMenuItem;\n\n//classe utilitaire\nclass Utilitaires {\n    // g\u00e9rer l'\u00e9tat d'un tableau de labels\n    public static void setEnabled(JLabel[] labels, boolean value) {\n        for (int i = 0; i &lt; labels.length; i++) {\n            labels[i].setEnabled(value);\n        }\n    }\n\n    // g\u00e9rer l'\u00e9tat d'un tableau d'options de menu\n    public static void setEnabled(JMenuItem[] menuItems, boolean value) {\n        ...\n    }\n\n}\n</code></pre> <ul> <li>ligne 9 :  la m\u00e9thode setEnabled fixe l'\u00e9tat de composants JLabel d\u00e9finis dans un tableau. La m\u00e9thode setEnabled d'un composant JLabel permet d'activer ou de d\u00e9sactiver le JLabel. Travail \u00e0 faire : en suivant l'exemple de la m\u00e9thode setEnabled de la ligne 9, \u00e9crivez la m\u00e9thode setEnabled de la ligne 16 qui fait la m\u00eame chose avec des composants JMenuItem.</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#1039-le-code-de-la-classe-electionsswing","title":"10.3.9. Le code de la classe [ElectionsSwing]","text":"<p>Rappelons la structure g\u00e9n\u00e9rale de la classe [ElectionsSwing] :</p> <pre><code>package istia.st.elections.ui;\n\n...\npublic class ElectionsSwing extends AbstractElectionsSwing implements IElectionsUI {\n\n  // r\u00e9f\u00e9rence sur la couche [m\u00e9tier]\n  @Autowired\n  private IElectionsMetier metier;\n\n\n    // initialisations\n    public void init() {\n    ...\n    }\n\n    // gestionnaires d'\u00e9vts\n\n    @Override\n    protected void doInformer() {\n...\n    }\n\n    @Override\n    protected void doAjouter() {\n...\n    }\n\n    @Override\n    protected void doCalculer() {\n    ...\n    }\n\n    @Override\n    protected void doEffacer() {\n...\n    }\n\n    @Override\n    protected void doEnregistrer() {\n...\n    }\n\n    @Override\n    protected void doQuitter() {\n        System.exit(0);\n    }\n\n    @Override\n    protected void doSupprimer() {\n...\n    }\n\n    @Override\n    protected void doMajLabelAjouter() {\n    ...\n    }\n\n    @Override\n    protected void doMajLabelSupprimer() {\n...\n    }\n\n}\n</code></pre> <p>Nous allons \u00e9tudier les m\u00e9thodes de la classe les unes apr\u00e8s les autres.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10391-la-methode-init","title":"10.3.9.1. La m\u00e9thode [init]","text":"<p>Revenons sur l'interface graphique :</p> <p>La m\u00e9thode [init] a pour objectifs :</p> <ul> <li>de remplir le combo [4] avec les identifiants et noms des listes sous la forme [id - nom]</li> <li>d'afficher un message de succ\u00e8s dans [15]</li> <li>d'initialiser les labels [2] et [3]</li> <li>de d\u00e9sactiver certains liens Le squelette de la m\u00e9thode [init] pourrait \u00eatre le suivant :</li> </ul> <pre><code>@Override\n    protected void init() {\n        // g\u00e9n\u00e9ration des composants par la classe parent\n        super.init();\n        // initialisations locales\n        mod\u00e8leNomsVoix = new DefaultListModel&lt;&gt;();\n        jListNomsVoix.setModel(mod\u00e8leNomsVoix);\n        mod\u00e8leR\u00e9sultats = new DefaultListModel&lt;&gt;();\n        jListResultats.setModel(mod\u00e8leR\u00e9sultats);\n        String info;\n        try {\n            // on demande les listes \u00e0 la couche [m\u00e9tier]\n            listes = ...\n            // on associe les noms des listes au combo jComboBoxNomsListes\n            ...\n            // ainsi que les param\u00e8tres de l'\u00e9lection\n            int nbSiegesAPourvoir = ...\n            double seuilElectoral = ...\n            // on initialise les labels li\u00e9s \u00e0 ces deux informations\n            ...\n            // message de succ\u00e8s\n            info = \"Source de donn\u00e9es lue avec succ\u00e8s\";\n        } catch (ElectionsException ex1) {\n            // on note l'erreur\n            info = getInfoForException(\"Les erreurs suivantes se sont produites :\", ex1);\n        } catch (RuntimeException ex2) {\n            // on note l'erreur\n            info = getInfoForException(\"Les erreurs suivantes se sont produites :\", ex2);\n        }\n        // on affiche l'info\n        jTextPaneMessages.setText(info);\n        jTextPaneMessages.setCaretPosition(0);\n        // \u00e9tat formulaire\n        Utilitaires.setEnabled(new JLabel[] { jLabelAjouter, jLabelCalculer, jLabelEnregistrer, jLabelSupprimer }, false);\n        Utilitaires.setEnabled(\n                new JMenuItem[] { jMenuItemAjouter, jMenuItemCalculer, jMenuItemEnregistrer, jMenuItemSupprimer }, false);\n        // centrer la fen\u00eatre\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        Dimension frameSize = getSize();\n        if (frameSize.height &gt; screenSize.height) {\n            frameSize.height = screenSize.height;\n        }\n        if (frameSize.width &gt; screenSize.width) {\n            frameSize.width = screenSize.width;\n        }\n        setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n    }\n</code></pre> <pre><code>    private String getInfoForException(String message, ElectionsException ex) {\n        // on affiche le message\n        StringBuffer info = new StringBuffer(String.format(\"%s -------------\\n\", message));\n        info.append(String.format(\"Code erreur : %d\\n\", ex.getCode()));\n        // on affiche les erreurs\n        for (String erreur : ex.getErreurs()) {\n            info.append(String.format(\"-- %s\\n\", erreur));\n        }\n        return info.toString();\n    }\n\n    private String getInfoForException(String message, RuntimeException ex) {\n        // on affiche le message\n        StringBuffer info = new StringBuffer(String.format(\"%s -------------\\n\", message));\n        // on affiche la pile des exceptions\n        Throwable cause = ex;\n        while (cause != null) {\n            info.append(String.format(\"-- %s\\n\", cause.getMessage()));\n            cause = cause.getCause();\n        }\n        return info.toString();\n    }\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [init].</p> <p>A lire dans le cours : composants JTextField, JLabel</p> <p>A savoir :</p> <p>Un composant JList affiche les donn\u00e9es pr\u00e9sentes dans un mod\u00e8le. Par d\u00e9faut, ce mod\u00e8le est de type DefaultListModel (lignes 2 et 3). Un objet de DefaultListModel  se comporte un peu comme un type ArrayList :</p> <ul> <li>pour ajouter un objet o dans le mod\u00e8le : <pre><code>[DefaultListModel].addElement(Object o);\n</code></pre></li> </ul> <p>Dans cette application, l'objet o sera toujours de type String.</p> <ul> <li> <p>pour enlever l'\u00e9l\u00e9ment n\u00b0 i du mod\u00e8le : <pre><code>[DefaultListModel].remove(int i);\n</code></pre></p> </li> <li> <p>pour obtenir l'\u00e9l\u00e9ment n\u00b0 i du mod\u00e8le : <pre><code>[DefaultListModel].elementAt(int i);\n</code></pre></p> </li> </ul> <p>Pour ajouter un \u00e9l\u00e9ment au combo [jComboBoxNomsListes], on utilisera la m\u00e9thode [addItem]\u00a0:</p> <pre><code>jComboBoxNomsListes.addItem(cha\u00eene de caract\u00e8res)\n</code></pre> <p>Un composant JTextPane a les m\u00e9thodes getText() et setText() pour lire / \u00e9crire le texte affich\u00e9.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10392-gerer-letat-du-lien-ajouter","title":"10.3.9.2. G\u00e9rer l'\u00e9tat du lien [Ajouter]","text":"<p>Le lien [Ajouter] [6] n'est actif que lorsque le champ [5] des voix est non vide. Dans la classe [AbstractElectionsSwing], le gestionnaire qui suit les mouvements du curseur dans le champ [5] est le suivant :</p> <pre><code>  private void jTextFieldVoixListeCaretUpdate(javax.swing.event.CaretEvent evt) {\n    doMajLabelAjouter()\n}\n</code></pre> <p>La ligne 2 appelle la m\u00e9thode [doMajLabelAjouter] de la classe [ElectionsSwing].</p> <pre><code>    protected void doMajLabelAjouter() {\n        // on fixe l'\u00e9tat du label [jLabelAjouter]\n        ...\n        // on fixe l'\u00e9tat du menu [jMenuItemAjouter]\n        ...\n}\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doMajLabelAjouter].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10393-affecter-les-voix-a-chaque-liste","title":"10.3.9.3. Affecter les voix \u00e0 chaque liste","text":"<p>Pour chaque liste candidate de (4), on proc\u00e8de ainsi :</p> <ul> <li>choix d'une liste dans (4)</li> <li>saisie du nombre de voix dans (5)</li> <li>validation par un clic sur le lien [Ajouter] Les erreurs de saisie sont signal\u00e9es comme le montre l'exemple suivant :</li> </ul> <p></p> <p>Si le nombre de voix est correct, la liste est ajout\u00e9e dans le composant (8), le nombre de voix effac\u00e9 et le lien [Ajouter] \u00e9teint :</p> <p>Dans la classe [AbstractElectionsSwing], le gestionnaire qui g\u00e8re le clic sur le lien [Ajouter] est le suivant :</p> <pre><code>    private void jLabelAjouterMouseClicked(java.awt.event.MouseEvent evt) {\n        if (jLabelAjouter.isEnabled()) {\n            doAjouter();\n        }\n}\n</code></pre> <p>La ligne 3 appelle la m\u00e9thode [doAjouter] de la classe [ElectionsSwing] :</p> <pre><code>  // mod\u00e8les des listes JList\n  private DefaultListModel&lt;String&gt; mod\u00e8leNomsVoix = null;\n  private DefaultListModel&lt;String&gt; mod\u00e8leR\u00e9sultats = null;\n\n  // les listes en comp\u00e9tition\n  private ListeElectorale[] listes;\n\n  // listes saisies par l'utilisateur\n  private final List&lt;ListeElectorale&gt; listesSaisies = new ArrayList&lt;&gt;();\n  private ListeElectorale[] tListesSaisies;\n...\n  @Override\n  protected void doAjouter() {\n    // le nombre de voix est-il correct ?\n    ...\n    // si erreur, alors on la signale\n    if (erreur) {\n      JOptionPane.showMessageDialog(null, \"Nombre de voix incorrect\", \"Elections : erreur\",\n              JOptionPane.INFORMATION_MESSAGE);\n      jTextFieldVoixListe.requestFocus();\n      // retour \u00e0 l'interface graphique\n      return;\n    }\n    // pas d'erreur - on enregistre la liste\n    listesSaisies.add(...);\n    mod\u00e8leNomsVoix.addElement(...);\n    // on nettoie le nombre de voix\n    jTextFieldVoixListe.setText(\"\");\n    // \u00e9tat formulaire (menus, labels)\n...\n}\n</code></pre> <ul> <li>ligne 25\u00a0: \u00e0 chaque fois que l'utilisateur ajoute des voix \u00e0 une liste et valide son choix, cette liste est mise dans le champ [listesSaisies] de la ligne 9. On y enregistrera la liste avec les informations [id, version, nom, voix]. Les trois premi\u00e8res informations viennent des listes enregistr\u00e9es initialement dans le tableau de la ligne 6. La m\u00e9thode [getSelectedIndex] du combo permet de conna\u00eetre l'indice de la liste s\u00e9lectionn\u00e9e\u00a0; Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doAjouter].</li> </ul>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10394-gerer-letat-du-lien-supprimer","title":"10.3.9.4. G\u00e9rer l'\u00e9tat du lien [Supprimer]","text":"<p>Le lien [Supprimer] [9] n'est actif que lorsqu'un \u00e9l\u00e9ment est s\u00e9lectionn\u00e9 dans [8].</p> <p>Dans la classe [AbstractElectionsSwing], le gestionnaire qui r\u00e9agit au clic sur un \u00e9l\u00e9ment de la liste [8] est le suivant :</p> <pre><code>  private void jListNomsVoixValueChanged(javax.swing.event.ListSelectionEvent evt) {\n    doMajLabelSupprimer();\n}\n</code></pre> <p>La ligne 2 appelle la m\u00e9thode [doMajLabelSupprimer] de la classe [ElectionsSwing].</p> <pre><code>    @Override\n    protected void doMajLabelSupprimer() {\n            // on allume le label [jLabelSupprimer] et l'option de menu correspondante\n            ...\n}\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doMajLabelSupprimer].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10395-supprimer-une-liste-candidate","title":"10.3.9.5. Supprimer une liste candidate","text":"<p>Le lien [Supprimer] [9] permet de supprimer le couple (nom,voix) s\u00e9lectionn\u00e9 dans (8). Une fois la suppression op\u00e9r\u00e9e, le lien [Supprimer] est \u00e9teint. Il ne sera rallum\u00e9 que sur s\u00e9lection d'une nouvelle liste dans (8).</p> <p>Dans la classe [AbstractElectionsSwing], le gestionnaire qui r\u00e9agit au clic sur le lien [Supprimer] est le suivant :</p> <pre><code>  private void jLabelSupprimerMouseClicked(java.awt.event.MouseEvent evt) {\n    if(jLabelSupprimer.isEnabled()){\n      doSupprimer();\n    }\n}\n</code></pre> <p>La ligne 3 appelle la m\u00e9thode [doSupprimer] de la classe [ElectionsSwing].</p> <pre><code>@Override\n    protected void doSupprimer() {\n        // suppression de la liste s\u00e9lectionn\u00e9e, du mod\u00e8le mod\u00e8leNomsVoix et des listes saisies\n        ...\n        // maj de l'\u00e9tat des labels et options de menu du formulaire\n        Utilitaires.setEnabled(...);\n    ...\n}\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doSupprimer].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10396-gerer-letat-du-lien-calculer","title":"10.3.9.6. G\u00e9rer l'\u00e9tat du lien [Calculer]","text":"<p>Le lien [Calculer] [10] n'est actif que lorsqu'il existe au moins un \u00e9l\u00e9ment dans [8].</p> <p>Travail \u00e0 faire : ajoutez le code n\u00e9cessaire \u00e0 la gestion de ce lien dans les m\u00e9thodes [doAjouter] et [doSupprimer] \u00e9crites pr\u00e9c\u00e9demment. L'option de menu correspondante sera \u00e9galement g\u00e9r\u00e9e.</p> <p>A savoir : le nombre d'\u00e9l\u00e9ments d'un \u00e9l\u00e9ment de type DefaultListModel est obtenu avec la m\u00e9thode size().</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10397-calculer-les-sieges","title":"10.3.9.7. Calculer les si\u00e8ges","text":"<p>Le lien [Calculer] [10] permet de lancer le calcul des si\u00e8ges et d'afficher les r\u00e9sultats dans (14). En cas d'\u00e9chec (toutes les listes ont \u00e9t\u00e9 \u00e9limin\u00e9es), un message d'erreur est affich\u00e9 dans [15]. Dans tous les cas, apr\u00e8s calcul, le lien [Calculer] [10] est d\u00e9sactiv\u00e9.</p> <p>Dans la classe [AbstractElectionsSwing], le gestionnaire qui r\u00e9agit au clic sur le lien [Calculer] est le suivant :</p> <pre><code>  private void jLabelCalculerMouseClicked(java.awt.event.MouseEvent evt) {\n    if(jLabelCalculer.isEnabled()){\n      doCalculer();\n    }\n}\n</code></pre> <p>La ligne 3 appelle la m\u00e9thode [doCalculer] de la classe [ElectionsSwing].</p> <pre><code>  // listes saisies par l'utilisateur\n  private final List&lt;ListeElectorale&gt; listesSaisies = new ArrayList&lt;&gt;();\n  private ListeElectorale[] tListesSaisies;\n\n...\n  @Override\n  protected void doCalculer() {\n    tListesSaisies = listesSaisies.toArray(new ListeElectorale[0]);\n    // calcul des si\u00e8ges\n    try {\n      ...\n    } catch (ElectionsException ex) {\n      // on affiche l'exception\n      ...\n      return;\n    }\n    // affichage des r\u00e9sultats\n    ...\n    // maj \u00e9tat formulaire\n    Utilitaires.setEnabled(...);\n}\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doCalculer].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10398-enregistrer-les-resultats-dans-la-source-de-donnees","title":"10.3.9.8. Enregistrer les r\u00e9sultats dans la source de donn\u00e9es","text":"<p>Le lien [Enregistrer] (12) permet d'enregistrer les r\u00e9sultats du calcul des si\u00e8ges dans la source de donn\u00e9es. Une fois l'enregistrement op\u00e9r\u00e9 avec succ\u00e8s, le lien [Enregistrer] est d\u00e9sactiv\u00e9. En cas d'\u00e9chec, un message d'erreur est affich\u00e9 dans [15]. Dans tous les cas, le lien [Enregistrer] est ensuite d\u00e9sactiv\u00e9.</p> <p>Dans la classe [AbstractElectionsSwing], le gestionnaire qui g\u00e8re le clic sur le label [Enregistrer] est le suivant :</p> <pre><code>  private void jLabelEnregistrerMouseClicked(java.awt.event.MouseEvent evt) {\n    if(jLabelEnregistrer.isEnabled()){\n      doEnregistrer();\n    }\n}\n</code></pre> <p>La ligne 3 appelle la m\u00e9thode [doEnregistrer] de la classe [ElectionsSwing] :</p> <pre><code>@Override\n    protected void doEnregistrer() {\n        // on demande l'enregistrement \u00e0 la couche m\u00e9tier\n        try {\n            ...\n        } catch (ElectionsException ex) {\n            // on affiche l'exception\n            ...\n            // retour \u00e0 l'interface graphique\n            return;\n        }\n        // maj du formulaire\n        Utilitaires.setEnabled(...);\n...\n}\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doEnregistrer].</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10399-effacer-les-resultats","title":"10.3.9.9. Effacer les r\u00e9sultats","text":"<p>Le lien [Effacer] (11) permet d'effacer les r\u00e9sultats affich\u00e9s dans (14).</p> <p>Dans la classe [AbstractElectionsSwing], le gestionnaire qui g\u00e8re le clic sur le label [Effacer] est le suivant :</p> <pre><code>  private void jLabelEffacerMouseClicked(java.awt.event.MouseEvent evt) {\n    if(jLabelEffacer.isEnabled()){\n      doEffacer();\n    }\n}\n</code></pre> <p>La ligne 3 appelle la m\u00e9thode [doEffacer] de la classe [ElectionsSwing] :</p> <pre><code>    @Override\n    protected void doEffacer() {\n        // on vide la liste des r\u00e9sultats\n        ....\n        // maj du formulaire\n        Utilitaires.setEnabled(...);\n}\n</code></pre> <p>Travail \u00e0 faire : compl\u00e9tez le code de la m\u00e9thode [doEffacer].</p> <p>A savoir : la classe DefaultListModel  a une m\u00e9thode clear() qui supprime tous ses \u00e9l\u00e9ments.</p>"},{"location":"td-implementation-de-la-couche-ui-avec-une-interface-swing.html#10310-ameliorations","title":"10.3.10. Am\u00e9liorations","text":"<p>L'interface graphique pr\u00e9c\u00e9dente peut \u00eatre am\u00e9lior\u00e9e de diverses fa\u00e7ons : l'utilisateur peut, par oubli, ne pas saisir les voix de toutes les listes pr\u00e9sentes dans le combo et par ailleurs, il peut, par erreur, saisir plusieurs fois les voix d'une m\u00eame liste.</p> <p>Travail \u00e0 faire : am\u00e9liorez l'algorithme afin que ces deux cas ne puissent pas se produire. Une solution simple est de g\u00e9rer un dictionnaire des listes saisies dont les cl\u00e9s seraient les \u00e9l\u00e9ments du combo. On fera \u00e9galement en sorte que le lien [Calculer] ne soit allum\u00e9 que lorsque la totalit\u00e9 des listes a \u00e9t\u00e9 saisie.</p> <p>A lire dans le cours [ref1]\u00a0: la classe HashTable au paragraphe 3.8.</p>"},{"location":"td-la-couche-metier.html","title":"8. [TD]\u00a0: La couche [metier]","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances.</p>"},{"location":"td-la-couche-metier.html#81-support","title":"8.1. Support","text":"<p>Le dossier [support / chap-08] contient le projet Eclipse de ce chapitre.</p>"},{"location":"td-la-couche-metier.html#82-configuration-maven","title":"8.2. Configuration Maven","text":"<p>Le projet [elections-metier-dao-jdbc] va s'appuyer sur le projet [elections-dao-jdbc-01]. Nous allons installer le jar de ce dernier projet dans le d\u00e9p\u00f4t Maven local\u00a0:</p> <p>Ceci fait, la configuration Maven du projet Eclipse [elections-metier-dao-jdbc] est la suivante\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-metier-dao-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- DAO --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-dao-jdbc-01&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring Boot Test --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;archive&gt;\n                        &lt;manifest&gt;\n                            &lt;mainClass&gt;config.AppConfig&lt;/mainClass&gt;\n                        &lt;/manifest&gt;\n                    &lt;/archive&gt;\n                    &lt;descriptorRefs&gt;\n                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;\n                    &lt;/descriptorRefs&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n            &lt;!-- pour l'installation de l'artifact du projet dans le d\u00e9p\u00f4t local Maven --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre> <ul> <li> <p>lignes 21-25\u00a0: la d\u00e9pendance sur le jar du projet [elections-jdbc-01]. On prend ces lignes directement dans le fichier [pom.xml] du projet que l'on veut importer\u00a0: <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-dao-jdbc-01&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n...\n</code></pre></p> </li> <li> <p>lignes 26-37\u00a0: les d\u00e9pendances n\u00e9cessaires aux tests. Bien qu'elles soient pr\u00e9sentes dans le fichier [pom.xml] du projet [elections-jdbc-01], nous sommes oblig\u00e9s de les remettre car leur attribut [&lt;scope&gt;test&lt;/scope&gt;] fait qu'elles n'ont pas \u00e9t\u00e9 incluses dans le jar mis dans le d\u00e9p\u00f4t Maven local\u00a0;</p> </li> </ul>"},{"location":"td-la-couche-metier.html#83-configuration-spring","title":"8.3. Configuration Spring","text":"<pre><code>package elections.metier.config;\n\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n\n@Import({ elections.dao.config.AppConfig.class })\n@EnableCaching\n@ComponentScan(basePackages = { \"elections.metier.service\" })\npublic class MetierConfig {\n}\n</code></pre> <ul> <li>ligne 7\u00a0: on importe tous les beans d\u00e9finis dans la couche [DAO]\u00a0;</li> <li>ligne 8\u00a0: on active le cache. On ne red\u00e9finit pas le bean [CacheManager], car il est d\u00e9j\u00e0 d\u00e9fini dans la couche [DAO]\u00a0;</li> <li>ligne 9\u00a0: la couche [m\u00e9tier] d\u00e9finit de nouveaux beans dans le package [elections.metier.service]\u00a0;</li> </ul>"},{"location":"td-la-couche-metier.html#84-linterface-ielectionsmetier","title":"8.4. L'interface [IElectionsMetier]","text":"<p>La couche [metier] aura l'interface pr\u00e9sent\u00e9e page 37. Nous la rappelons :</p> <pre><code>public interface IElectionsMetier {\n\n    public ListeElectorale[] getListesElectorales();\n\n    public int getNbSiegesAPourvoir();\n\n    public double getSeuilElectoral();\n\n    public void recordResultats(ListeElectorale[] listesElectorales);\n\n    public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales);\n\n}\n</code></pre>"},{"location":"td-la-couche-metier.html#85-la-classe-dimplementation-electionsmetier","title":"8.5. La classe d'impl\u00e9mentation [ElectionsMetier]","text":"<p>Cette classe impl\u00e9mente l'interface [IElectionsMetier]. L'impl\u00e9mentation propos\u00e9e aura la structure suivante :</p> <pre><code>package elections.metier.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Component;\n\nimport elections.dao.entities.ListeElectorale;\nimport elections.dao.service.IElectionsDao;\n\n@Component\npublic class ElectionsMetier implements IElectionsMetier {\n\n    // le point d'acc\u00e8s \u00e0 la couche [dao] instanci\u00e9e par [Spring]\n    @SuppressWarnings(\"unused\")\n    @Autowired\n    private IElectionsDao electionsDao;\n\n    // calcul des si\u00e8ges obtenus\n  @Override\n    public ListeElectorale[] calculerSieges(ListeElectorale[] listesElectorales) {\n        throw new RuntimeException(\"[calculerSieges] not yet implemented\");\n    }\n\n    // listes en comp\u00e9tition\n  @Override\n    public ListeElectorale[] getListesElectorales() {\n        throw new RuntimeException(\"[getListesElectorales] not yet implemented\");\n    }\n\n    // sauvegarde des r\u00e9sultats\n  @Override\n    public void recordResultats(ListeElectorale[] listesElectorales) {\n        throw new RuntimeException(\"[recordResultats] not yet implemented\");\n    }\n\n    // nombre de si\u00e8ges \u00e0 pourvoir\n    @Override\n    public int getNbSiegesAPourvoir() {\n        throw new RuntimeException(\"[getNbSiegesAPourvoir] not yet implemented\");\n    }\n\n    // seuil \u00e9lectoral\n    @Override\n    public double getSeuilElectoral() {\n        throw new RuntimeException(\"[getSeuilElectoral] not yet implemented\");\n    }\n\n}\n</code></pre> <ul> <li>ligne 10\u00a0: la classe [ElectionsMetier] est un composant Spring\u00a0;</li> <li>ligne 11 : la classe [ElectionsMetier] impl\u00e9mente l'interface [IElectionsMetier]\u00a0;</li> <li>lignes 15-16\u00a0: injection Spring d'une r\u00e9f\u00e9rence sur la couche [DAO]\u00a0;</li> <li>lignes 37 et 44\u00a0: le nombre de si\u00e8ges \u00e0 pourvoir et le seuil \u00e9lectoral sont mis en cache\u00a0; Travail \u00e0 faire : \u00e9crivez la classe [ElectionsMetier]. On s'aidera des commentaires lorsqu'il y en a. On n'essaiera pas d'arr\u00eater (try / catch) les exceptions de type [ElectionsException] qui remontent de la couche [DAO]. On les laissera remonter \u00e0 la couche [UI]. Parce que la classe [ElectionsException] est un type d'exception non contr\u00f4l\u00e9e, il n'y a pas obligation \u00e0 la g\u00e9rer par un (try / catch).</li> </ul>"},{"location":"td-la-couche-metier.html#86-la-classe-de-test","title":"8.6. La classe de test","text":"<p>La classe de test JUnit aura la forme suivante :</p> <pre><code>package tests;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport dao.config.AppConfig;\nimport dao.entities.ElectionsException;\nimport metier.service.IElectionsMetier;\n\n@SpringApplicationConfiguration(classes = MetierConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // couche [m\u00e9tier]\n    @Autowired\n    static private IElectionsMetier electionsMetier;\n\n    /**\n     * v\u00e9rification 1 : m\u00e9thode de calcul des si\u00e8ges on fixe en dur les listes\n     */\n    @Test\n    public void calculSieges1() {\n        // on cr\u00e9e le tableau des 7 listes candidates (nom, voix)\n\n        // on calcule les si\u00e8ges de chacune des listes\n\n        // on v\u00e9rifie les r\u00e9sultats (si\u00e8ges, voix, elimine)\n\n        // temporaire\n        throw new RuntimeException(\"[calculSieges1] not yet implemented\");\n    }\n\n    /**\n     * v\u00e9rification 2 : m\u00e9thode de calcul des si\u00e8ges on demande les listes \u00e0 la\n     * couche [metier] puis on fixe en dur les voix\n     */\n    @Test\n    public void calculSieges2() {\n        // on r\u00e9cup\u00e8re en base le tableau des 7 listes candidates\n\n        // on fixe en dur les voix\n\n        // on calcule les si\u00e8ges obtenus par chacune des listes\n\n        // on v\u00e9rifie les r\u00e9sultats (si\u00e8ges, voix, elimine)\n\n        // temporaire\n        throw new RuntimeException(\"[calculSieges2] not yet implemented\");\n    }\n\n    /**\n     * v\u00e9rification 3 m\u00e9thode de calcul des si\u00e8ges on provoque une exception\n     */\n    @Test(expected = ElectionsException.class)\n    // \u00e9crire un test qui provoque une exception de type [ElectionsException]\n    public void calculSieges3() {\n        // on cr\u00e9e un tableau de 25 listes candidates avec chacune 1 voix\n        // les 25 listes auront le m\u00eame nombre de voix (4%)\n\n        // calcul des si\u00e8ges - normalement on doit avoir une ElectionsException\n        // avec un seuil \u00e9lectoral de 5%\n\n        // temporaire\n        throw new RuntimeException(\"[calculSieges3] not yet implemented\");\n    }\n\n    /**\n     * enregistrement des r\u00e9sultats de l'\u00e9lection\n     */\n    @Test\n    public void ecritureResultatsElections() {\n        // on cr\u00e9e le tableau des 7 listes candidates\n\n        // on fixe en dur les voix\n\n        // on calcule les si\u00e8ges obtenus par chacune des listes\n\n        // on enregistre les r\u00e9sultats dans la base de donn\u00e9es\n\n        // on relit les listes en base\n\n        // on v\u00e9rifie les r\u00e9sultats (si\u00e8ges, voix, elimine)\n\n        // temporaire\n        throw new RuntimeException(\"[ecritureResultatsElections] not yet implemented\");\n    }\n}\n</code></pre> <p>Travail \u00e0 faire : \u00e9crivez les quatre m\u00e9thodes de tests en vous aidant des commentaires. On se rappellera que lorsque ces m\u00e9thodes s'ex\u00e9cutent, le champ [electionsMetier] de la ligne 19 a d\u00e9j\u00e0 \u00e9t\u00e9 initialis\u00e9. V\u00e9rifiez que le test JUnit passe.</p>"},{"location":"td-la-couche-metier.html#87-creation-de-larchive-de-la-couche-metier","title":"8.7. Cr\u00e9ation de l'archive de la couche [metier]","text":"<p>Comme il a \u00e9t\u00e9 fait pour la couche [DAO], nous mettons l'archive du projet [elections-metier-dao-jdbc] dans le d\u00e9p\u00f4t Maven local\u00a0:</p> <p>Note\u00a0: cette op\u00e9ration peut \u00e9chouer si votre projet Eclipse est associ\u00e9 \u00e0 un JRE (Java Runtime Environment) au lieu d'un JDK (Java Development Kit). Pour le savoir, proc\u00e9dez comme indiqu\u00e9 au paragraphe 3.1, page 16. Si vous d\u00e9couvrez que vous avez un JRE et non un JDK, associez votre projet \u00e0 un JDK comme indiqu\u00e9 dans ce paragraphe.</p>"},{"location":"td-la-couche-metier.html#88-conclusion","title":"8.8. Conclusion","text":"<p>Rappelons l'architecture g\u00e9n\u00e9rale de l'application [Elections] que nous sommes en train de construire :</p> <p>Nous avons construit les couches [metier] et [dao]. Nous allons maintenant construire la couche [ui]. Nous proposerons deux impl\u00e9mentations pour cette couche :</p> <ul> <li>une impl\u00e9mentation \"\u00a0console\u00a0\"</li> <li>une impl\u00e9mentation avec interface graphique</li> </ul>"},{"location":"td-le-probleme.html","title":"2. [TD]\u00a0: Le probl\u00e8me","text":"<p>Mots cl\u00e9s : algorithmique, bases de Java : tableaux, E/S, boucles, tests, gestion d'exceptions</p> <p>Lectures conseill\u00e9es : chapitre 1 de [ref1] : Les bases du langage Java</p>"},{"location":"td-le-probleme.html#21-support","title":"2.1. Support","text":"<p>Le dossier [support / chap-02] contient l'algorithme \u00e0 traduire en C# et Java.</p>"},{"location":"td-le-probleme.html#22-le-probleme-a-resoudre","title":"2.2. Le probl\u00e8me \u00e0 r\u00e9soudre","text":"<p>On d\u00e9sire \u00e9crire un programme qui, au soir d'\u00e9lections, puisse calculer le nombre de si\u00e8ges obtenus par les diff\u00e9rentes listes en pr\u00e9sence. On trouvera un peu plus loin, le mode de calcul des si\u00e8ges pour une \u00e9lection proportionnelle \u00e0 la plus forte moyenne, tel qu'expliqu\u00e9 dans un article du journal Ouest-France du 15 mars 1986.</p> <p>On \u00e9crira une application Java \"console\", c.a.d. une application utilisant le clavier et l'\u00e9cran pour communiquer avec l'utilisateur. Elle demandera les renseignements suivants \u00e0 l'utilisateur (tap\u00e9s au clavier) :</p> <ul> <li>nombre de si\u00e8ges \u00e0 pourvoir</li> <li>nombre de listes en comp\u00e9tition</li> <li> <p>pour chaque liste : son nom, son nombre de voix Avec ces renseignements, l'application calcule les si\u00e8ges obtenus par chacune des listes et les affiche \u00e0 l'\u00e9cran sous la forme suivante :</p> </li> <li> <p>La liste [X1] a obtenu [N1] si\u00e8ges</p> </li> <li> <p>La liste [X2] a obtenu [N2] si\u00e8ges</p> </li> <li> <p>...</p> </li> </ul> <p>o\u00f9 [Xi] est le nom de la liste n\u00b0 i et [Ni] le nombre de si\u00e8ges qu'elle a obtenus.</p> <p>L'article Ouest-France du 15 mars 1986 :</p> <p></p> <p></p>"},{"location":"td-le-probleme.html#23-la-solution-algorithmique","title":"2.3. La solution algorithmique","text":"<p>Une solution algorithmique pourrait \u00eatre la suivante\u00a0:</p> <pre><code>d\u00e9but-programme\n    // donn\u00e9es\n    saisieOK : bool\u00e9en\n    nbSi\u00e8gesAPourvoir : entier\n    nbListes : entier\n    nomListe[] : cha\u00eenes de caract\u00e8res\n    voixListe[] : entier\n    elimineListe[] : bool\u00e9en\n    siegesListe[] : entier\n    moyenneListe[] : r\u00e9el\n    i : entier\n    nbVoixUtiles : entier\n    quotientElectoral : r\u00e9el\n    nbSi\u00e8gesPourvus : entier\n    moyenneMax : r\u00e9el\n    Max : entier iSi\u00e8ge : entier\n\n    // code\n    // nbre de si\u00e8ges \u00e0 pourvoir\n    saisieOK&lt;-faux\n    tant que non saisieOK\n        \u00e9crire \"Nombre de si\u00e8ges \u00e0 pourvoir : \"\n        lire nbSi\u00e8gesAPourvoir\n        si nbSi\u00e8gesAPourvoir n'est pas un entier &gt;0 alors\n            \u00e9crire \"Erreur : tapez un nombre entier &gt;0\"\n        sinon\n            saisieOK&lt;-vrai\n        finsi\n    fintantque\n    // nbre de listes en comp\u00e9tition\n    saisieOK&lt;-faux\n    tant que non saisieOK\n        \u00e9crire \"Nombre de listes en comp\u00e9tition : \"\n        lire nbListes\n        si nbListes n'est pas un entier &gt;0 alors\n            \u00e9crire \"Erreur : tapez un nombre entier &gt;0\"\n        sinon\n            saisieOK&lt;-vrai\n        finsi\n    fintantque\n\n    // dimensionnement des tableaux\n    dimensionner les tableau nomListe, voixListe, elimineListe, siegesListe, moyenneListe \u00e0 nbListes \u00e9l\u00e9ments\n\n    // saisie des noms et voix des listes\n    totalVoix&lt;-0\n    pour i variant de 0 \u00e0 nbListes-1\n        // saisie du nom de la liste i\n        saisieOK&lt;-faux\n        tantque non saisieOK\n        \u00e9crire \"Nom de la liste n\u00b0 \", i, \" : \"\n        lire nomListe[i]\n        si nomListe[i] est vide alors\n            \u00e9crire \"Erreur : Tapez un nom non vide\"\n        sinon\n            saisieOK&lt;-vrai\n        finsi\n    fintantque\n    // saisie du nombre de voix de la liste i\n    saisieOK&lt;-faux\n    tantque non saisieOK\n        \u00e9crire \"Nombre de voix de la liste \", nomListe[i] , \" : \"\n        lire voixListe[i]\n        si voixListe[i] n'est pas un nombre entier &gt;=0 alors\n            \u00e9crire \"Erreur : tapez un nombre entier &gt;=0\"\n        sinon\n            saisieOK&lt;-vrai\n        finsi\n    fintantque\n\n    // on incr\u00e9mente le total des voix\n    totalVoix&lt;- totalVoix+voixListe[i]79.finpour 80.\n    // calcul des voix utiles\n    nbVoixUtiles&lt;-0\n    pour i variant de 0 \u00e0 nbListes-1\n        si (voixListe[i]/totalVoix)&lt;0.05 alors\n            elimineListe[i]&lt;-vrai\n        sinon\n            elimineListe[i]&lt;-faux\n            nbVoixUtiles&lt;-nbVoixUtiles+voixListe[i]\n        finsi\n    finpour\n    // y-a-t-il des listes non \u00e9limin\u00e9es ?\n    si nbVoixUtiles=0 alors\n        \u00e9crire \"Erreur : toutes les listes ont \u00e9t\u00e9 \u00e9limin\u00e9es\"\n        arr\u00eat du programme\n    finsi\n    // r\u00e9partition des si\u00e8ges au quotient\n    quotientElectoral &lt;- nbVoixUtiles / nbSi\u00e8gesAPourvoir\n    nbSi\u00e8gesPourvus&lt;- 0\n    pour i variant de 0 \u00e0 nbListes-1\n        si non elimineListe[i] alors\n            siegesListe[i]&lt;- partie enti\u00e8re de (voixListe[i]/quotientElectoral)\n            moyenneListe[i] &lt;- voixListe[i] / (siegesListe[i]+1)\n            nbSi\u00e8gesPourvus&lt;-nbSi\u00e8gesPourvus+siegesListe[i]\n        sinon\n            siegesListe[i]&lt;-0\n        finsi\n    finpour\n    // r\u00e9partition des si\u00e8ges restants \u00e0 la plus forte moyenne\n    // 1 si\u00e8ge est attribu\u00e9 \u00e0 chaque tour de boucle\n    pour iSi\u00e8ge variant de 0 \u00e0 nbSi\u00e8gesAPourvoir - nbSi\u00e8gesPourvus - 1\n        // recherche de la liste ayant la + forte moyenne\n        moyenneMax&lt;- (-1)\n        pour i variant de 0 \u00e0 nbListes-1\n            si non elimineListe[i] alors\n                si moyenneListe[i] &gt; moyenneMax alors\n                    moyenneMax &lt;- moyenneListe[i]\n                    iMax &lt;- i\n                finsi\n            finsi\n        finpour\n        // on attribue 1 si\u00e8ge \u00e0 la liste de + forte moyenne\n        siegeListe[iMax] &lt;- siegeListe[iMax]+1\n        // et on change sa moyenne\n        moyenneListe[iMax] &lt;- voixListe[iMax]/(siegeListe[iMax]+1)\n    finpour\n    // affichage r\u00e9sultats sans tri\n    pour i variant de 0 \u00e0 nbListes-1\n        si elimineListe[i] alors\n            \u00e9crire \"La liste \", nomListe[i], \" a \u00e9t\u00e9 \u00e9limin\u00e9e\"\n        sinon\n            \u00e9crire \"La liste \", nomListe[i], \" a obtenu \",\n            siegesListe[i], \" si\u00e8ge(s)\"\n        finsi\n    finpour\nfin-programme\n</code></pre>"},{"location":"td-le-probleme.html#24-travail-a-faire","title":"2.4. Travail \u00e0 faire","text":"<p>Q1 : traduire l'algorithme en C#. Le mettre en oeuvre avec Visual Studio.</p> <p>Q2 : traduire l'algorithme en Java en vous inspirant du code C#. Mettre en oeuvre le programme Java dans un environnement Eclipse analogue au suivant :</p> <ul> <li>[1] : le projet s'appelle [elections-01]</li> <li>[2] : l'application sera plac\u00e9e dans un paquetage, ici [istia.st.elections]</li> <li>[3] : [MainElections.java] est le code source de l'application \u00e9crite dans la partie pr\u00e9c\u00e9dente</li> <li>[4] : la classe [MainElections] est ex\u00e9cut\u00e9e Un exemple d'ex\u00e9cution pourrait \u00eatre le suivant :</li> </ul> <p></p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html","title":"17. [TD]\u00a0: s\u00e9curisation du serveur web / jSON des \u00e9lections","text":"<p>Mots cl\u00e9s : architecture multicouche, Spring, injection de d\u00e9pendances, service web / jSON s\u00e9curis\u00e9, client / serveur</p> <p>Nous appliquons maintenant ce que nous avons appris dans le chapitre pr\u00e9c\u00e9dent au TD des \u00e9lections. L'architecture sera la suivante\u00a0:</p> <p>La progession se fera de la fa\u00e7on suivante\u00a0:</p> <ul> <li>\u00e9criture du serveur\u00a0;</li> <li>\u00e9criture du client sans couche [ui] mais avec un test JUnit de la couche [m\u00e9tier]\u00a0;</li> <li>\u00e9criture du client avec la couche [ui]\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#171-support","title":"17.1. Support","text":"<p>Les projets de ce chapitre seront trouv\u00e9s dans le dossier [support / chap-17]. Le script SQL sert \u00e0 g\u00e9n\u00e9rer la base de donn\u00e9es n\u00e9cessaire aux tests.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#172-la-base-de-donnees","title":"17.2. La base de donn\u00e9es","text":"<p>La base de donn\u00e9es du serveur s\u00e9curis\u00e9 doit maintenant comporter les tables [USERS], [ROLES] et [USERS_ROLES]\u00a0:</p> <p>Le script SQL de la g\u00e9n\u00e9ration de la base est disponible dans le support du document.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#173-le-serveur-securise","title":"17.3. Le serveur s\u00e9curis\u00e9","text":"<p>Pour mettre en place le serveur s\u00e9curis\u00e9 des \u00e9lections, nous nous contentons de faire un copy / paste du projet exemple [intro-spring-security-server-01]\u00a0:</p> <p>Travail \u00e0 faire\u00a0: renommez les packages comme montr\u00e9 en [1].</p> <p>Ceci fait, nous modifions le fichier [pom.xml] de la fa\u00e7on suivante\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-security-webjson-metier-dao-spring-data&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n\n    &lt;name&gt;elections-security-webjson-metier-dao-spring-data&lt;/name&gt;\n    &lt;description&gt;elections spring security&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-webjson-metier-dao-spring-data&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring security --&gt;\n        ...\n    &lt;/dependencies&gt;\n    &lt;!-- plugins --&gt;\n    &lt;build&gt;\n        ...\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>aux lignes 23-27, remplacez la d\u00e9pendance sur le projet [intro-server-webjson-01] par celle sur le projet [elections-webjson-metier-dao-spring-data] \u00e9tudi\u00e9 au paragraphe 12, page 209\u00a0;</li> <li>aux lignes 4-7, mettre les caract\u00e9ristiques du nouveau projet\u00a0; Il nous reste \u00e0 modifier les classes de configuration du projet\u00a0:</li> </ul> <p>[DaoConfig]</p> <pre><code>package elections.security.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n\n@EnableJpaRepositories(basePackages = { \"elections.security.repositories\" })\n@ComponentScan(basePackages = { \"elections.security.dao\" })\n@Import({ elections.dao.config.DaoConfig.class })\npublic class DaoConfig {\n\n    // constantes\n    final static private String[] ENTITIES_PACKAGES = { \"elections.dao.entities\", \"elections.security.entities\" };\n\n\n    @Bean\n    public String[] packagesToScan() {\n        return ENTITIES_PACKAGES;\n    }\n\n}\n</code></pre> <p>Les modifications sont aux lignes suivantes\u00a0:</p> <ul> <li>lignes 8, 9, 14\u00a0: mettre les bons noms de packages\u00a0;</li> <li>ligne 10\u00a0: la classe import\u00e9e est maintenant [elections.dao.config.DaoConfig] du projet [elections-webjson-metier-dao-spring-data]\u00a0; Note\u00a0: comme il a \u00e9t\u00e9 dit, cette configuration ne marche que si la classe [elections.dao.config.DaoConfig] a l'annotation [@Configuration]. V\u00e9rifiez ce point.</li> </ul> <p>[SecurityConfig]</p> <pre><code>package elections.security.config;\n\n...\n\n@EnableWebSecurity\n@ComponentScan(basePackages = { \"elections.security.service\" })\n@Import({ WebConfig.class, DaoConfig.class })\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    ...\n}\n</code></pre> <p>Les modifications sont aux lignes suivantes\u00a0:</p> <ul> <li>ligne 6\u00a0: changez le nom du package\u00a0; C'est tout. Faites un premier test en ex\u00e9cutant le test JUnit []\u00a0:</li> </ul> <p>Ex\u00e9cutez la classe de boot [Boot] puis avec l'extension Chrome [Advanced Rest Client] faites le test suivant\u00a0:</p> <p>En [1], la demande. En [3], la r\u00e9ponse. En [2], l'ent\u00eate HTTP est l'ent\u00eate d'authentification de l'utilisateur [admin, admin]\u00a0: Authorization:Basic YWRtaW46YWRtaW4=</p> <p>Demandez maintenant, les listes en comp\u00e9tition\u00a0:</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#174-le-client-du-serveur-securise-sans-la-couche-ui","title":"17.4. Le client du serveur s\u00e9curis\u00e9 sans la couche [ui]","text":"<p>Faites un copy / paste du projet [elections-ui-metier-dao-webjson] dans le projet [elections-metier-dao-security-webjson].</p> <p>1</p> <p>Travail \u00e0 faire\u00a0: en [1], renommez les packages si n\u00e9cessaire et supprimez ceux de la couche [ui] et des classes de d\u00e9marrage [boot].</p> <p>Nous allons proc\u00e9der maintenant comme il a \u00e9t\u00e9 fait au paragraphe 16.5, page 321.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1741-configuration-maven","title":"17.4.1. Configuration Maven","text":"<p>Seule la partie identification du projet change\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-metier-dao-security-webjson&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;description&gt;Client jUnit du serveur web / jSON&lt;/description&gt;\n    &lt;name&gt;elections-metier-dao-security-webjson&lt;/name&gt;\n...\n</code></pre>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1742-refactorisation-de-la-couche-metier","title":"17.4.2. Refactorisation de la couche [m\u00e9tier]","text":"<p>L'interface [IElectionsMetier] \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.security.client.metier;\n\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\n\npublic interface IElectionsMetier {\n\n    // authentification\n    public void authenticate(User user);\n\n    // obtenir les listes en comp\u00e9tition\n    public ListeElectorale[] getListesElectorales(User user);\n\n    // le nombre de si\u00e8ges \u00e0 pourvoir\n    public int getNbSiegesAPourvoir(User user);\n\n    // le seuil \u00e9lectoral\n    public double getSeuilElectoral(User user);\n\n    // l'enregistrement des r\u00e9sultats\n    public void recordResultats(User user, ListeElectorale[] listesElectorales);\n\n    // le calcul des si\u00e8ges\n    public ListeElectorale[] calculerSieges(User user, ListeElectorale[] listesElectorales);\n\n}\n</code></pre> <p>Toutes les m\u00e9thodes ont pour premier param\u00e8tre, l'utilisateur qui veut utiliser les ressources du serveur s\u00e9curis\u00e9.</p> <p>L'impl\u00e9mentation [ElectionsMetier] \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.security.client.metier;\n\nimport java.io.IOException;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Component;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport elections.security.client.dao.IClientDao;\nimport elections.security.client.entities.ElectionsConfig;\nimport elections.security.client.entities.ElectionsException;\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\n\n@Component\npublic class ElectionsMetier implements IElectionsMetier {\n\n  @Autowired\n  private IClientDao dao;\n  @Autowired\n  private ApplicationContext context;\n\n  // configuration de l'\u00e9lection\n  private ElectionsConfig electionsConfig;\n\n  private ElectionsConfig getElectionsConfig(User user) {\n    if(electionsConfig!=null){\n      return electionsConfig;\n    }\n    // mappeurs jSON\n    ObjectMapper mapperResponse = context.getBean(ObjectMapper.class);\n    try {\n      // requ\u00eate\n      Response&lt;ElectionsConfig&gt; response = mapperResponse.readValue(dao.getResponse(user, \"/getElectionsConfig\", null),\n              new TypeReference&lt;Response&lt;ElectionsConfig&gt;&gt;() {\n      });\n      // erreur ?\n      if (response.getStatus() != 0) {\n        // on lance 1 exception\n        throw new ElectionsException(response.getStatus(), response.getMessages());\n      } else {\n        electionsConfig = response.getBody();\n        return electionsConfig;\n      }\n    } catch (ElectionsException e1) {\n      throw e1;\n    } catch (IOException | RuntimeException e2) {\n      throw new ElectionsException(100, e2);\n    }\n  }\n\n  @Override\n  public ListeElectorale[] getListesElectorales(User user) {\n   ...\n  }\n\n  @Override\n  public int getNbSiegesAPourvoir(User user) {\n    return getElectionsConfig(user).getNbSiegesAPourvoir();\n  }\n\n  @Override\n  public double getSeuilElectoral(User user) {\n    return getElectionsConfig(user).getSeuilElectoral();\n  }\n\n  @Override\n  public void recordResultats(User user, ListeElectorale[] listesElectorales) {\n    ...\n  }\n\n  @Override\n  public ListeElectorale[] calculerSieges(User user, ListeElectorale[] listesElectorales) {\n    ...\n  }\n\n  @Override\n  public void authenticate(User user) {\n    dao.getResponse(user, \"/authenticate\", null);\n  }\n}\n</code></pre> <p>Travail \u00e0 faire\u00a0: compl\u00e9tez le code ci-dessus.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1743-configuration-spring","title":"17.4.3. Configuration Spring","text":"<p>La classe [MetierConfig] \u00e9volue comme suit\u00a0:</p> <pre><code>package elections.security.client.config;\n\n...\n\n@ComponentScan({ \"elections.security.client.dao\", \"elections.security.client.metier\" })\npublic class MetierConfig {\n</code></pre> <p>Ligne 5, les packages \u00e0 explorer doivent \u00eatre mis \u00e0 jour.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1744-le-test-junit-de-la-couche-metier","title":"17.4.4. Le test JUnit de la couche [m\u00e9tier]","text":"<p>La classe de test [Test01] \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.security.client.metier.junit;\n\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.SpringApplicationConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport elections.security.client.config.MetierConfig;\nimport elections.security.client.entities.ElectionsException;\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport elections.security.client.metier.IElectionsMetier;\n\n@SpringApplicationConfiguration(classes = MetierConfig.class)\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class Test01 {\n\n    // couche [electionsMetier]\n    @Autowired\n    private IElectionsMetier electionsMetier;\n\n    // mappeur jSON\n    private final ObjectMapper mapper = new ObjectMapper();\n\n    // utilisateurs\n    static private User admin;\n    static private User user;\n    static private User unknown;\n\n    @BeforeClass\n    public static void initTest() {\n        admin = new User(\"admin\", \"admin\");\n        user = new User(\"user\", \"user\");\n        unknown = new User(\"x\", \"y\");\n    }\n\n    @Test()\n    public void checkUserUser() {\n        ElectionsException se = null;\n        try {\n            electionsMetier.authenticate(user);\n        } catch (ElectionsException e) {\n            se = e;\n        }\n        Assert.assertNotNull(se);\n        Assert.assertEquals(\"403 Forbidden\", se.getErreurs().get(0));\n    }\n\n    @Test()\n    public void checkUserUnknown() {\n        ElectionsException se = null;\n        try {\n            electionsMetier.authenticate(unknown);\n        } catch (ElectionsException e) {\n            se = e;\n        }\n        Assert.assertNotNull(se);\n        Assert.assertEquals(\"401 Unauthorized\", se.getErreurs().get(0));\n    }\n\n    @Test()\n    public void checkUserAdmin() {\n        ElectionsException se = null;\n        try {\n            electionsMetier.authenticate(admin);\n        } catch (ElectionsException e) {\n            se = e;\n        }\n        Assert.assertNull(se);\n    }\n\n    /**\n     * v\u00e9rification 1 : m\u00e9thode de calcul des si\u00e8ges on fixe en dur les listes\n     */\n    @Test\n    public void calculSieges1() {\n        // on cr\u00e9e le tableau des 7 listes candidates\n        ListeElectorale[] listes = new ListeElectorale[7];\n        listes[0] = new ListeElectorale(\"A\", 32000, 0, false);\n        listes[1] = new ListeElectorale(\"B\", 25000, 0, false);\n        listes[2] = new ListeElectorale(\"C\", 16000, 0, false);\n        listes[3] = new ListeElectorale(\"D\", 12000, 0, false);\n        listes[4] = new ListeElectorale(\"E\", 8000, 0, false);\n        listes[5] = new ListeElectorale(\"F\", 4500, 0, false);\n        listes[6] = new ListeElectorale(\"G\", 2500, 0, false);\n        // on calcule les si\u00e8ges de chacune des listes\n        listes = electionsMetier.calculerSieges(admin,listes);\n        // on v\u00e9rifie les r\u00e9sultats\n        Assert.assertEquals(2, listes[0].getSieges());\n        Assert.assertFalse(listes[0].isElimine());\n        Assert.assertEquals(2, listes[1].getSieges());\n        Assert.assertFalse(listes[1].isElimine());\n        Assert.assertEquals(1, listes[2].getSieges());\n        Assert.assertFalse(listes[2].isElimine());\n        Assert.assertEquals(1, listes[3].getSieges());\n        Assert.assertFalse(listes[3].isElimine());\n        Assert.assertEquals(0, listes[4].getSieges());\n        Assert.assertFalse(listes[4].isElimine());\n        Assert.assertEquals(0, listes[5].getSieges());\n        Assert.assertTrue(listes[5].isElimine());\n        Assert.assertEquals(0, listes[6].getSieges());\n        Assert.assertTrue(listes[6].isElimine());\n    }\n\n    /**\n     * v\u00e9rification 2 : m\u00e9thode de calcul des si\u00e8ges on demande les listes \u00e0 la couche [metier] puis on fixe en dur les\n     * voix\n     */\n    @Test\n    public void calculSieges2() {\n        // on cr\u00e9e le tableau des 7 listes candidates\n        ListeElectorale[] listes = electionsMetier.getListesElectorales(admin);\n        // on fixe en dur les voix\n        listes[0].setVoix(32000);\n        listes[1].setVoix(25000);\n        listes[2].setVoix(16000);\n        listes[3].setVoix(12000);\n        listes[4].setVoix(8000);\n        listes[5].setVoix(4500);\n        listes[6].setVoix(2500);\n        // on calcule les si\u00e8ges obtenus par chacune des listes\n        listes = electionsMetier.calculerSieges(admin,listes);\n        // on v\u00e9rifie les r\u00e9sultats\n        Assert.assertEquals(2, listes[0].getSieges());\n        Assert.assertFalse(listes[0].isElimine());\n        Assert.assertEquals(2, listes[1].getSieges());\n        Assert.assertFalse(listes[1].isElimine());\n        Assert.assertEquals(1, listes[2].getSieges());\n        Assert.assertFalse(listes[2].isElimine());\n        Assert.assertEquals(1, listes[3].getSieges());\n        Assert.assertFalse(listes[3].isElimine());\n        Assert.assertEquals(0, listes[4].getSieges());\n        Assert.assertFalse(listes[4].isElimine());\n        Assert.assertEquals(0, listes[5].getSieges());\n        Assert.assertTrue(listes[5].isElimine());\n        Assert.assertEquals(0, listes[6].getSieges());\n        Assert.assertTrue(listes[6].isElimine());\n    }\n\n    /**\n     * v\u00e9rification 3 m\u00e9thode de calcul des si\u00e8ges on provoque une exception\n     */\n    @Test(expected = ElectionsException.class)\n    public void calculSieges3() {\n        // on cr\u00e9e un tableau de 24 listes candidates avec chacune 1 voix\n        ListeElectorale[] listes = new ListeElectorale[25];\n        // les 25 listes auront le m\u00eame nombre de voix (4%)\n        for (int i = 0; i &lt; listes.length; i++) {\n            listes[i] = new ListeElectorale(\"Liste\" + (i + 1), 1, 0, false);\n        }\n        // calcul des si\u00e8ges - normalement on doit avoir une ElectionsException\n        // avec un seuil \u00e8lectoral de 5%\n        electionsMetier.calculerSieges(admin,listes);\n    }\n\n    /**\n     * enregistrement des r\u00e9sultats de l'\u00e9lection\n     * \n     * @throws JsonProcessingException\n     */\n    @Test\n    public void ecritureResultatsElections() throws JsonProcessingException {\n        // on cr\u00e9e le tableau des 7 listes candidates\n        ListeElectorale[] listes = electionsMetier.getListesElectorales(admin);\n        // on fixe en dur les voix\n        listes[0].setVoix(32000);\n        listes[1].setVoix(25000);\n        listes[2].setVoix(16000);\n        listes[3].setVoix(12000);\n        listes[4].setVoix(8000);\n        listes[5].setVoix(4500);\n        listes[6].setVoix(2500);\n        // on calcule les si\u00e8ges obtenus par chacune des listes\n        listes = electionsMetier.calculerSieges(admin,listes);\n        // on affiche les r\u00e9sultats\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(mapper.writeValueAsString(listes[i]));\n        }\n        // on enregistre les r\u00e9sultats dans la base de donn\u00e9es\n        electionsMetier.recordResultats(admin,listes);\n        // on v\u00e9rifie les r\u00e9sultats\n        listes = electionsMetier.getListesElectorales(admin);\n        // on affiche les r\u00e9sultats\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(mapper.writeValueAsString(listes[i]));\n        }\n        Assert.assertEquals(2, listes[0].getSieges());\n        Assert.assertFalse(listes[0].isElimine());\n        Assert.assertEquals(2, listes[1].getSieges());\n        Assert.assertFalse(listes[1].isElimine());\n        Assert.assertEquals(1, listes[2].getSieges());\n        Assert.assertFalse(listes[2].isElimine());\n        Assert.assertEquals(1, listes[3].getSieges());\n        Assert.assertFalse(listes[3].isElimine());\n        Assert.assertEquals(0, listes[4].getSieges());\n        Assert.assertFalse(listes[4].isElimine());\n        Assert.assertEquals(0, listes[5].getSieges());\n        Assert.assertTrue(listes[5].isElimine());\n        Assert.assertEquals(0, listes[6].getSieges());\n        Assert.assertTrue(listes[6].isElimine());\n    }\n}\n</code></pre> <p>Travail \u00e0 faire\u00a0: comprenez ce test et v\u00e9rifiez qu'il passe.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#175-le-client-du-serveur-securise-avec-une-couche-console","title":"17.5. Le client du serveur s\u00e9curis\u00e9 avec une couche [console]","text":"<p>Avec Netbeans, nous ouvrons les projets Maven [elections-metier-dao-security-webjson] et [elections-ui-metier-dao-webjson] puis nous construisons un nouveau projet  [elections-console-metier-dao-security-webjson] par un copy / paste du projet [elections-ui-metier-dao-webjson]\u00a0:</p> <p>La plupart des classes du nouveau projet [3] proviennent du projet [elections-ui-metier-dao-webjson] [2] qui \u00e9tait le client du serveur web / jSON non s\u00e9curis\u00e9\u00a0:</p> <p>Proc\u00e9dez ainsi pour construire le nouveau projet Maven\u00a0:</p> <ul> <li>faites un copy / paste du projet [elections-ui-metier-dao-webjson] dans le projet [elections-ui-metier-dao-security-webjson]\u00a0;</li> <li>dans le nouveau projet\u00a0:</li> <li>supprimez les packages [elections.client.dao, elections.client.metier, elections.client.entities]\u00a0;</li> <li>dans le package [elections.client.ui], gardez seulement la classe console [ElectionsConsole] et son interface [IElectionsUI]\u00a0;</li> <li>renommez les packages comme indiqu\u00e9 en [3]\u00a0;</li> <li>r\u00e9glez les probl\u00e8mes d'import dans les diverses classes par [clic droit / Fix Imports]\u00a0; A ce stade, le nouveau projet pr\u00e9sente de nombreuses erreurs.</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1751-configuration-maven","title":"17.5.1. Configuration Maven","text":"<p>Le fichier [pom.xml] du nouveau projet est le suivant\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-console-metier-dao-security-webjson&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;elections-console-metier-dao-security-webjson&lt;/name&gt;\n    &lt;description&gt;couche console du client web / jSON&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-metier-dao-security-webjson&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 4-8\u00a0: l'identit\u00e9 Maven du nouveau projet\u00a0;</li> <li>lignes 22-26\u00a0: la d\u00e9pendance sur le projet [elections-metier-dao-security-webjson] que nous venons de construire au paragraphe 17.4, page 333, et qui fournit les couches [DAO] et [m\u00e9tier]\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1752-configuration-spring","title":"17.5.2. Configuration Spring","text":"<p>La classe [UiConfig] est la suivante\u00a0:</p> <pre><code>package elections.security.client.config;\n\nimport elections.security.client.entities.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Import;\n\n@Import(MetierConfig.class)\n@ComponentScan(basePackages = {\"elections.security.client.console\",\"elections.security.client.swing\"})\npublic class UiConfig {\n\n  // administrateur\n  private final User ADMIN = new User(\"admin\", \"admin\");\n\n  @Bean\n  private User admin() {\n    return ADMIN;\n  }\n\n}\n</code></pre> <ul> <li>ligne 8\u00a0: on importe la classe [elections.security.client.config.MetierConfig] du projet [elections-metier-dao-security-webjson] \u00e9tudi\u00e9 au paragraphe 17.4, page 333\u00a0;</li> <li>ligne 9\u00a0: on d\u00e9clare les packages o\u00f9 se trouvent les beans Spring\u00a0;</li> <li>lignes 12-18\u00a0: le bean [admin] est l'utilisateur [admin, admin] qui sera utilis\u00e9 par l'application console. On se rappelle que c'est le seul utilisateur autoris\u00e9 \u00e0 interroger el serveur web / jSON s\u00e9curis\u00e9\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1753-lapplication-de-boot-de-la-console","title":"17.5.3. L'application de boot de la console","text":"<p>La classe [ElectionsConsole] \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.security.client.console;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport elections.security.client.entities.ElectionsException;\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport elections.security.client.metier.IElectionsMetier;\n\n@Component\npublic class ElectionsConsole implements IElectionsUI {\n\n    @Autowired\n    private IElectionsMetier electionsMetier;\n\n  @Autowired\n  private User admin;\n\n    @Override\n    public void run() {\n        // les listes en comp\u00e9tition\n        ListeElectorale[] listes;\n        // saisie des donn\u00e9es\n        try (Scanner clavier = new Scanner(System.in)) {\n            // on demande les listes en comp\u00e9tition \u00e0 la couche [metier]\n            listes = electionsMetier.getListesElectorales(admin);\n            // on fait la saisie des voix\n            System.out.println(\"Il y a \" + listes.length\n                    + \" listes en comp\u00e9tition. Veuillez indiquer le nombre de voix de chacune d'elles :\");\n            for (int i = 0; i &lt; listes.length; i++) {\n                boolean saisieOK = false;\n                while (!saisieOK) {\n                    System.out.print(\"Nombre de voix de la liste [\" + listes[i].getNom() + \"] : \");\n                    try {\n                        listes[i].setVoix(Integer.parseInt(clavier.nextLine()));\n                        saisieOK = true;\n                    } catch (ElectionsException | NumberFormatException ex) {\n                        System.out.println(\"Nombre de voix incorrect. Veuillez recommencer\");\n                    }\n                }\n            }\n        }\n        // on fait le calcul des si\u00e8ges\n        listes=electionsMetier.calculerSieges(admin,listes);\n        // on enregistre les r\u00e9sultats\n        electionsMetier.recordResultats(admin,listes);\n        // tri des listes dans l'ordre d\u00e9croissant des voix\n        Arrays.sort(listes, new CompareListesElectorales());\n        // on les affiche\n        System.out.println(\"\\nR\u00e9sultats de l'\u00e9lection\\n\");\n        for (int i = 0; i &lt; listes.length; i++) {\n            System.out.println(listes[i]);\n        }\n    }\n\n    // classe de comparaison de listes \u00e9lectorales\n    class CompareListesElectorales implements Comparator&lt;ListeElectorale&gt; {\n\n        // comparaison de deux listes candidates selon le nombre de voix\n        @Override\n        public int compare(ListeElectorale listeElectorale1, ListeElectorale listeElectorale2) {\n            // on compare les voix de ces deux listes\n            int nbVoix1 = listeElectorale1.getVoix();\n            int nbVoix2 = listeElectorale2.getVoix();\n            if (nbVoix1 &lt; nbVoix2) {\n                return +1;\n            } else {\n                if (nbVoix1 &gt; nbVoix2)\n                    return -1;\n                else\n                    return 0;\n            }\n        }\n    }\n\n}\n</code></pre> <p>La classe ElectionsConsole bouge tr\u00e8s peu. Il faut simplement se rappeler que maintenant les m\u00e9thodes de la couche [m\u00e9tier] r\u00e9clament comme premier param\u00e8tre, un utilisateur (lignes 31, 49, 51). Celui-ci est fourni par l'injection des lignes 21-22. L'utilisateur inject\u00e9 est celui autoris\u00e9 \u00e0 interroger le serveur web / jSON.</p> <p>Travail \u00e0 faire\u00a0: testez l'application console (pensez \u00e0 lancer auparavant le serveur s\u00e9curis\u00e9).</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#176-le-client-du-serveur-securise-avec-une-couche-swing","title":"17.6. Le client du serveur s\u00e9curis\u00e9 avec une couche [swing]","text":"<p>Nous cr\u00e9ons un nouveau projet Netbeans [elections-swing-metier-dao-security-webjson] par un copy / paste du projet [elections-ui-metier-dao-webjson]\u00a0:</p> <p>Dans le nouveau projet [2]\u00a0:</p> <ul> <li>supprimez les packages [elections.client.dao, elections.client.metier, elections.client.entities]\u00a0;</li> <li>dans le package [elections.client.ui], supprimez les classes [ElectionsConsole, IElectionsUI]\u00a0;</li> <li>renommez les packages comme indiqu\u00e9 en [2]\u00a0;</li> <li>dans le package [elections.security.client.swing], renommez la classe [AbstractElectionsSwing] qui impl\u00e9mente l'interface graphique en [AbstractElectionsMainForm] et la classe [ElectionsSwing] qui impl\u00e9mente les gestionnaires des \u00e9v\u00e9nements de l'interface graphque en [ElectionsMainForm]\u00a0;</li> <li>r\u00e9glez les probl\u00e8mes d'import dans les diverses classes par [clic droit / Fix Imports]\u00a0; A ce stade, il y a de nombreuses erreurs.</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1761-configuration-maven","title":"17.6.1. Configuration Maven","text":"<p>Le fichier [pom.xml] \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n    &lt;artifactId&gt;elections-swing-metier-dao-security-webjson&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;elections-swing-metier-dao-security-webjson&lt;/name&gt;\n    &lt;description&gt;couche swing du client web / jSON&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.2.7.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;istia.st.elections&lt;/groupId&gt;\n            &lt;artifactId&gt;elections-console-metier-dao-security-webjson&lt;/artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;version&gt;2.18.1&lt;/version&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <ul> <li>lignes 4-8\u00a0: l'identit\u00e9 Maven du nouveau projet\u00a0;</li> <li>lignes 22-26\u00a0: une d\u00e9pendance sur le projet console que nous venons d'\u00e9tudier au paragraphe 17.5, page 339\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1762-configuration-spring","title":"17.6.2. Configuration Spring","text":"<p>Ce projet utilise la configuration Spring du projet console qu'il importe (cf paragraphe 17.5.2, page 341).</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1763-les-vues-de-lapplication-swing","title":"17.6.3. Les vues de l'application Swing","text":"<p>Ce projet va utiliser deux vues\u00a0:</p> <ul> <li>la vue [1] de connexion est nouvelle. Elle sert \u00e0 authentifier l'utilisateur qui veut utiliser l'application. Elle utilise les classes\u00a0:</li> <li>[AbstractElectionsConnectForm] qui impl\u00e9mente la vue\u00a0;</li> <li>[ElectionsConnectForm] qui g\u00e8re les \u00e9v\u00e9nements de la vue\u00a0;</li> <li>la vue [2] est connue. C'est celle utilis\u00e9e jusqu'\u00e0 maintenant. Elle utilise les classes\u00a0:</li> <li>[AbstractElectionsMainForm] qui impl\u00e9mente la vue\u00a0;</li> <li>[ElectionsMainForm] qui g\u00e8re les \u00e9v\u00e9nements de la vue\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1764-la-session","title":"17.6.4. La session","text":"<p>Lorsqu'une application Swing a plusieurs vues, il faut trouver un moyen pour qu'une vue puisse passer de l'information \u00e0 une autre vue. Nous utilisons un concept utilis\u00e9 en d\u00e9veloppement web\u00a0: la session qui permet aux vues associ\u00e9es \u00e0 un utilisateur pr\u00e9cis de  partager de l'information. Ce concept sera impl\u00e9ment\u00e9 ici \u00e0 l'aide d'un singleton Spring qui sera inject\u00e9 dans les deux classes qui g\u00e8rent les \u00e9v\u00e9nements des deux vues\u00a0:</p> <pre><code>package elections.security.client.swing;\n\nimport elections.security.client.entities.User;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class UiSession {\n\n    // l'utilisateur connect\u00e9\n  private User user;\n\n  // getters et setters\n... \n}\n</code></pre> <ul> <li>ligne 6\u00a0: la classe [UiSession] est un composant Spring\u00a0;</li> <li>ligne 10\u00a0: elle ne sert qu'\u00e0 une chose\u00a0: m\u00e9moriser l'utilisateur qui se connecte avec la vue [1]. La vue [2] qui a besoin de conna\u00eetre celui-ci ira le chercher l\u00e0\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1765-la-classe-de-boot","title":"17.6.5. La classe de boot","text":"<p>La classe de boot de l'application graphique est la suivante\u00a0:</p> <pre><code>package elections.security.client.boot;\n\nimport elections.security.client.console.IElectionsUI;\n\npublic class BootElectionsSwing extends AbstractBootElections {\n    public static void main(String[] arguments) {\n        new BootElectionsSwing().run();\n    }\n\n    @Override\n    protected IElectionsUI getUI() {\n        return ctx.getBean(\"electionsConnectForm\", IElectionsUI.class);\n    }\n}\n</code></pre> <ul> <li>ligne 5\u00a0: la classe [BootElectionsSwing] \u00e9tend la classe [AbstractBootElections] d\u00e9finit dans le projet console pr\u00e9sent dans les d\u00e9pendances du projet\u00a0;</li> <li>lignes 10-13\u00a0: la classe [BootElectionsSwing] fera afficher la vue de connexion [ElectionsConnectForm]\u00a0;</li> <li>lignes 6-8\u00a0: c'est la m\u00e9thode [run] de cette classe qui sera ex\u00e9cut\u00e9e\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1766-la-classe-electionsmainform","title":"17.6.6. La classe [ElectionsMainForm]","text":"<p>La classe [ElectionsMainForm] est celle qui s'appelait auparavant [ElectionsSwing]. Elle g\u00e8re les \u00e9v\u00e9nements de la vue [AbstractElectionsMainForm]. Son code \u00e9volue de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.security.client.swing;\n\nimport elections.security.client.console.IElectionsUI;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.swing.DefaultListModel;\nimport javax.swing.JLabel;\nimport javax.swing.JMenuItem;\nimport javax.swing.JOptionPane;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport elections.security.client.entities.ElectionsException;\nimport elections.security.client.entities.ListeElectorale;\nimport elections.security.client.entities.User;\nimport elections.security.client.metier.IElectionsMetier;\n\n@Component\npublic class ElectionsMainForm extends AbstractElectionsMainForm implements IElectionsUI {\n\n  private static final long serialVersionUID = 1L;\n\n  // r\u00e9f\u00e9rence sur la couche [m\u00e9tier]\n  @Autowired\n  private IElectionsMetier metier;\n\n  // session UI\n  @Autowired\n  private UiSession uiSession;\n\n  // utilisateur connect\u00e9\n  private User user;\n\n  // mod\u00e8les des listes JList\n  private DefaultListModel&lt;String&gt; mod\u00e8leNomsVoix = null;\n  private DefaultListModel&lt;String&gt; mod\u00e8leR\u00e9sultats = null;\n\n  // les listes en comp\u00e9tition\n  private ListeElectorale[] listes;\n\n  // listes saisies par l'utilisateur\n  private final List&lt;ListeElectorale&gt; listesSaisies = new ArrayList&lt;&gt;();\n  private ListeElectorale[] tListesSaisies;\n\n  // initialisations\n  @Override\n  protected void init() {\n    // g\u00e9n\u00e9ration des composants par la classe parent\n    super.init();\n    // initialisations locales\n    mod\u00e8leNomsVoix = new DefaultListModel&lt;&gt;();\n    jListNomsVoix.setModel(mod\u00e8leNomsVoix);\n    mod\u00e8leR\u00e9sultats = new DefaultListModel&lt;&gt;();\n    jListResultats.setModel(mod\u00e8leR\u00e9sultats);\n    String info;\n    boolean erreur = false;\n    try {\n      // on demande les listes \u00e0 la couche [m\u00e9tier]\n      listes = metier.getListesElectorales(user);\n      // on associe les noms des listes au combo jComboBoxNomsListes\n      for (int i = 0; i &lt; listes.length; i++) {\n        jComboBoxNomsListes.addItem(String.format(\"%s - %s\", listes[i].getId(), listes[i].getNom()));\n      }\n      // ainsi que les param\u00e8tres de l'\u00e9lection\n      int nbSiegesAPourvoir = metier.getNbSiegesAPourvoir(user);\n      double seuilElectoral = metier.getSeuilElectoral(user);\n      // on initialise les labels li\u00e9s \u00e0 ces deux informations\n      jLabelSAP.setText(jLabelSAP.getText() + nbSiegesAPourvoir);\n      jLabelSE.setText(jLabelSE.getText() + seuilElectoral);\n      // message de succ\u00e8s\n      info = \"Source de donn\u00e9es lue avec succ\u00e8s\";\n    } catch (ElectionsException ex1) {\n      // on note l'erreur\n      info = getInfoForException(\"Les erreurs suivantes se sont produites :\", ex1);\n      erreur = true;\n    } catch (RuntimeException ex2) {\n      // on note l'erreur\n      info = getInfoForException(\"Les erreurs suivantes se sont produites :\", ex2);\n      erreur = true;\n    }\n    // erreur ?\n    if (erreur) {\n      // on affiche l'info\n      jTextPaneMessages.setText(info);\n      jTextPaneMessages.setCaretPosition(0);\n      return;\n    } else {\n      jTextPaneMessages.setText(\"\");\n    }\n    // \u00e9tat formulaire\n    Utilitaires.setEnabled(new JLabel[]{jLabelAjouter, jLabelCalculer, jLabelEnregistrer, jLabelSupprimer}, false);\n    Utilitaires.setEnabled(\n            new JMenuItem[]{jMenuItemAjouter, jMenuItemCalculer, jMenuItemEnregistrer, jMenuItemSupprimer}, false);\n    // centrer la fen\u00eatre\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    Dimension frameSize = getSize();\n    if (frameSize.height &gt; screenSize.height) {\n      frameSize.height = screenSize.height;\n    }\n    if (frameSize.width &gt; screenSize.width) {\n      frameSize.width = screenSize.width;\n    }\n    setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);\n\n  }\n...\n\n  @Override\n  public void run() {\n    // m\u00e9morisation utilisateur\n    user = uiSession.getUser();\n    // initialisation fen\u00eatre\n    init();\n    setVisible(true);\n  }\n}\n</code></pre> <ul> <li>lignes 32-33\u00a0: injection de la session de l'application\u00a0;</li> <li>lignes 112-119\u00a0: la vue sera activ\u00e9e comme pr\u00e9c\u00e9demment par sa m\u00e9thode [run]\u00a0;</li> <li>ligne 115\u00a0: on r\u00e9cup\u00e8re l'utilisateur dans la session. Celui-ci y aura \u00e9t\u00e9 mis par le code de la vue de connexion [ElectionsConnectForm]. Le code ensuite est modifi\u00e9 pour que le 1er param\u00e8tre des appels \u00e0 la couche [m\u00e9tier] soient cet utilisateur (lignes 63, 69-70 par exemple)\u00a0;</li> </ul>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1767-la-vue-abstractelectionsconnectform","title":"17.6.7. La vue [AbstractElectionsConnectForm]","text":"<p>Construisez avec Netbeans le formulaire suivant\u00a0:</p> <p>La classe n'impl\u00e9mentera pas elle-m\u00eame la m\u00e9thode g\u00e9rant le clic sur l'option de menu [Connexion]. Elle fera appel \u00e0 une m\u00e9thode [doConnecter] d\u00e9clar\u00e9e abstraite et la classe de la vue sera elle-m\u00eame d\u00e9clar\u00e9e abstraite. On supprimera la m\u00e9thode statique [main] qui a \u00e9t\u00e9 g\u00e9n\u00e9r\u00e9e automatiquement.</p>"},{"location":"td-securisation-du-serveur-web--json-des-elections.html#1768-la-gestion-des-evenements-de-la-vue-de-connexion","title":"17.6.8. La gestion des \u00e9v\u00e9nements de la vue de connexion","text":"<p>La classe [ElectionsConnectForm] impl\u00e9mente la gestion des \u00e9v\u00e9nements de la vue de connexion de la fa\u00e7on suivante\u00a0:</p> <pre><code>package elections.security.client.swing;\n\nimport elections.security.client.console.IElectionsUI;\nimport elections.security.client.entities.ElectionsException;\nimport elections.security.client.entities.User;\nimport elections.security.client.metier.IElectionsMetier;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport javax.swing.SwingUtilities;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class ElectionsConnectForm extends AbstractElectionsConnectForm implements IElectionsUI {\n\n    private static final long serialVersionUID = 1L;\n\n    // r\u00e9f\u00e9rence sur la couche [m\u00e9tier]\n  @Autowired\n  private IElectionsMetier metier;\n\n  // utilisateur connect\u00e9\n  private User user;\n\n  // formulaire principal\n  @Autowired\n  private ElectionsMainForm electionsMainForm;\n\n  // session UI\n  @Autowired\n  private UiSession uiSession;\n\n  @Override\n  protected void doConnect() {\n    String info = null;\n    try {\n      if (isPageValid()) {\n        // authentification de l'utilisateur\n        metier.authenticate(user);\n        // on m\u00e9morise l'utilisateur dans la session\n        uiSession.setUser(user);\n        // la vue de connexion est cach\u00e9e\n        setVisible(false);\n        // la vue principale est affich\u00e9e\n        electionsMainForm.run();\n      }\n    } catch (ElectionsException ex1) {\n      // on note l'erreur\n      info = getInfoForException(\"Les erreurs suivantes se sont produites :\", ex1);\n    } catch (RuntimeException ex2) {\n      // on note l'erreur\n      info = getInfoForException(\"Les erreurs suivantes se sont produites :\", ex2);\n    }\n    // erreur ?\n    if (info != null) {\n      // on affiche l'info\n      jTextPaneErreurs.setText(info);\n      jTextPaneErreurs.setCaretPosition(0);\n    }\n  }\n\n  // initialisations\n  @Override\n  protected void init() {\n    // g\u00e9n\u00e9ration des composants par la classe parent\n    super.init();\n    // initialisations locales\n...\n    // centrer la fen\u00eatre\n...\n  }\n\n  @Override\n  public void run() {\n    // on affiche l'interface graphique\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        init();\n        setVisible(true);\n      }\n    });\n  }\n\n  private boolean isPageValid() {\n    ...\n  }\n\n  private String getInfoForException(String message, ElectionsException ex) {\n...\n  }\n\n  private String getInfoForException(String message, RuntimeException ex) {\n...\n  }\n\n}\n</code></pre> <ul> <li>lignes 73-82\u00a0: la m\u00e9thode [run] qui sera appel\u00e9e par la classe de boot [BootElectionsSwing]\u00a0;</li> <li>lignes 26-27\u00a0: injection d'une r\u00e9f\u00e9rence sur la vue n\u00b0 2 qui devra \u00eatre affich\u00e9e si l'utilisateur est reconnu\u00a0;</li> <li>lignes 30-31\u00a0: injection de la session de l'application\u00a0;</li> <li>ligne 84\u00a0: la m\u00e9thode [isPageValid] fait deux choses\u00a0:</li> <li>elle v\u00e9rifie que l'identifiant n'est pas vide (le mot de passe peut l'\u00eatre lui)\u00a0;</li> <li>instancie avec les saisies le champ User de la ligne 23\u00a0;</li> </ul> <p>Travail \u00e0 faire\u00a0: compl\u00e9tez le code de la classe.</p> <p>Travail \u00e0 faire\u00a0: Testez l'application.</p>"}]}